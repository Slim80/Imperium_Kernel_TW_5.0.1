
ipc/namespace.c: * accessing it through the VFS, are protected with mq_lock.
ipc/mqueue.c:	struct inode vfs_inode;
ipc/mqueue.c:	return container_of(inode, struct mqueue_inode_info, vfs_inode);
ipc/mqueue.c:	inode_init_once(&p->vfs_inode);
ipc/mqueue.c:	return &ei->vfs_inode;
ipc/mqueue.c:	ret = vfs_create(dir->d_inode, dentry, mode, NULL);
ipc/mqueue.c:	err = vfs_unlink(dentry->d_parent->d_inode, dentry);
include/linux/file.h:struct vfsmount;
include/linux/proc_fs.h:	struct inode vfs_inode;
include/linux/proc_fs.h:	return container_of(inode, struct proc_inode, vfs_inode);
include/linux/gpio_keys.h:/* DVFS feature : HOME_KEY BOOSTER */
include/linux/namei.h:struct vfsmount;
include/linux/namei.h:extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
include/linux/dcache.h:struct vfsmount;
include/linux/dcache.h:	struct vfsmount *(*d_automount)(struct path *);
include/linux/dcache.h: * FUrther descriptions are found in Documentation/filesystems/vfs.txt.
include/linux/dcache.h:extern int sysctl_vfs_cache_pressure;
include/linux/magic.h:#define BDEVFS_MAGIC            0x62646576
include/linux/dcookies.h: * Convert the given dentry/vfsmount pair into
include/linux/mount.h:struct vfsmount;
include/linux/mount.h:#define MNT_SHARED	0x1000	/* if the vfsmount is a shared mount */
include/linux/mount.h:#define MNT_UNBINDABLE	0x2000	/* if the vfsmount is a unbindable mount */
include/linux/mount.h:struct vfsmount {
include/linux/mount.h:extern int mnt_want_write(struct vfsmount *mnt);
include/linux/mount.h:extern int mnt_clone_write(struct vfsmount *mnt);
include/linux/mount.h:extern void mnt_drop_write(struct vfsmount *mnt);
include/linux/mount.h:extern void mntput(struct vfsmount *mnt);
include/linux/mount.h:extern struct vfsmount *mntget(struct vfsmount *mnt);
include/linux/mount.h:extern void mnt_pin(struct vfsmount *mnt);
include/linux/mount.h:extern void mnt_unpin(struct vfsmount *mnt);
include/linux/mount.h:extern int __mnt_is_readonly(struct vfsmount *mnt);
include/linux/mount.h:extern struct vfsmount *vfs_kern_mount(struct file_system_type *type,
include/linux/mount.h:extern void mnt_set_expiry(struct vfsmount *mnt, struct list_head *expiry_list);
include/linux/mfd/db8500-prcmu.h: * enum dvfs_stat - DVFS status messages definition
include/linux/mfd/db8500-prcmu.h: * @DVFS_GO: A state transition DVFS is on going
include/linux/mfd/db8500-prcmu.h: * @DVFS_ARM100OPPOK: The state transition DVFS has been completed for 100OPP
include/linux/mfd/db8500-prcmu.h: * @DVFS_ARM50OPPOK: The state transition DVFS has been completed for 50OPP
include/linux/mfd/db8500-prcmu.h: * @DVFS_ARMEXTCLKOK: The state transition DVFS has been completed for EXTCLK
include/linux/mfd/db8500-prcmu.h: * @DVFS_NOCHGTCLKOK: The state transition DVFS has been completed for
include/linux/mfd/db8500-prcmu.h: * @DVFS_INITSTATUS: Value init
include/linux/mfd/db8500-prcmu.h:enum dvfs_stat {
include/linux/mfd/db8500-prcmu.h:	DVFS_GO = 0xFF,
include/linux/mfd/db8500-prcmu.h:	DVFS_ARM100OPPOK = 0xFE,
include/linux/mfd/db8500-prcmu.h:	DVFS_ARM50OPPOK = 0xFD,
include/linux/mfd/db8500-prcmu.h:	DVFS_ARMEXTCLKOK = 0xFC,
include/linux/mfd/db8500-prcmu.h:	DVFS_NOCHGTCLKOK = 0xFB,
include/linux/mfd/db8500-prcmu.h:	DVFS_INITSTATUS = 0x00
include/linux/power/max17042_battery.h:	MAX17042_VFSOC0		= 0x48,
include/linux/power/max17042_battery.h:	MAX17042_VFSOC0Enable	= 0x60,
include/linux/power/max17042_battery.h:	MAX17042_VFSOC		= 0xFF,
include/linux/relay.h:	size_t early_bytes;		/* bytes consumed before VFS inited */
include/linux/capability.h:#define VFS_CAP_REVISION_MASK	0xFF000000
include/linux/capability.h:#define VFS_CAP_REVISION_SHIFT	24
include/linux/capability.h:#define VFS_CAP_FLAGS_MASK	~VFS_CAP_REVISION_MASK
include/linux/capability.h:#define VFS_CAP_FLAGS_EFFECTIVE	0x000001
include/linux/capability.h:#define VFS_CAP_REVISION_1	0x01000000
include/linux/capability.h:#define VFS_CAP_U32_1           1
include/linux/capability.h:#define XATTR_CAPS_SZ_1         (sizeof(__le32)*(1 + 2*VFS_CAP_U32_1))
include/linux/capability.h:#define VFS_CAP_REVISION_2	0x02000000
include/linux/capability.h:#define VFS_CAP_U32_2           2
include/linux/capability.h:#define XATTR_CAPS_SZ_2         (sizeof(__le32)*(1 + 2*VFS_CAP_U32_2))
include/linux/capability.h:#define VFS_CAP_U32             VFS_CAP_U32_2
include/linux/capability.h:#define VFS_CAP_REVISION	VFS_CAP_REVISION_2
include/linux/capability.h:struct vfs_cap_data {
include/linux/capability.h:	} data[VFS_CAP_U32];
include/linux/capability.h:/* exact same as vfs_cap_data but in cpu endian and always filled completely */
include/linux/capability.h:struct cpu_vfs_cap_data {
include/linux/capability.h:/* Without VFS support for capabilities:
include/linux/capability.h: * With VFS support for capabilities (neither of above, but)
include/linux/capability.h:extern int get_vfs_caps_from_disk(const struct dentry *dentry, struct cpu_vfs_cap_data *cpu_caps);
include/linux/quota.h:#define	QFMT_VFS_OLD 1
include/linux/quota.h:#define	QFMT_VFS_V0 2
include/linux/quota.h:#define	QFMT_VFS_V1 4
include/linux/quota.h: * (over VFS all formats) */
include/linux/quota.h:	{QFMT_VFS_OLD, "quota_v1"},\
include/linux/quota.h:	{QFMT_VFS_V0, "quota_v2"},\
include/linux/quota.h:	{QFMT_VFS_V1, "quota_v2"},\
include/linux/pid_namespace.h:	struct vfsmount *proc_mnt;
include/linux/atmel_tc.h:#define     ATMEL_TC_COVFS	(1 <<  0)	/* counter overflow */
include/linux/exportfs.h:struct vfsmount;
include/linux/exportfs.h:extern struct dentry *exportfs_decode_fh(struct vfsmount *mnt, struct fid *fid,
include/linux/sunrpc/auth.h:/* Work around the lack of a VFS credential */
include/linux/sunrpc/rpc_pipe_fs.h:	struct inode vfs_inode;
include/linux/sunrpc/rpc_pipe_fs.h:	return container_of(inode, struct rpc_inode, vfs_inode);
include/linux/cpufreq.h:#ifdef CONFIG_SEC_DVFS
include/linux/cpufreq.h:	DVFS_NO_ID			= 0,
include/linux/cpufreq.h:	DVFS_TOUCH_ID			= 0x00000001,
include/linux/cpufreq.h:	DVFS_APPS_MIN_ID		= 0x00000002,
include/linux/cpufreq.h:	DVFS_APPS_MAX_ID		= 0x00000004,
include/linux/cpufreq.h:	DVFS_UNICPU_ID			= 0x00000008,
include/linux/cpufreq.h:	DVFS_THERMALD_ID		= 0x00000100,
include/linux/cpufreq.h:	DVFS_MAX_ID
include/linux/acct.h:struct vfsmount;
include/linux/acct.h:extern void acct_auto_close_mnt(struct vfsmount *m);
include/linux/battery/fuelgauge/max17042_fuelgauge.h:#define VFSOC_REG				0xFF
include/linux/battery/fuelgauge/max17042_fuelgauge.h:	u32 previous_vfsoc;
include/linux/battery/fuelgauge/max17042_fuelgauge.h:#define VFSOC_FOR_FULLCAP_LEARNING	90
include/linux/battery/fuelgauge/max17050_fuelgauge.h:#define VFSOC_REG				0xFF
include/linux/battery/fuelgauge/max17050_fuelgauge.h:#define VFSOC_FOR_FULLCAP_LEARNING	950
include/linux/shmem_fs.h:	struct inode		vfs_inode;
include/linux/shmem_fs.h:	return container_of(inode, struct shmem_inode_info, vfs_inode);
include/linux/cred.h:	uid_t		fsuid;		/* UID for VFS ops */
include/linux/cred.h:	gid_t		fsgid;		/* GID for VFS ops */
include/linux/audit.h:#define AUDIT_AVC_PATH		1402	/* dentry, vfsmount pair from avc */
include/linux/unix_diag.h:#define UDIAG_SHOW_VFS		0x00000002	/* show VFS inode info */
include/linux/unix_diag.h:	UNIX_DIAG_VFS,
include/linux/unix_diag.h:struct unix_diag_vfs {
include/linux/unix_diag.h:	__u32	udiag_vfs_ino;
include/linux/unix_diag.h:	__u32	udiag_vfs_dev;
include/linux/sysctl.h:	VM_VFS_CACHE_PRESSURE=26, /* dcache/icache reclaim pressure */
include/linux/vfs.h:#ifndef _LINUX_VFS_H
include/linux/vfs.h:#define _LINUX_VFS_H
include/linux/fsnotify_backend.h:				  struct fsnotify_mark *vfsmount_mark,
include/linux/fsnotify_backend.h:			    struct fsnotify_mark *vfsmount_mark,
include/linux/fsnotify_backend.h:struct fsnotify_vfsmount_mark {
include/linux/fsnotify_backend.h:	struct vfsmount *mnt;		/* vfsmount this mark is associated with */
include/linux/fsnotify_backend.h:		struct fsnotify_vfsmount_mark m;
include/linux/fsnotify_backend.h:#define FSNOTIFY_MARK_FLAG_VFSMOUNT		0x02
include/linux/fsnotify_backend.h:	unsigned int flags;		/* vfsmount or inode mark? */
include/linux/fsnotify_backend.h:/* called from the vfs helpers */
include/linux/fsnotify_backend.h:extern void __fsnotify_vfsmount_delete(struct vfsmount *mnt);
include/linux/fsnotify_backend.h:/* run all marks associated with a vfsmount and update mnt->mnt_fsnotify_mask */
include/linux/fsnotify_backend.h:extern void fsnotify_recalc_vfsmount_mask(struct vfsmount *mnt);
include/linux/fsnotify_backend.h:/* find (and take a reference) to a mark associated with group and vfsmount */
include/linux/fsnotify_backend.h:extern struct fsnotify_mark *fsnotify_find_vfsmount_mark(struct fsnotify_group *group, struct vfsmount *mnt);
include/linux/fsnotify_backend.h:			     struct inode *inode, struct vfsmount *mnt, int allow_dups);
include/linux/fsnotify_backend.h:/* run all the marks in a group, and clear all of the vfsmount marks */
include/linux/fsnotify_backend.h:extern void fsnotify_clear_vfsmount_marks_by_group(struct fsnotify_group *group);
include/linux/fsnotify_backend.h:static inline void __fsnotify_vfsmount_delete(struct vfsmount *mnt)
include/linux/pci_regs.h:#define PCI_SRIOV_INITIAL_VF	0x0c	/* Initial VFs */
include/linux/pci_regs.h:#define PCI_SRIOV_TOTAL_VF	0x0e	/* Total VFs */
include/linux/pci_regs.h:#define PCI_SRIOV_NUM_VF	0x10	/* Number of VFs */
include/linux/fs.h:#define MS_POSIXACL	(1<<16)	/* VFS does not apply the umask */
include/linux/fs.h:struct vfsmount;
include/linux/fs.h: * about.  Basically, these are the attributes that the VFS layer can
include/linux/fs.h: * 0: the object of the current VFS operation
include/linux/fs.h:#define f_vfsmnt	f_path.mnt
include/linux/fs.h: * Special return value from posix_lock_file() and vfs_lock_file() for
include/linux/fs.h:extern int vfs_test_lock(struct file *, struct file_lock *);
include/linux/fs.h:extern int vfs_lock_file(struct file *, unsigned int, struct file_lock *, struct file_lock *);
include/linux/fs.h:extern int vfs_cancel_lock(struct file *filp, struct file_lock *fl);
include/linux/fs.h:extern int vfs_setlease(struct file *, long, struct file_lock **);
include/linux/fs.h:static inline int vfs_test_lock(struct file *filp, struct file_lock *fl)
include/linux/fs.h:static inline int vfs_lock_file(struct file *filp, unsigned int cmd,
include/linux/fs.h:static inline int vfs_cancel_lock(struct file *filp, struct file_lock *fl)
include/linux/fs.h:static inline int vfs_setlease(struct file *filp, long arg,
include/linux/fs.h:	 * The next field is for VFS *only*. No filesystems have any business
include/linux/fs.h:	struct mutex s_vfs_rename_mutex;	/* Kludge */
include/linux/fs.h:#define vfs_check_frozen(sb, level) \
include/linux/fs.h: * until VFS tracks user namespaces for inodes, just make all files
include/linux/fs.h: * VFS helper functions..
include/linux/fs.h:extern int vfs_create(struct inode *, struct dentry *, umode_t, struct nameidata *);
include/linux/fs.h:extern int vfs_mkdir(struct inode *, struct dentry *, umode_t);
include/linux/fs.h:extern int vfs_mknod(struct inode *, struct dentry *, umode_t, dev_t);
include/linux/fs.h:extern int vfs_symlink(struct inode *, struct dentry *, const char *);
include/linux/fs.h:extern int vfs_link(struct dentry *, struct inode *, struct dentry *);
include/linux/fs.h:extern int vfs_rmdir(struct inode *, struct dentry *);
include/linux/fs.h:extern int vfs_unlink(struct inode *, struct dentry *);
include/linux/fs.h:extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
include/linux/fs.h: * VFS dentry helper functions.
include/linux/fs.h: * VFS file helper functions.
include/linux/fs.h: * VFS FS_IOC_FIEMAP helper definitions.
include/linux/fs.h:	int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
include/linux/fs.h:extern ssize_t vfs_read(struct file *, char __user *, size_t, loff_t *);
include/linux/fs.h:extern ssize_t vfs_write(struct file *, const char __user *, size_t, loff_t *);
include/linux/fs.h:extern ssize_t vfs_readv(struct file *, const struct iovec __user *,
include/linux/fs.h:extern ssize_t vfs_writev(struct file *, const struct iovec __user *,
include/linux/fs.h:	struct lock_class_key s_vfs_rename_key;
include/linux/fs.h:extern struct dentry *mount_subtree(struct vfsmount *mnt, const char *path);
include/linux/fs.h:extern struct vfsmount *kern_mount_data(struct file_system_type *, void *data);
include/linux/fs.h:extern void kern_unmount(struct vfsmount *mnt);
include/linux/fs.h:extern int may_umount_tree(struct vfsmount *);
include/linux/fs.h:extern int may_umount(struct vfsmount *);
include/linux/fs.h:extern struct vfsmount *collect_mounts(struct path *);
include/linux/fs.h:extern void drop_collected_mounts(struct vfsmount *);
include/linux/fs.h:extern int iterate_mounts(int (*)(struct vfsmount *, void *), void *,
include/linux/fs.h:			  struct vfsmount *);
include/linux/fs.h:extern int vfs_statfs(struct path *, struct kstatfs *);
include/linux/fs.h:extern int vfs_ustat(dev_t, struct kstatfs *);
include/linux/fs.h:extern bool our_mnt(struct vfsmount *mnt);
include/linux/fs.h:extern struct file *file_open_root(struct dentry *, struct vfsmount *,
include/linux/fs.h:extern struct file * dentry_open(struct dentry *, struct vfsmount *, int,
include/linux/fs.h:extern void __init vfs_caches_init_early(void);
include/linux/fs.h:extern void __init vfs_caches_init(unsigned long);
include/linux/fs.h:extern int vfs_fsync_range(struct file *file, loff_t start, loff_t end,
include/linux/fs.h:extern int vfs_fsync(struct file *file, int datasync);
include/linux/fs.h:extern loff_t vfs_llseek(struct file *file, loff_t offset, int origin);
include/linux/fs.h:extern int vfs_readlink(struct dentry *, char __user *, int, const char *);
include/linux/fs.h:extern int vfs_follow_link(struct nameidata *, const char *);
include/linux/fs.h:extern int vfs_getattr(struct vfsmount *, struct dentry *, struct kstat *);
include/linux/fs.h:extern int vfs_readdir(struct file *, filldir_t, void *);
include/linux/fs.h:extern int vfs_stat(const char __user *, struct kstat *);
include/linux/fs.h:extern int vfs_lstat(const char __user *, struct kstat *);
include/linux/fs.h:extern int vfs_fstat(unsigned int, struct kstat *);
include/linux/fs.h:extern int vfs_fstatat(int , const char __user *, struct kstat *, int);
include/linux/fs.h:extern int do_vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd,
include/linux/fs.h:extern int simple_getattr(struct vfsmount *, struct dentry *, struct kstat *);
include/linux/fs.h:extern int simple_pin_fs(struct file_system_type *, struct vfsmount **mount, int *count);
include/linux/fs.h:extern void simple_release_fs(struct vfsmount **mount, int *count);
include/linux/path.h:struct vfsmount;
include/linux/path.h:	struct vfsmount *mnt;
include/linux/fdtable.h:struct vfsmount;
include/linux/lockd/lockd.h:	struct file *		f_file;		/* VFS file pointer */
include/linux/lockd/lockd.h:	unsigned char		b_granted;	/* VFS granted lock */
include/linux/devfreq.h: * devfreq: Generic Dynamic Voltage and Frequency Scaling (DVFS) Framework
include/linux/jbd2.h:	/* VFS inode this inode belongs to [constant during the lifetime
include/linux/jbd2.h:	struct inode *i_vfs_inode;
include/linux/nfs_iostat.h: * show the rate at which VFS requests are made, and how often the
include/linux/nfs_iostat.h:	NFSIOS_VFSOPEN,
include/linux/nfs_iostat.h:	NFSIOS_VFSLOOKUP,
include/linux/nfs_iostat.h:	NFSIOS_VFSACCESS,
include/linux/nfs_iostat.h:	NFSIOS_VFSUPDATEPAGE,
include/linux/nfs_iostat.h:	NFSIOS_VFSREADPAGE,
include/linux/nfs_iostat.h:	NFSIOS_VFSREADPAGES,
include/linux/nfs_iostat.h:	NFSIOS_VFSWRITEPAGE,
include/linux/nfs_iostat.h:	NFSIOS_VFSWRITEPAGES,
include/linux/nfs_iostat.h:	NFSIOS_VFSGETDENTS,
include/linux/nfs_iostat.h:	NFSIOS_VFSSETATTR,
include/linux/nfs_iostat.h:	NFSIOS_VFSFLUSH,
include/linux/nfs_iostat.h:	NFSIOS_VFSFSYNC,
include/linux/nfs_iostat.h:	NFSIOS_VFSLOCK,
include/linux/nfs_iostat.h:	NFSIOS_VFSRELEASE,
include/linux/cdrom.h:	unsigned int vfs_events;	/* cached events for vfs path */
include/linux/security.h:struct vfsmount;
include/linux/security.h: *	the post_create/mkdir/... hooks called by the VFS.  The hook function
include/linux/security.h: *	@mnt contains the vfsmnt structure.
include/linux/security.h: *	@mnt is the vfsmount where the dentry was looked up
include/linux/security.h: * 	fs code as needed (via __vfs_setxattr_noperm) to update any backing
include/linux/security.h:	int (*sb_umount) (struct vfsmount *mnt, int flags);
include/linux/security.h:	int (*inode_getattr) (struct vfsmount *mnt, struct dentry *dentry);
include/linux/security.h:int security_sb_umount(struct vfsmount *mnt, int flags);
include/linux/security.h:int security_inode_getattr(struct vfsmount *mnt, struct dentry *dentry);
include/linux/security.h:static inline int security_sb_umount(struct vfsmount *mnt, int flags)
include/linux/security.h:static inline int security_inode_getattr(struct vfsmount *mnt,
include/linux/i2c/cypress_touchkey.h:/* DVFS feature : TOUCH BOOSTER */
include/linux/i2c/mxts_msm8930.h:#ifdef CONFIG_SEC_DVFS
include/linux/i2c/mxts_msm8930.h:#ifdef CONFIG_SEC_DVFS
include/linux/i2c/mxts_msm8930.h:#define DVFS_STAGE_DUAL		2
include/linux/i2c/mxts_msm8930.h:#define DVFS_STAGE_SINGLE	1
include/linux/i2c/mxts_msm8930.h:#define DVFS_STAGE_NONE		0
include/linux/i2c/mxts_msm8930.h:	struct delayed_work	work_dvfs_off;
include/linux/i2c/mxts_msm8930.h:	struct delayed_work	work_dvfs_chg;
include/linux/i2c/mxts_msm8930.h:	struct mutex	dvfs_lock;
include/linux/i2c/mxts_msm8930.h:	bool	dvfs_lock_status;
include/linux/i2c/mxts_msm8930.h:	int	dvfs_old_stauts;
include/linux/i2c/mxts_msm8930.h:	int	dvfs_boost_mode;
include/linux/i2c/mxts_msm8930.h:	int	dvfs_freq;
include/linux/i2c/mxts.h:	struct delayed_work dvfs_dwork;
include/linux/i2c/mxts.h:	struct delayed_work work_dvfs_off;
include/linux/i2c/mxts.h:	bool	dvfs_lock_status;
include/linux/i2c/mxts.h:	struct mutex dvfs_lock;
include/linux/ipc_namespace.h:	struct vfsmount	*mq_mnt;
include/linux/usbdevice_fs.h:/* usbdevfs ioctl codes */
include/linux/usbdevice_fs.h:struct usbdevfs_ctrltransfer {
include/linux/usbdevice_fs.h:struct usbdevfs_bulktransfer {
include/linux/usbdevice_fs.h:struct usbdevfs_setinterface {
include/linux/usbdevice_fs.h:struct usbdevfs_disconnectsignal {
include/linux/usbdevice_fs.h:#define USBDEVFS_MAXDRIVERNAME 255
include/linux/usbdevice_fs.h:struct usbdevfs_getdriver {
include/linux/usbdevice_fs.h:	char driver[USBDEVFS_MAXDRIVERNAME + 1];
include/linux/usbdevice_fs.h:struct usbdevfs_connectinfo {
include/linux/usbdevice_fs.h:#define USBDEVFS_URB_SHORT_NOT_OK	0x01
include/linux/usbdevice_fs.h:#define USBDEVFS_URB_ISO_ASAP		0x02
include/linux/usbdevice_fs.h:#define USBDEVFS_URB_BULK_CONTINUATION	0x04
include/linux/usbdevice_fs.h:#define USBDEVFS_URB_NO_FSBR		0x20
include/linux/usbdevice_fs.h:#define USBDEVFS_URB_ZERO_PACKET	0x40
include/linux/usbdevice_fs.h:#define USBDEVFS_URB_NO_INTERRUPT	0x80
include/linux/usbdevice_fs.h:#define USBDEVFS_URB_TYPE_ISO		   0
include/linux/usbdevice_fs.h:#define USBDEVFS_URB_TYPE_INTERRUPT	   1
include/linux/usbdevice_fs.h:#define USBDEVFS_URB_TYPE_CONTROL	   2
include/linux/usbdevice_fs.h:#define USBDEVFS_URB_TYPE_BULK		   3
include/linux/usbdevice_fs.h:struct usbdevfs_iso_packet_desc {
include/linux/usbdevice_fs.h:struct usbdevfs_urb {
include/linux/usbdevice_fs.h:	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
include/linux/usbdevice_fs.h:struct usbdevfs_ioctl {
include/linux/usbdevice_fs.h:struct usbdevfs_hub_portinfo {
include/linux/usbdevice_fs.h:struct usbdevfs_ctrltransfer32 {
include/linux/usbdevice_fs.h:struct usbdevfs_bulktransfer32 {
include/linux/usbdevice_fs.h:struct usbdevfs_disconnectsignal32 {
include/linux/usbdevice_fs.h:struct usbdevfs_urb32 {
include/linux/usbdevice_fs.h:	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
include/linux/usbdevice_fs.h:struct usbdevfs_ioctl32 {
include/linux/usbdevice_fs.h:#define USBDEVFS_CONTROL           _IOWR('U', 0, struct usbdevfs_ctrltransfer)
include/linux/usbdevice_fs.h:#define USBDEVFS_CONTROL32           _IOWR('U', 0, struct usbdevfs_ctrltransfer32)
include/linux/usbdevice_fs.h:#define USBDEVFS_BULK              _IOWR('U', 2, struct usbdevfs_bulktransfer)
include/linux/usbdevice_fs.h:#define USBDEVFS_BULK32              _IOWR('U', 2, struct usbdevfs_bulktransfer32)
include/linux/usbdevice_fs.h:#define USBDEVFS_RESETEP           _IOR('U', 3, unsigned int)
include/linux/usbdevice_fs.h:#define USBDEVFS_SETINTERFACE      _IOR('U', 4, struct usbdevfs_setinterface)
include/linux/usbdevice_fs.h:#define USBDEVFS_SETCONFIGURATION  _IOR('U', 5, unsigned int)
include/linux/usbdevice_fs.h:#define USBDEVFS_GETDRIVER         _IOW('U', 8, struct usbdevfs_getdriver)
include/linux/usbdevice_fs.h:#define USBDEVFS_SUBMITURB         _IOR('U', 10, struct usbdevfs_urb)
include/linux/usbdevice_fs.h:#define USBDEVFS_SUBMITURB32       _IOR('U', 10, struct usbdevfs_urb32)
include/linux/usbdevice_fs.h:#define USBDEVFS_DISCARDURB        _IO('U', 11)
include/linux/usbdevice_fs.h:#define USBDEVFS_REAPURB           _IOW('U', 12, void *)
include/linux/usbdevice_fs.h:#define USBDEVFS_REAPURB32         _IOW('U', 12, __u32)
include/linux/usbdevice_fs.h:#define USBDEVFS_REAPURBNDELAY     _IOW('U', 13, void *)
include/linux/usbdevice_fs.h:#define USBDEVFS_REAPURBNDELAY32   _IOW('U', 13, __u32)
include/linux/usbdevice_fs.h:#define USBDEVFS_DISCSIGNAL        _IOR('U', 14, struct usbdevfs_disconnectsignal)
include/linux/usbdevice_fs.h:#define USBDEVFS_DISCSIGNAL32      _IOR('U', 14, struct usbdevfs_disconnectsignal32)
include/linux/usbdevice_fs.h:#define USBDEVFS_CLAIMINTERFACE    _IOR('U', 15, unsigned int)
include/linux/usbdevice_fs.h:#define USBDEVFS_RELEASEINTERFACE  _IOR('U', 16, unsigned int)
include/linux/usbdevice_fs.h:#define USBDEVFS_CONNECTINFO       _IOW('U', 17, struct usbdevfs_connectinfo)
include/linux/usbdevice_fs.h:#define USBDEVFS_IOCTL             _IOWR('U', 18, struct usbdevfs_ioctl)
include/linux/usbdevice_fs.h:#define USBDEVFS_IOCTL32           _IOWR('U', 18, struct usbdevfs_ioctl32)
include/linux/usbdevice_fs.h:#define USBDEVFS_HUB_PORTINFO      _IOR('U', 19, struct usbdevfs_hub_portinfo)
include/linux/usbdevice_fs.h:#define USBDEVFS_RESET             _IO('U', 20)
include/linux/usbdevice_fs.h:#define USBDEVFS_CLEAR_HALT        _IOR('U', 21, unsigned int)
include/linux/usbdevice_fs.h:#define USBDEVFS_DISCONNECT        _IO('U', 22)
include/linux/usbdevice_fs.h:#define USBDEVFS_CONNECT           _IO('U', 23)
include/linux/usbdevice_fs.h:#define USBDEVFS_CLAIM_PORT        _IOR('U', 24, unsigned int)
include/linux/usbdevice_fs.h:#define USBDEVFS_RELEASE_PORT      _IOR('U', 25, unsigned int)
include/linux/xattr.h:ssize_t vfs_getxattr(struct dentry *, const char *, void *, size_t);
include/linux/xattr.h:ssize_t vfs_listxattr(struct dentry *d, char *list, size_t size);
include/linux/xattr.h:int __vfs_setxattr_noperm(struct dentry *, const char *, const void *, size_t, int);
include/linux/xattr.h:int vfs_setxattr(struct dentry *, const char *, const void *, size_t, int);
include/linux/xattr.h:int vfs_removexattr(struct dentry *, const char *);
include/linux/xattr.h:ssize_t vfs_getxattr_alloc(struct dentry *dentry, const char *name,
include/linux/xattr.h:int vfs_xattr_cmp(struct dentry *dentry, const char *xattr_name,
include/linux/debugfs.h: * want to duplicate the design decision mistakes of procfs and devfs again.
include/linux/hugetlb.h:	 * The file is being created on the internal vfs mount and shmfs
include/linux/if_link.h:	IFLA_NUM_VF,		/* Number of VFs if device is SR-IOV PF */
include/linux/if_link.h:	IFLA_EXT_MASK,		/* Extended info mask, VFs, etc */
include/linux/mlx4/device.h:	int			num_vfs;
include/linux/fsnotify.h: * fsnotify_vfsmount_delete - a vfsmount is being destroyed, clean up is needed
include/linux/fsnotify.h:static inline void fsnotify_vfsmount_delete(struct vfsmount *mnt)
include/linux/fsnotify.h:	__fsnotify_vfsmount_delete(mnt);
include/linux/coda.h: * to deal with VFS open modes
include/linux/dqblk_v2.h: *  Definitions for vfsv0 quota format
include/linux/nfs_fs.h:	struct inode		vfs_inode;
include/linux/nfs_fs.h:	return container_of(inode, struct nfs_inode, vfs_inode);
include/linux/nfs_fs.h:extern int nfs_getattr(struct vfsmount *, struct dentry *, struct kstat *);
include/linux/nfs_fs.h:#define NFSDBG_VFS		0x0001
include/trace/events/ext4.h:#define EXT4_I(inode) (container_of(inode, struct ext4_inode_info, vfs_inode))
include/net/9p/9p.h: * @P9_DEBUG_VFS: VFS API tracing
include/net/9p/9p.h:	P9_DEBUG_VFS =		(1<<3),
include/net/9p/9p.h: * most likely will not be issued from the Linux VFS client, but may
include/net/sock.h:	struct inode vfs_inode;
include/net/sock.h:	return &container_of(inode, struct socket_alloc, vfs_inode)->socket;
include/net/sock.h:	return &container_of(socket, struct socket_alloc, socket)->vfs_inode;
security/integrity/evm/evm_crypto.c:		size = vfs_getxattr_alloc(dentry, *xattrname,
security/integrity/evm/evm_crypto.c:		rc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,
security/integrity/evm/evm_main.c:	rc = vfs_getxattr_alloc(dentry, XATTR_NAME_EVM, (char **)&xattr_data, 0,
security/integrity/evm/evm_main.c: * __vfs_setxattr_noperm().  The caller of which has taken the inode's
security/tomoyo/realpath.c:		 * or dentry without vfsmount.
security/tomoyo/tomoyo.c: * @mnt:    Pointer to "struct vfsmount".
security/tomoyo/tomoyo.c:static int tomoyo_inode_getattr(struct vfsmount *mnt, struct dentry *dentry)
security/tomoyo/tomoyo.c: * @mnt:   Pointer to "struct vfsmount".
security/tomoyo/tomoyo.c:static int tomoyo_sb_umount(struct vfsmount *mnt, int flags)
security/security.c:int security_sb_umount(struct vfsmount *mnt, int flags)
security/security.c:int security_inode_getattr(struct vfsmount *mnt, struct dentry *dentry)
security/inode.c:static struct vfsmount *mount;
security/smack/smackfs.c:static struct vfsmount *smackfs_mount;
security/smack/smackfs.c: * initialized before the vfs caches.
security/smack/smack_lsm.c:static int smack_sb_umount(struct vfsmount *mnt, int flags)
security/smack/smack_lsm.c:static int smack_inode_getattr(struct vfsmount *mnt, struct dentry *dentry)
security/smack/smack_lsm.c:	return __vfs_setxattr_noperm(dentry, XATTR_NAME_SMACK, ctx, ctxlen, 0);
security/smack/smack.h:						 struct vfsmount *m)
security/capability.c:static int cap_sb_umount(struct vfsmount *mnt, int flags)
security/capability.c:static int cap_inode_getattr(struct vfsmount *mnt, struct dentry *dentry)
security/selinux/include/security.h:extern struct vfsmount *selinuxfs_mount;
security/selinux/sec/seclsm.c: *   get full path string from struct dentry and struct vfsmount
security/selinux/sec/seclsm.c:			struct vfsmount *pMnt)
security/selinux/selinuxfs.c:struct vfsmount *selinuxfs_mount;
security/selinux/avc.c: * @flags: VFS walk flags
security/selinux/avc.c: * @flags: VFS walk flags
security/selinux/hooks.c:	 * after inode_free_security() is called. Ideally, the VFS
security/selinux/hooks.c:	 * from an explicit call and once from the generic calls from the vfs.
security/selinux/hooks.c:	 * Since the generic VFS calls will not contain any security mount data
security/selinux/hooks.c:static int selinux_umount(struct vfsmount *mnt, int flags)
security/selinux/hooks.c:static int selinux_inode_getattr(struct vfsmount *mnt, struct dentry *dentry)
security/selinux/hooks.c:	return __vfs_setxattr_noperm(dentry, XATTR_NAME_SELINUX, ctx, ctxlen, 0);
security/apparmor/apparmorfs.c:	AA_FS_FILE_U64("capability",		VFS_CAP_FLAGS_MASK),
security/apparmor/lsm.c:static int common_perm_mnt_dentry(int op, struct vfsmount *mnt,
security/apparmor/lsm.c:static int apparmor_inode_getattr(struct vfsmount *mnt, struct dentry *dentry)
security/commoncap.c:static inline int bprm_caps_from_vfs_caps(struct cpu_vfs_cap_data *caps,
security/commoncap.c:	if (caps->magic_etc & VFS_CAP_FLAGS_EFFECTIVE)
security/commoncap.c:	if (caps->magic_etc & VFS_CAP_REVISION_MASK)
security/commoncap.c:int get_vfs_caps_from_disk(const struct dentry *dentry, struct cpu_vfs_cap_data *cpu_caps)
security/commoncap.c:	struct vfs_cap_data caps;
security/commoncap.c:	memset(cpu_caps, 0, sizeof(struct cpu_vfs_cap_data));
security/commoncap.c:	switch (magic_etc & VFS_CAP_REVISION_MASK) {
security/commoncap.c:	case VFS_CAP_REVISION_1:
security/commoncap.c:		tocopy = VFS_CAP_U32_1;
security/commoncap.c:	case VFS_CAP_REVISION_2:
security/commoncap.c:		tocopy = VFS_CAP_U32_2;
security/commoncap.c:	struct cpu_vfs_cap_data vcaps;
security/commoncap.c:	if (bprm->file->f_vfsmnt->mnt_flags & MNT_NOSUID)
security/commoncap.c:	rc = get_vfs_caps_from_disk(dentry, &vcaps);
security/commoncap.c:			printk(KERN_NOTICE "%s: get_vfs_caps_from_disk returned %d for %s\n",
security/commoncap.c:	rc = bprm_caps_from_vfs_caps(&vcaps, bprm, effective, has_cap);
init/do_mounts.c:			printk(KERN_ERR "VFS: PARTUUID= is invalid.\n"
init/do_mounts.c:	       "VFS: Mounted root (%s filesystem)%s on device %u:%u.\n",
init/do_mounts.c:		printk("VFS: Cannot open root device \"%s\" or %s: error %d\n",
init/do_mounts.c:		panic("VFS: Unable to mount root fs on %s", b);
init/do_mounts.c:	panic("VFS: Unable to mount root fs on %s", b);
init/do_mounts.c:	printk(KERN_NOTICE "VFS: Insert %s and press ENTER\n", buf);
init/do_mounts.c:		printk(KERN_ERR "VFS: Unable to mount root fs via NFS, trying floppy.\n");
init/main.c:	vfs_caches_init_early();
init/main.c:	vfs_caches_init(totalram_pages);
init/do_mounts_md.c: *		for later execution. Rewrote section to make devfs compatible.
init/do_mounts_md.c:			 * boot a kernel with devfs compiled in from partitioned md
mm/filemap_xip.c:	vfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);
mm/filemap.c:	vfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);
mm/shmem.c:#include <linux/vfs.h>
mm/shmem.c:static struct vfsmount *shm_mnt;
mm/shmem.c:	struct address_space *mapping = info->vfs_inode.i_mapping;
mm/shmem.c: * The VFS layer already does all the dentry stuff for rename,
mm/shmem.c: * it exists so that the VFS layer correctly free's it when it
mm/shmem.c:	return &info->vfs_inode;
mm/shmem.c:	inode_init_once(&info->vfs_inode);
mm/shmem.c:	shm_mnt = vfs_kern_mount(&shmem_fs_type, MS_NOUSER,
mm/msync.c:			error = vfs_fsync(file, 0);
mm/slab.c:		 * A VFS-reclaimable slab tends to have most allocations
CREDITS:D: /devfs hacking.
CREDITS:D: VFS fixes (new notify_change in particular)
CREDITS:D: Moving all VFS access checks into the file systems
CREDITS:D: Device FileSystem (devfs)
CREDITS:D: sysvfs maintainer
CREDITS:D: Some 8-bit XT disk driver and devfs hacking 
drivers/video/riva/riva_hw.c:    int vfsize, mfsize, gfsize;
drivers/video/riva/riva_hw.c:    vfsize = 0;
drivers/video/riva/riva_hw.c:            vfsize = ns * ainfo->vdrain_rate / 1000000;
drivers/video/riva/riva_hw.c:            vfsize =  ainfo->wcvlwm - ainfo->vburst_size + vfsize;
drivers/video/riva/riva_hw.c:        if (abs(vfsize) > VFIFO_SIZE)
drivers/video/msm/samsung_cmc624.c:	pr_debug("[CMC624:INFO] : before vfs_read()\n");
drivers/video/msm/samsung_cmc624.c:	ret = vfs_read(filp, (char __user *)dp, l, &pos);
drivers/video/msm/samsung_cmc624.c:	pr_debug("[CMC624:INFO] : after vfs_read()\n");
drivers/video/msm/samsung_cmc624.c:		pr_debug("[CMC624:ERROR] : vfs_read() filed ret : %d\n", ret);
drivers/video/msm/mipi_samsung_oled-8930.c:	pr_info("%s before vfs_read()\n", __func__);
drivers/video/msm/mipi_samsung_oled-8930.c:	ret = vfs_read(filp, (char __user *)dp, l, &pos);
drivers/video/msm/mipi_samsung_oled-8930.c:	pr_info("%s after vfs_read()\n", __func__);
drivers/video/msm/mipi_samsung_oled-8930.c:		pr_info("vfs_read() filed ret : %d\n", ret);
drivers/video/msm/mdp4_video_enhance-8960.c:	DPRINT("[CMC623:INFO] : before vfs_read()\n");
drivers/video/msm/mdp4_video_enhance-8960.c:	ret = vfs_read(filp, (char __user *)dp, l, &pos);
drivers/video/msm/mdp4_video_enhance-8960.c:	DPRINT("[CMC623:INFO] : after vfs_read()\n");
drivers/video/msm/mdp4_video_enhance-8960.c:		DPRINT("[CMC623:ERROR] : vfs_read() filed ret : %d\n", ret);
drivers/video/msm/mipi_samsung_tft.c:	pr_info("%s before vfs_read()\n", __func__);
drivers/video/msm/mipi_samsung_tft.c:	ret = vfs_read(filp, (char __user *)dp, l, &pos);
drivers/video/msm/mipi_samsung_tft.c:	pr_info("%s after vfs_read()\n", __func__);
drivers/video/msm/mipi_samsung_tft.c:		pr_info("vfs_read() filed ret : %d\n", ret);
drivers/video/msm/samsung_cmc624-8960.c:	pr_debug("[CMC624:INFO] : before vfs_read()\n");
drivers/video/msm/samsung_cmc624-8960.c:	ret = vfs_read(filp, (char __user *)dp, l, &pos);
drivers/video/msm/samsung_cmc624-8960.c:	pr_debug("[CMC624:INFO] : after vfs_read()\n");
drivers/video/msm/samsung_cmc624-8960.c:		pr_debug("[CMC624:ERROR] : vfs_read() filed ret : %d\n", ret);
drivers/video/msm/mdp4_video_enhance.c:	DPRINT("[CMC623:INFO] : before vfs_read()\n");
drivers/video/msm/mdp4_video_enhance.c:	ret = vfs_read(filp, (char __user *)dp, l, &pos);
drivers/video/msm/mdp4_video_enhance.c:	DPRINT("[CMC623:INFO] : after vfs_read()\n");
drivers/video/msm/mdp4_video_enhance.c:		DPRINT("[CMC623:ERROR] : vfs_read() filed ret : %d\n", ret);
drivers/video/msm/mipi_himax_tft.c:	pr_info("%s before vfs_read()\n", __func__);
drivers/video/msm/mipi_himax_tft.c:	ret = vfs_read(filp, (char __user *)dp, l, &pos);
drivers/video/msm/mipi_himax_tft.c:	pr_info("%s after vfs_read()\n", __func__);
drivers/video/msm/mipi_himax_tft.c:		pr_info("vfs_read() filed ret : %d\n", ret);
drivers/video/msm/mipi_samsung_octa.c:	pr_info("%s before vfs_read()\n", __func__);
drivers/video/msm/mipi_samsung_octa.c:	ret = vfs_read(filp, (char __user *)dp, l, &pos);
drivers/video/msm/mipi_samsung_octa.c:	pr_info("%s after vfs_read()\n", __func__);
drivers/video/msm/mipi_samsung_octa.c:		pr_info("vfs_read() filed ret : %d\n", ret);
drivers/video/cyber2000fb.h:#define EXT_DCLK_DIV_VFSEL		0x20
drivers/video/cyber2000fb.c:		/* Set VFSEL when VCO > 180MHz (5.556 ps). */
drivers/video/cyber2000fb.c:		hw->clock_div |= EXT_DCLK_DIV_VFSEL;
drivers/scsi/scsi_debug.c: *   dpg: work for devfs large number of disks [20010809]
drivers/scsi/sd.c: *       - Richard Gooch <rgooch@atnf.csiro.au> support devfs.
drivers/scsi/sd.c: * This gets directly called from VFS. When the ioctl 
drivers/scsi/sr.c: *	Modified by Richard Gooch <rgooch@atnf.csiro.au> to support devfs
drivers/scsi/bfa/bfa_defs.h:	u8	max_vfs;
drivers/scsi/qla2xxx/qla_def.h:#define MBC_CONFIGURE_VF		0x4b	/* Configure VFs */
drivers/scsi/lpfc/lpfc_init.c:				"3057 Requested vfs (%d) greater than "
drivers/scsi/lpfc/lpfc_init.c:				"supported vfs (%d)", nr_vfn, max_nr_vfn);
drivers/scsi/lpfc/lpfc_init.c:	 * calling lpfc_get_cfgparam. For VFs this will report the
drivers/scsi/lpfc/lpfc_hw.h:#define LPFC_MAX_VFN_PER_PFN	255 /* Maximum VFs allowed per ARI */
drivers/scsi/lpfc/lpfc_hw.h:#define LPFC_DEF_VFN_PER_PFN	0   /* Default VFs due to platform limitation*/
drivers/scsi/lpfc/lpfc_attr.c: * @buf: containing the string the number of vfs to be enabled.
drivers/scsi/st.c:   Last modified: 18-JAN-1998 Richard Gooch <rgooch@atnf.csiro.au> Devfs support
drivers/scsi/sg.c: *  Modified  19-JAN-1998  Richard Gooch <rgooch@atnf.csiro.au>  Devfs support
drivers/sensorhub/ssp_firmware.c:	uNRead = (unsigned int)vfs_read(fp, (char __user *)buff,
drivers/mfd/db8500-prcmu.c:#define PRCM_ACK_MB1_DVFS_STATUS	(PRCM_ACK_MB1 + 0x3)
drivers/power/max17042_battery.c:#define VFSOC0_LOCK		0x0000
drivers/power/max17042_battery.c:#define VFSOC0_UNLOCK		0x0080
drivers/power/max17042_battery.c:static void max17042_reset_vfsoc0_reg(struct max17042_chip *chip)
drivers/power/max17042_battery.c:	u16 vfSoc;
drivers/power/max17042_battery.c:	vfSoc = max17042_read_reg(chip->client, MAX17042_VFSOC);
drivers/power/max17042_battery.c:	max17042_write_reg(chip->client, MAX17042_VFSOC0Enable, VFSOC0_UNLOCK);
drivers/power/max17042_battery.c:	max17042_write_verify_reg(chip->client, MAX17042_VFSOC0, vfSoc);
drivers/power/max17042_battery.c:	max17042_write_reg(chip->client, MAX17042_VFSOC0Enable, VFSOC0_LOCK);
drivers/power/max17042_battery.c:	u16 full_cap0, rep_cap, dq_acc, vfSoc;
drivers/power/max17042_battery.c:	vfSoc = max17042_read_reg(chip->client, MAX17042_VFSOC);
drivers/power/max17042_battery.c:	/* fg_vfSoc needs to shifted by 8 bits to get the
drivers/power/max17042_battery.c:	 * full_cap0, fg_vfSoc and devide by 100
drivers/power/max17042_battery.c:	rem_cap = ((vfSoc >> 8) * full_cap0) / 100;
drivers/power/max17042_battery.c:	/* delay must be atleast 350mS to allow VFSOC
drivers/power/max17042_battery.c:	/* reset vfsoc0 reg */
drivers/power/max17042_battery.c:	max17042_reset_vfsoc0_reg(chip);
drivers/cdrom/cdrom.c: * is not lost for both the usual VFS and ioctl paths.
drivers/cdrom/cdrom.c: * cdi->{vfs|ioctl}_events are used to buffer pending events for each
drivers/cdrom/cdrom.c:	cdi->vfs_events |= events;
drivers/cdrom/cdrom.c:	events = cdi->vfs_events;
drivers/cdrom/cdrom.c:	cdi->vfs_events = 0;
drivers/cdrom/cdrom.c: * low-level implementation, to assure that the VFS and the user both
drivers/cdrom/cdrom.c:		BUG_ON(!queue);	/* shouldn't be called from VFS path */
drivers/cdrom/cdrom.c:	/* This talks to the VFS, which doesn't like errors - just 1 or 0.  
drivers/battery/max17050_fuelgauge.c:static int fg_read_vfsoc(struct i2c_client *client)
drivers/battery/max17050_fuelgauge.c:	if (fg_i2c_read(client, VFSOC_REG, data, 2) < 0) {
drivers/battery/max17050_fuelgauge.c:		dev_err(&client->dev, "%s: Failed to read VFSOC\n", __func__);
drivers/battery/max17050_fuelgauge.c:		"%s: Before quick-start - VCELL(%d), VFOCV(%d), VfSOC(%d), RepSOC(%d)\n",
drivers/battery/max17050_fuelgauge.c:		fg_read_vfsoc(client), fg_read_soc(client));
drivers/battery/max17050_fuelgauge.c:		"%s: After quick-start - VCELL(%d), VFOCV(%d), VfSOC(%d), RepSOC(%d)\n",
drivers/battery/max17050_fuelgauge.c:		fg_read_vfsoc(client), fg_read_soc(client));
drivers/battery/max17050_fuelgauge.c:		"%s: Additional step - VfOCV(%d), VfSOC(%d), RepSOC(%d)\n",
drivers/battery/max17050_fuelgauge.c:		fg_read_vfsoc(client), fg_read_soc(client));
drivers/battery/max17050_fuelgauge.c:		ret = fg_read_vfsoc(client);
drivers/battery/max17050_fuelgauge.c:	int fg_vfsoc;
drivers/battery/max17050_fuelgauge.c:	fg_vfsoc = get_fuelgauge_value(client, FG_VF_SOC);
drivers/battery/max17050_fuelgauge.c:		(fg_vfsoc > VFSOC_FOR_FULLCAP_LEARNING &&
drivers/s390/block/dasd_int.h: *   new -> known: find discipline for the device and create devfs entries.
drivers/s390/block/dasd_int.h: *   known -> new: remove devfs entries and forget discipline.
drivers/infiniband/core/uverbs.h: * struct ib_uverbs_file: One reference is held by the VFS and
drivers/infiniband/core/uverbs.h: * struct ib_uverbs_event_file: One reference is held by the VFS and
drivers/hid/hid-picolcd.c:static void picolcd_init_devfs(struct picolcd_data *data,
drivers/hid/hid-picolcd.c:static void picolcd_exit_devfs(struct picolcd_data *data)
drivers/hid/hid-picolcd.c:static inline void picolcd_init_devfs(struct picolcd_data *data,
drivers/hid/hid-picolcd.c:static inline void picolcd_exit_devfs(struct picolcd_data *data)
drivers/hid/hid-picolcd.c:	picolcd_init_devfs(data, picolcd_out_report(REPORT_EE_READ, hdev),
drivers/hid/hid-picolcd.c:	picolcd_init_devfs(data, NULL, NULL,
drivers/hid/hid-picolcd.c:	picolcd_exit_devfs(data);
drivers/char/tty_io.c: * Added devfs support.
drivers/char/tty_io.c: * Move do_SAK() into process context.  Less stack use in devfs functions.
drivers/char/tty_io.c:		res = vfs_write(p, buf, count, &p->f_pos);
drivers/char/tty_io.c: *	tty_release		-	vfs callback for close
drivers/char/mem.c: *  Added devfs support.
drivers/char/nsc_gpio.c:   National Semiconductor common GPIO device-file/VFS methods.
drivers/char/misc.c: * Added devfs support. Richard Gooch <rgooch@atnf.csiro.au>  10-Jan-1998
drivers/char/lp.c: * 22-JAN-1998  Added support for devfs  Richard Gooch <rgooch@atnf.csiro.au>
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [R 32] FLR request attention dirty bits for VFs 96 to 127. Each bit
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [R 32] FLR request attention dirty bits for VFs 0 to 31. Each bit
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [R 32] FLR request attention dirty bits for VFs 32 to 63. Each bit
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [R 32] FLR request attention dirty bits for VFs 64 to 95. Each bit
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [R 32] Was_error indication dirty bits for VFs 96 to 127. Each bit
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [W 32] Was_error indication dirty bits clear for VFs 96 to 127. MCP
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [R 32] Was_error indication dirty bits for VFs 0 to 31. Each bit
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [W 32] Was_error indication dirty bits clear for VFs 0 to 31. MCP writes
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [R 32] Was_error indication dirty bits for VFs 32 to 63. Each bit
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [W 32] Was_error indication dirty bits clear for VFs 32 to 63. MCP writes
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [R 32] Was_error indication dirty bits for VFs 64 to 95. Each bit
drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h:/* [W 32] Was_error indication dirty bits clear for VFs 64 to 95. MCP writes
drivers/net/ethernet/broadcom/bnx2x/bnx2x.h:/* IGU MSIX STATISTICS on 57712: 64 for VFs; 4 for PFs; 4 for Attentions */
drivers/net/ethernet/broadcom/bnx2x/bnx2x.h:#define BNX2X_MAX_NUM_OF_VFS	64
drivers/net/ethernet/broadcom/bnx2x/bnx2x_hsi.h:	 * mcp_vf_disabled is set by the MCP to indicate the driver about VFs
drivers/net/ethernet/broadcom/bnx2x/bnx2x_hsi.h:	 * VFs
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	/* wait for CFC PF usage-counter to zero (includes all the VFs) */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		REG_WR(bp, TSEM_REG_VFPF_ERR_NUM, BNX2X_MAX_NUM_OF_VFS + func);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		REG_WR(bp, USEM_REG_VFPF_ERR_NUM, BNX2X_MAX_NUM_OF_VFS + func);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		REG_WR(bp, CSEM_REG_VFPF_ERR_NUM, BNX2X_MAX_NUM_OF_VFS + func);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		REG_WR(bp, XSEM_REG_VFPF_ERR_NUM, BNX2X_MAX_NUM_OF_VFS + func);
drivers/net/ethernet/cisco/enic/enic_pp.c:			if (vf < 0 || vf >= enic->num_vfs) {
drivers/net/ethernet/cisco/enic/enic.h:	u16 num_vfs;
drivers/net/ethernet/cisco/enic/enic_main.c:	return vf >= 0 && vf < enic->num_vfs;
drivers/net/ethernet/cisco/enic/enic_main.c:			&enic->num_vfs);
drivers/net/ethernet/cisco/enic/enic_main.c:		if (enic->num_vfs) {
drivers/net/ethernet/cisco/enic/enic_main.c:			err = pci_enable_sriov(pdev, enic->num_vfs);
drivers/net/ethernet/cisco/enic/enic_main.c:			num_pps = enic->num_vfs;
drivers/net/ethernet/emulex/benet/be.h:	u32 num_vfs;
drivers/net/ethernet/emulex/benet/be.h:#define	sriov_enabled(adapter)		(adapter->num_vfs > 0)
drivers/net/ethernet/emulex/benet/be.h:#define for_all_vfs(adapter, vf_cfg, i)					\
drivers/net/ethernet/emulex/benet/be.h:	for (i = 0, vf_cfg = &adapter->vf_cfg[i]; i < adapter->num_vfs;	\
drivers/net/ethernet/emulex/benet/be_main.c:static unsigned int num_vfs;
drivers/net/ethernet/emulex/benet/be_main.c:module_param(num_vfs, uint, S_IRUGO);
drivers/net/ethernet/emulex/benet/be_main.c:MODULE_PARM_DESC(num_vfs, "Number of PCI VFs to initialize");
drivers/net/ethernet/emulex/benet/be_main.c:	if (!is_valid_ether_addr(mac) || vf >= adapter->num_vfs)
drivers/net/ethernet/emulex/benet/be_main.c:	if (vf >= adapter->num_vfs)
drivers/net/ethernet/emulex/benet/be_main.c:	if (vf >= adapter->num_vfs || vlan > 4095)
drivers/net/ethernet/emulex/benet/be_main.c:	if (vf >= adapter->num_vfs)
drivers/net/ethernet/emulex/benet/be_main.c:	     adapter->num_vfs == 0 && be_physfn(adapter) &&
drivers/net/ethernet/emulex/benet/be_main.c:	if (be_physfn(adapter) && num_vfs) {
drivers/net/ethernet/emulex/benet/be_main.c:		u16 dev_vfs;
drivers/net/ethernet/emulex/benet/be_main.c:				     pos + PCI_SRIOV_TOTAL_VF, &dev_vfs);
drivers/net/ethernet/emulex/benet/be_main.c:		adapter->num_vfs = min_t(u16, num_vfs, dev_vfs);
drivers/net/ethernet/emulex/benet/be_main.c:		if (adapter->num_vfs != num_vfs)
drivers/net/ethernet/emulex/benet/be_main.c:				 "Device supports %d VFs and not %d\n",
drivers/net/ethernet/emulex/benet/be_main.c:				 adapter->num_vfs, num_vfs);
drivers/net/ethernet/emulex/benet/be_main.c:		status = pci_enable_sriov(adapter->pdev, adapter->num_vfs);
drivers/net/ethernet/emulex/benet/be_main.c:			adapter->num_vfs = 0;
drivers/net/ethernet/emulex/benet/be_main.c:		if (adapter->num_vfs) {
drivers/net/ethernet/emulex/benet/be_main.c:			adapter->vf_cfg = kcalloc(num_vfs,
drivers/net/ethernet/emulex/benet/be_main.c:		adapter->num_vfs = 0;
drivers/net/ethernet/emulex/benet/be_main.c: * MAC Address for VFs are assigned incrementally starting from the seed.
drivers/net/ethernet/emulex/benet/be_main.c:	for_all_vfs(adapter, vf_cfg, vf) {
drivers/net/ethernet/emulex/benet/be_main.c:	for_all_vfs(adapter, vf_cfg, vf) {
drivers/net/ethernet/emulex/benet/be_main.c:	for_all_vfs(adapter, vf_cfg, vf) {
drivers/net/ethernet/emulex/benet/be_main.c:	for_all_vfs(adapter, vf_cfg, vf) {
drivers/net/ethernet/emulex/benet/be_main.c:	for_all_vfs(adapter, vf_cfg, vf) {
drivers/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c:	 * For the VFs, the Mailbox Data "registers" are actually backed by
drivers/net/ethernet/chelsio/cxgb4vf/t4vf_defs.h: * and VFs, and therefore must fit in both the VF and PF Register Maps without
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:	 * For VFs, we'll assign them access to the ports based purely on the
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:MODULE_PARM_DESC(num_vf, "number of VFs for each of PFs 0-3");
drivers/net/ethernet/neterion/vxge/vxge-reg.h:#define VXGE_HW_MRPCIM_GENERAL_CFG3_MR_MAX_MVFS(val) vxge_vBIT(val, 20, 16)
drivers/net/ethernet/neterion/vxge/vxge-main.c:static inline u32 vxge_get_num_vfs(u64 function_mode)
drivers/net/ethernet/neterion/vxge/vxge-main.c:	u32 num_vfs = 0;
drivers/net/ethernet/neterion/vxge/vxge-main.c:		num_vfs = vxge_get_num_vfs(function_mode) - 1;
drivers/net/ethernet/neterion/vxge/vxge-main.c:		ret = pci_enable_sriov(pdev, num_vfs);
drivers/net/ethernet/amd/nmclan_cs.c:#define MACE_RCVFS			6
drivers/net/ethernet/amd/nmclan_cs.c:#define MACE_RCVFS_RCVSTS		0xF000
drivers/net/ethernet/amd/nmclan_cs.c:#define MACE_RCVFS_OFLO			0x8000
drivers/net/ethernet/amd/nmclan_cs.c:#define MACE_RCVFS_CLSN			0x4000
drivers/net/ethernet/amd/nmclan_cs.c:#define MACE_RCVFS_FRAM			0x2000
drivers/net/ethernet/amd/nmclan_cs.c:#define MACE_RCVFS_FCS			0x1000
drivers/net/ethernet/amd/nmclan_cs.c:    if (rx_status & MACE_RCVFS_RCVSTS) { /* Error, update stats. */
drivers/net/ethernet/amd/nmclan_cs.c:      if (rx_status & MACE_RCVFS_OFLO) {
drivers/net/ethernet/amd/nmclan_cs.c:      if (rx_status & MACE_RCVFS_CLSN) {
drivers/net/ethernet/amd/nmclan_cs.c:      if (rx_status & MACE_RCVFS_FRAM) {
drivers/net/ethernet/amd/nmclan_cs.c:      if (rx_status & MACE_RCVFS_FCS) {
drivers/net/ethernet/amd/nmclan_cs.c:      short pkt_len = (rx_status & ~MACE_RCVFS_RCVSTS) - 4;
drivers/net/ethernet/intel/igb/e1000_82575.h:#define MAX_NUM_VFS                   8
drivers/net/ethernet/intel/igb/e1000_82575.c:			dtxswc ^= (1 << pf | 1 << (pf + MAX_NUM_VFS));
drivers/net/ethernet/intel/igb/igb_ethtool.c:	tx_ring->reg_idx = adapter->vfs_allocated_count;
drivers/net/ethernet/intel/igb/igb_ethtool.c:	rx_ring->reg_idx = adapter->vfs_allocated_count;
drivers/net/ethernet/intel/igb/igb_ethtool.c:	wr32(E1000_MRQC, adapter->vfs_allocated_count << 3);
drivers/net/ethernet/intel/igb/igb_main.c:static void igb_ping_all_vfs(struct igb_adapter *);
drivers/net/ethernet/intel/igb/igb_main.c:static int igb_find_enabled_vfs(struct igb_adapter *adapter);
drivers/net/ethernet/intel/igb/igb_main.c:static unsigned int max_vfs = 0;
drivers/net/ethernet/intel/igb/igb_main.c:module_param(max_vfs, uint, 0);
drivers/net/ethernet/intel/igb/igb_main.c:MODULE_PARM_DESC(max_vfs, "Maximum number of virtual functions to allocate "
drivers/net/ethernet/intel/igb/igb_main.c:	u32 rbase_offset = adapter->vfs_allocated_count;
drivers/net/ethernet/intel/igb/igb_main.c:		if (adapter->vfs_allocated_count) {
drivers/net/ethernet/intel/igb/igb_main.c:	if (adapter->vfs_allocated_count)
drivers/net/ethernet/intel/igb/igb_main.c:	adapter->vfs_allocated_count = 0;
drivers/net/ethernet/intel/igb/igb_main.c:	 * we need to be careful when disabling interrupts.  The VFs are also
drivers/net/ethernet/intel/igb/igb_main.c:		if (adapter->vfs_allocated_count) {
drivers/net/ethernet/intel/igb/igb_main.c:	/* notify VFs that reset has been completed */
drivers/net/ethernet/intel/igb/igb_main.c:	if (adapter->vfs_allocated_count) {
drivers/net/ethernet/intel/igb/igb_main.c:	/* disable receive for all VFs and wait one second */
drivers/net/ethernet/intel/igb/igb_main.c:	if (adapter->vfs_allocated_count) {
drivers/net/ethernet/intel/igb/igb_main.c:		for (i = 0 ; i < adapter->vfs_allocated_count; i++)
drivers/net/ethernet/intel/igb/igb_main.c:		/* ping all the active vfs to let them know we are going down */
drivers/net/ethernet/intel/igb/igb_main.c:		igb_ping_all_vfs(adapter);
drivers/net/ethernet/intel/igb/igb_main.c:	/* reclaim resources allocated to VFs */
drivers/net/ethernet/intel/igb/igb_main.c: * igb_probe_vfs - Initialize vf data storage and add VFs to pci config space
drivers/net/ethernet/intel/igb/igb_main.c: * allocate the VFs.  The reason for ordering it this way is because it is much
drivers/net/ethernet/intel/igb/igb_main.c: * the memory for the VFs.
drivers/net/ethernet/intel/igb/igb_main.c:static void __devinit igb_probe_vfs(struct igb_adapter * adapter)
drivers/net/ethernet/intel/igb/igb_main.c:	int old_vfs = igb_find_enabled_vfs(adapter);
drivers/net/ethernet/intel/igb/igb_main.c:	if (old_vfs) {
drivers/net/ethernet/intel/igb/igb_main.c:		dev_info(&pdev->dev, "%d pre-allocated VFs found - override "
drivers/net/ethernet/intel/igb/igb_main.c:			 "max_vfs setting of %d\n", old_vfs, max_vfs);
drivers/net/ethernet/intel/igb/igb_main.c:		adapter->vfs_allocated_count = old_vfs;
drivers/net/ethernet/intel/igb/igb_main.c:	if (!adapter->vfs_allocated_count)
drivers/net/ethernet/intel/igb/igb_main.c:	adapter->vf_data = kcalloc(adapter->vfs_allocated_count,
drivers/net/ethernet/intel/igb/igb_main.c:		adapter->vfs_allocated_count = 0;
drivers/net/ethernet/intel/igb/igb_main.c:	if (!old_vfs) {
drivers/net/ethernet/intel/igb/igb_main.c:		if (pci_enable_sriov(pdev, adapter->vfs_allocated_count))
drivers/net/ethernet/intel/igb/igb_main.c:	dev_info(&pdev->dev, "%d VFs allocated\n",
drivers/net/ethernet/intel/igb/igb_main.c:		 adapter->vfs_allocated_count);
drivers/net/ethernet/intel/igb/igb_main.c:	for (i = 0; i < adapter->vfs_allocated_count; i++)
drivers/net/ethernet/intel/igb/igb_main.c:	adapter->vfs_allocated_count = 0;
drivers/net/ethernet/intel/igb/igb_main.c:		if (max_vfs > 7) {
drivers/net/ethernet/intel/igb/igb_main.c:				 "Maximum of 7 VFs per PF, using max\n");
drivers/net/ethernet/intel/igb/igb_main.c:			adapter->vfs_allocated_count = 7;
drivers/net/ethernet/intel/igb/igb_main.c:			adapter->vfs_allocated_count = max_vfs;
drivers/net/ethernet/intel/igb/igb_main.c:	if (hw->mac.type == e1000_i350 && adapter->vfs_allocated_count)
drivers/net/ethernet/intel/igb/igb_main.c:	 * if rss_queues > 4 or vfs are going to be allocated with rss_queues
drivers/net/ethernet/intel/igb/igb_main.c:	    ((adapter->rss_queues > 1) && (adapter->vfs_allocated_count > 6)))
drivers/net/ethernet/intel/igb/igb_main.c:	igb_probe_vfs(adapter);
drivers/net/ethernet/intel/igb/igb_main.c:	/* notify VFs that reset has been completed */
drivers/net/ethernet/intel/igb/igb_main.c:	if (adapter->vfs_allocated_count) {
drivers/net/ethernet/intel/igb/igb_main.c:	if (adapter->vfs_allocated_count) {
drivers/net/ethernet/intel/igb/igb_main.c:	if (adapter->vfs_allocated_count) {
drivers/net/ethernet/intel/igb/igb_main.c:			vtctl |= adapter->vfs_allocated_count <<
drivers/net/ethernet/intel/igb/igb_main.c:	if (adapter->vfs_allocated_count) {
drivers/net/ethernet/intel/igb/igb_main.c:	/* if it isn't the PF check to see if VFs are enabled and
drivers/net/ethernet/intel/igb/igb_main.c:	if (vfn < adapter->vfs_allocated_count &&
drivers/net/ethernet/intel/igb/igb_main.c:	u16 pf_id = adapter->vfs_allocated_count;
drivers/net/ethernet/intel/igb/igb_main.c:	if (adapter->rss_queues > 1 && vfn == adapter->vfs_allocated_count)
drivers/net/ethernet/intel/igb/igb_main.c:	 * for VMDq only allow the VFs and pool 0 to accept broadcast and
drivers/net/ethernet/intel/igb/igb_main.c:	if (vfn <= adapter->vfs_allocated_count)
drivers/net/ethernet/intel/igb/igb_main.c:	if (adapter->vfs_allocated_count || adapter->num_rx_queues > 1)
drivers/net/ethernet/intel/igb/igb_main.c:	                 adapter->vfs_allocated_count);
drivers/net/ethernet/intel/igb/igb_main.c:	                 adapter->vfs_allocated_count);
drivers/net/ethernet/intel/igb/igb_main.c:	unsigned int vfn = adapter->vfs_allocated_count;
drivers/net/ethernet/intel/igb/igb_main.c:	unsigned int vfn = adapter->vfs_allocated_count;
drivers/net/ethernet/intel/igb/igb_main.c:	for(j = 0; j < adapter->vfs_allocated_count; j++) {
drivers/net/ethernet/intel/igb/igb_main.c:			igb_ping_all_vfs(adapter);
drivers/net/ethernet/intel/igb/igb_main.c:			igb_ping_all_vfs(adapter);
drivers/net/ethernet/intel/igb/igb_main.c:static int igb_find_enabled_vfs(struct igb_adapter *adapter)
drivers/net/ethernet/intel/igb/igb_main.c:	int vfs_found = 0;
drivers/net/ethernet/intel/igb/igb_main.c:			vfs_found++;
drivers/net/ethernet/intel/igb/igb_main.c:	return vfs_found;
drivers/net/ethernet/intel/igb/igb_main.c:	for (i = 0; i < adapter->vfs_allocated_count; i++) {
drivers/net/ethernet/intel/igb/igb_main.c:static void igb_ping_all_vfs(struct igb_adapter *adapter)
drivers/net/ethernet/intel/igb/igb_main.c:	for (i = 0 ; i < adapter->vfs_allocated_count; i++) {
drivers/net/ethernet/intel/igb/igb_main.c:	for (i = 0; i < adapter->vfs_allocated_count; i++) {
drivers/net/ethernet/intel/igb/igb_main.c:	if (!adapter->vfs_allocated_count)
drivers/net/ethernet/intel/igb/igb_main.c:			if (vf >= adapter->vfs_allocated_count)
drivers/net/ethernet/intel/igb/igb_main.c:			if (vf >= adapter->vfs_allocated_count)
drivers/net/ethernet/intel/igb/igb_main.c:	if ((vf >= adapter->vfs_allocated_count) || (vlan > 4095) || (qos > 7))
drivers/net/ethernet/intel/igb/igb_main.c:	for (vf = 0; vf < adapter->vfs_allocated_count; vf++) {
drivers/net/ethernet/intel/igb/igb_main.c:	if (!adapter->vfs_allocated_count)
drivers/net/ethernet/intel/igb/igb_main.c:	int pf_id = adapter->vfs_allocated_count;
drivers/net/ethernet/intel/igb/igb_main.c:	int pf_id = adapter->vfs_allocated_count;
drivers/net/ethernet/intel/igb/igb_main.c:	if (!is_valid_ether_addr(mac) || (vf >= adapter->vfs_allocated_count))
drivers/net/ethernet/intel/igb/igb_main.c:	for (i = 0; i < adapter->vfs_allocated_count; i++) {
drivers/net/ethernet/intel/igb/igb_main.c:	if ((vf >= adapter->vfs_allocated_count) ||
drivers/net/ethernet/intel/igb/igb_main.c:	if (vf >= adapter->vfs_allocated_count)
drivers/net/ethernet/intel/igb/igb_main.c:	if (adapter->vfs_allocated_count) {
drivers/net/ethernet/intel/igb/igb_main.c:						adapter->vfs_allocated_count);
drivers/net/ethernet/intel/igb/igb.h:#define IGB_MAX_RX_QUEUES                  (adapter->vfs_allocated_count ? 2 : \
drivers/net/ethernet/intel/igb/igb.h:	unsigned int vfs_allocated_count;
drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c:			for (i = 0; i < adapter->num_vfs; i++) {
drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c:						    "supported when VFs are "
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:static int ixgbe_find_enabled_vfs(struct ixgbe_adapter *adapter)
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	int vfs_found = 0;
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:			vfs_found++;
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	return vfs_found;
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	int pre_existing_vfs = 0;
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	pre_existing_vfs = ixgbe_find_enabled_vfs(adapter);
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	if (!pre_existing_vfs && !adapter->num_vfs)
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	/* If there are pre-existing VFs then we have to force
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	 * If the user wants to change the number of VFs they can
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	 * use ethtool while making sure no VFs are allocated to
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	if (pre_existing_vfs) {
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:		adapter->num_vfs = pre_existing_vfs;
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:		err = pci_enable_sriov(adapter->pdev, adapter->num_vfs);
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:		goto err_novfs;
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	e_info(probe, "SR-IOV enabled with %d VFs\n", adapter->num_vfs);
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	(IXGBE_MAX_PF_MACVLANS + 1 + adapter->num_vfs);
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:				(i + adapter->num_vfs + 1);
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	/* If call to enable VFs succeeded then allocate memory
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:		kcalloc(adapter->num_vfs,
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:		for (i = 0; i < adapter->num_vfs; i++)
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:err_novfs:
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	adapter->num_vfs = 0;
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	for (i = 0; i < adapter->num_vfs; i++) {
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	adapter->num_vfs = 0;
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	 * VFs are limited to using the MTA hash table for their multicast
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	for (i = 0; i < adapter->num_vfs; i++) {
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	for (i = 0; i < adapter->num_vfs; i++) {
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	for (vf = 0; vf < adapter->num_vfs; vf++) {
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	/* disable transmit and receive for all vfs */
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:void ixgbe_ping_all_vfs(struct ixgbe_adapter *adapter)
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	for (i = 0 ; i < adapter->num_vfs; i++) {
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	if (!is_valid_ether_addr(mac) || (vf >= adapter->num_vfs))
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	if ((vf >= adapter->num_vfs) || (vlan > 4095) || (qos > 7))
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	for (i = 0; i < adapter->num_vfs; i++) {
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	if ((vf >= adapter->num_vfs) || (!adapter->link_up) ||
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	regval = IXGBE_READ_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg));
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	IXGBE_WRITE_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg), regval);
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:		regval = IXGBE_READ_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg));
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:		IXGBE_WRITE_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg), regval);
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	if (vf >= adapter->num_vfs)
drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c:	adapter->rx_ring[0]->reg_idx = adapter->num_vfs * 2;
drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c:	adapter->tx_ring[0]->reg_idx = adapter->num_vfs * 2;
drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c:	if (adapter->num_vfs)
drivers/net/ethernet/intel/ixgbe/ixgbe_type.h:#define IXGBE_PFVFSPOOF(_i) (0x08200 + ((_i) * 4)) /* 8 of these 0 - 7 */
drivers/net/ethernet/intel/ixgbe/ixgbe_type.h:#define IXGBE_PFVFSPOOF_REG_COUNT       8
drivers/net/ethernet/intel/ixgbe/ixgbe_type.h:#define IXGBE_GPIE_VTMODE_16     0x00004000 /* 16 VFs 8 queues per VF */
drivers/net/ethernet/intel/ixgbe/ixgbe_type.h:#define IXGBE_GPIE_VTMODE_32     0x00008000 /* 32 VFs 4 queues per VF */
drivers/net/ethernet/intel/ixgbe/ixgbe_type.h:#define IXGBE_GPIE_VTMODE_64     0x0000C000 /* 64 VFs 2 queues per VF */
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		 * entry bit but there are still pools/VFs using this VLAN
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		 * there may be multiple pools and/or VFs using the
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		 * VFTA bit until all pools/VFs using that VLAN ID have also
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:				 * but some pools/VFs are still using it.
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	u32 pfvfspoof = 0;
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		pfvfspoof = IXGBE_SPOOF_MACAS_MASK;
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	 * PFVFSPOOF register array is size 8 with 8 bits assigned to
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	for (j = 0; j < IXGBE_PFVFSPOOF_REG_COUNT; j++)
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		IXGBE_WRITE_REG(hw, IXGBE_PFVFSPOOF(j), pfvfspoof);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	pfvfspoof = IXGBE_READ_REG(hw, IXGBE_PFVFSPOOF(pf_target_reg));
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	pfvfspoof ^= (1 << pf_target_shift);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	IXGBE_WRITE_REG(hw, IXGBE_PFVFSPOOF(pf_target_reg), pfvfspoof);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	u32 pfvfspoof;
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	pfvfspoof = IXGBE_READ_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg));
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		pfvfspoof |= (1 << vf_target_shift);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:		pfvfspoof &= ~(1 << vf_target_shift);
drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:	IXGBE_WRITE_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg), pfvfspoof);
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:static unsigned int max_vfs;
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:module_param(max_vfs, uint, 0);
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:MODULE_PARM_DESC(max_vfs,
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	if (adapter->num_vfs > 32) {
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		u32 eitrsel = (1 << (adapter->num_vfs - 32)) - 1;
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	if (adapter->num_vfs)
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		IXGBE_WRITE_REG(hw, IXGBE_PSRTYPE(adapter->num_vfs + p),
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	vt_reg_bits |= (adapter->num_vfs << IXGBE_VT_CTL_POOL_SHIFT);
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	vf_shift = adapter->num_vfs % 32;
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	reg_offset = (adapter->num_vfs >= 32) ? 1 : 0;
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	/* Map PF MAC address in RAR Entry 0 to first pool following VFs */
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	hw->mac.ops.set_vmdq(hw, 0, adapter->num_vfs);
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	 * i.e. 32 or 64 VFs for SR-IOV
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:					   (adapter->num_vfs != 0),
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:					  adapter->num_vfs);
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	/* For VFs that have spoof checking turned off */
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	for (i = 0; i < adapter->num_vfs; i++) {
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	int pool_ndx = adapter->num_vfs;
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	int pool_ndx = adapter->num_vfs;
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	unsigned int vfn = adapter->num_vfs;
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	if (adapter->num_vfs) {
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		vmolr |= IXGBE_READ_REG(hw, IXGBE_VMOLR(adapter->num_vfs)) &
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		IXGBE_WRITE_REG(hw, IXGBE_VMOLR(adapter->num_vfs), vmolr);
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	 * back up to give the VFs time to respond to the reset.  The
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	hw->mac.ops.set_rar(hw, 0, hw->mac.addr, adapter->num_vfs,
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	if (adapter->num_vfs) {
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		/* Mark all the VFs as inactive */
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		for (i = 0 ; i < adapter->num_vfs; i++)
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		/* ping all the active vfs to let them know we are going down */
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		ixgbe_ping_all_vfs(adapter);
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	 * in SR-IOV mode as it may cause buffer overruns in guest VFs that
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	for (vf = 0; vf < adapter->num_vfs; vf++) {
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	 * no VFs or the link is down
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	if (!adapter->num_vfs ||
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	/* If we have VFs allocated then we must check for DMA hangs */
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	hw->mac.ops.set_rar(hw, 0, hw->mac.addr, adapter->num_vfs,
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	/* The 82599 supports up to 64 VFs per physical function
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	adapter->num_vfs = (max_vfs > 63) ? 63 : max_vfs;
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		e_info(probe, "IOV is enabled with %d VFs\n", adapter->num_vfs);
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		for (i = 0; i < adapter->num_vfs; i++)
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:			e_dev_warn("Unloading driver while VFs are assigned "
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:				   "- VFs will not be deallocated\n");
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	    adapter->num_vfs == 0)
drivers/net/ethernet/intel/ixgbe/ixgbe.h:#define VMDQ_P(p)   ((p) + adapter->num_vfs)
drivers/net/ethernet/intel/ixgbe/ixgbe.h:	DECLARE_BITMAP(active_vfs, IXGBE_MAX_VF_FUNCTIONS);
drivers/net/ethernet/intel/ixgbe/ixgbe.h:	unsigned int num_vfs;
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.h:void ixgbe_ping_all_vfs(struct ixgbe_adapter *adapter);
drivers/net/ethernet/intel/ixgbevf/regs.h:#define IXGBE_VFSTATUS         0x00008
drivers/net/ethernet/intel/ixgbevf/regs.h:#define IXGBE_VFSRRCTL(x)      (0x01014 + (0x40 * (x)))
drivers/net/ethernet/intel/ixgbevf/regs.h:#define IXGBE_WRITE_FLUSH(a) (IXGBE_READ_REG(a, IXGBE_VFSTATUS))
drivers/net/ethernet/intel/ixgbevf/ethtool.c:	"IXGBE_VFSTATUS",
drivers/net/ethernet/intel/ixgbevf/ethtool.c:	"IXGBE_VFSRRCTL0",
drivers/net/ethernet/intel/ixgbevf/ethtool.c:	"IXGBE_VFSRRCTL1",
drivers/net/ethernet/intel/ixgbevf/ethtool.c:	regs_buff[1] = IXGBE_READ_REG(hw, IXGBE_VFSTATUS);
drivers/net/ethernet/intel/ixgbevf/ethtool.c:		regs_buff[26 + i] = IXGBE_READ_REG(hw, IXGBE_VFSRRCTL(i));
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:	IXGBE_WRITE_REG(hw, IXGBE_VFSRRCTL(index), srrctl);
drivers/net/ethernet/mellanox/mlx4/main.c:static int num_vfs;
drivers/net/ethernet/mellanox/mlx4/main.c:module_param(num_vfs, int, 0444);
drivers/net/ethernet/mellanox/mlx4/main.c:MODULE_PARM_DESC(num_vfs, "enable #num_vfs functions if num_vfs > 0");
drivers/net/ethernet/mellanox/mlx4/main.c:MODULE_PARM_DESC(probe_vf, "number of vfs to probe by pf driver (num_vfs > 0)");
drivers/net/ethernet/mellanox/mlx4/main.c:	if (num_vfs > MLX4_MAX_NUM_VF) {
drivers/net/ethernet/mellanox/mlx4/main.c:		       num_vfs, MLX4_MAX_NUM_VF);
drivers/net/ethernet/mellanox/mlx4/main.c:		/* When acting as pf, we normally skip vfs unless explicitly
drivers/net/ethernet/mellanox/mlx4/main.c:		if (num_vfs && extended_func_num(pdev) > probe_vf) {
drivers/net/ethernet/mellanox/mlx4/main.c:		if (num_vfs) {
drivers/net/ethernet/mellanox/mlx4/main.c:			mlx4_warn(dev, "Enabling sriov with:%d vfs\n", num_vfs);
drivers/net/ethernet/mellanox/mlx4/main.c:			err = pci_enable_sriov(pdev, num_vfs);
drivers/net/ethernet/mellanox/mlx4/main.c:				num_vfs = 0;
drivers/net/ethernet/mellanox/mlx4/main.c:				dev->num_vfs = num_vfs;
drivers/net/ethernet/mellanox/mlx4/main.c:	if (num_vfs && (dev->flags & MLX4_FLAG_SRIOV))
drivers/net/ethernet/mellanox/mlx4/main.c:	if (num_vfs && (dev->flags & MLX4_FLAG_SRIOV)) {
drivers/net/ethernet/mellanox/mlx4/en_tx.c:		 * so that VFs and PF can communicate with each other
drivers/net/ethernet/sfc/efx.c:	/* If RSS is requested for the PF *and* VFs then we can't write RSS
drivers/net/ethernet/sfc/efx.c:	 * table entries that are inaccessible to VFs
drivers/net/ethernet/sfc/efx.c:	/* RSS might be usable on VFs even if it is disabled on the PF */
drivers/net/ethernet/sfc/nic.h: * functions (VFs) that may be handled by some other driver, often in
drivers/net/ethernet/sfc/nic.h: * The PF has access to all 1024 VIs while VFs are mapped to VIs
drivers/net/ethernet/sfc/nic.h:/* Maximum number of VFs allowed */
drivers/net/ethernet/sfc/nic.h:/* Limit EVQs on VFs to be only 8k to reduce buffer table reservation */
drivers/net/ethernet/sfc/vfdi.h: *	versions must either be layout-compatible or only be sent to VFs
drivers/net/ethernet/sfc/siena_sriov.c: * Siena does not have a switch, so VFs can't transmit data to each
drivers/net/ethernet/sfc/siena_sriov.c: * other. Instead the VFs must be made aware of the local addresses
drivers/net/ethernet/sfc/siena_sriov.c:/* VFs can only use this many transmit channels */
drivers/net/ethernet/sfc/siena_sriov.c:		 "Limit the number of TX channels VFs can use");
drivers/net/ethernet/sfc/siena_sriov.c:static int max_vfs = -1;
drivers/net/ethernet/sfc/siena_sriov.c:module_param(max_vfs, int, 0444);
drivers/net/ethernet/sfc/siena_sriov.c:MODULE_PARM_DESC(max_vfs,
drivers/net/ethernet/sfc/siena_sriov.c:		 "Reduce the number of VFs initialized by the driver");
drivers/net/ethernet/sfc/siena_sriov.c:	if (!max_vfs)
drivers/net/ethernet/sfc/siena_sriov.c:	if (count > 0 && count > max_vfs)
drivers/net/ethernet/sfc/siena_sriov.c:		count = max_vfs;
drivers/net/ethernet/sfc/siena_sriov.c:static void efx_sriov_vfs_fini(struct efx_nic *efx)
drivers/net/ethernet/sfc/siena_sriov.c:static int efx_sriov_vfs_init(struct efx_nic *efx)
drivers/net/ethernet/sfc/siena_sriov.c:	efx_sriov_vfs_fini(efx);
drivers/net/ethernet/sfc/siena_sriov.c:	rc = efx_sriov_vfs_init(efx);
drivers/net/ethernet/sfc/siena_sriov.c:		goto fail_vfs;
drivers/net/ethernet/sfc/siena_sriov.c:		   "enabled SR-IOV for %d VFs, %d VI per VF\n",
drivers/net/ethernet/sfc/siena_sriov.c:	efx_sriov_vfs_fini(efx);
drivers/net/ethernet/sfc/siena_sriov.c:fail_vfs:
drivers/net/ethernet/sfc/siena_sriov.c:	efx_sriov_vfs_fini(efx);
drivers/net/ethernet/sfc/siena_sriov.c:/* Reset all VFs */
drivers/net/ethernet/sfc/net_driver.h: * @vf_count: Number of VFs intended to be enabled.
drivers/net/ethernet/sfc/net_driver.h: * @vf_init_count: Number of VFs that have been fully initialised.
drivers/net/ethernet/apple/mace.h:	REG(rcvfs);		/* receive frame status (4 bytes) */
drivers/net/ethernet/apple/mace.h: * Bits in RCVFS.  After a frame is received, four bytes of status
drivers/net/wireless/bcmdhd/dhd_custom_sec.c:	ret = vfs_write(file, data, size, &offset);
drivers/base/devtmpfs.c:	err = vfs_mkdir(path.dentry->d_inode, dentry, mode);
drivers/base/devtmpfs.c:	err = vfs_mknod(path.dentry->d_inode,
drivers/base/devtmpfs.c:				err = vfs_rmdir(nd.path.dentry->d_inode,
drivers/base/devtmpfs.c:			err = vfs_getattr(nd.path.mnt, dentry, &stat);
drivers/base/devtmpfs.c:				err = vfs_unlink(nd.path.dentry->d_inode,
drivers/devfreq/Kconfig:	bool "Generic Dynamic Voltage and Frequency Scaling (DVFS) support"
drivers/devfreq/Kconfig:	  devfreq, a generic DVFS framework can be registered for a device
drivers/devfreq/exynos4_bus.c:	/* Enable pause function for DREX2 DVFS */
drivers/devfreq/exynos4_bus.c:		/* Set Fastest and Deactivate DVFS */
drivers/devfreq/devfreq.c: * devfreq: Generic Dynamic Voltage and Frequency Scaling (DVFS) Framework
drivers/pci/pci.h:	u16 total;		/* total VFs associated with the PF */
drivers/pci/pci.h:	u16 initial;		/* initial VFs associated with the PF */
drivers/pci/pci.h:	u16 nr_virtfn;		/* number of VFs available */
drivers/pci/iov.c: * the VF BAR size multiplied by the number of VFs.  The alignment
drivers/pci/iov.c: * pci_num_vf - return number of VFs associated with a PF device_release_driver
drivers/pci/iov.c: * Returns number of VFs, or 0 if SR-IOV is not enabled.
drivers/pci/remove.c:	 * VFs could be removed by pci_stop_and_remove_bus_device() in the
drivers/pci/remove.c:	 * but VFs are inserted after PFs when SRIOV is enabled for PF,
drivers/md/md.c:   - Devfs support by Richard Gooch <rgooch@atnf.csiro.au>
drivers/md/bitmap.c:		vfs_fsync(file, 1);
drivers/target/target_core_file.c:	ret = vfs_readv(fd, &iov[0], task->task_sg_nents, &pos);
drivers/target/target_core_file.c:			pr_err("vfs_readv() returned %d,"
drivers/target/target_core_file.c:			pr_err("vfs_readv() returned %d for non"
drivers/target/target_core_file.c:	ret = vfs_writev(fd, &iov[0], task->task_sg_nents, &pos);
drivers/target/target_core_file.c:		pr_err("vfs_writev() returned %d\n", ret);
drivers/target/target_core_file.c:	ret = vfs_fsync_range(fd_dev->fd_file, start, end, 1);
drivers/target/target_core_file.c:		pr_err("FILEIO: vfs_fsync_range() failed: %d\n", ret);
drivers/target/target_core_file.c:		 * Perform implict vfs_fsync_range() for fd_do_writev() ops
drivers/target/target_core_file.c:			vfs_fsync_range(fd_dev->fd_file, start, end, 1);
drivers/target/target_core_pr.c:	ret = vfs_writev(file, &iov[0], 1, &file->f_pos);
drivers/target/Kconfig:	tristate "TCM/FILEIO Subsystem Plugin for Linux/VFS"
drivers/target/Kconfig:	access to Linux/VFS struct file or struct block_device
drivers/target/target_core_alua.c:	ret = vfs_writev(file, &iov[0], 1, &file->f_pos);
drivers/usb/host/uhci-debug.c:	/* XXX: atomic 64bit seek access, but that needs to be fixed in the VFS */
drivers/usb/core/hub.c:	case USBDEVFS_HUB_PORTINFO: {
drivers/usb/core/hub.c:		struct usbdevfs_hub_portinfo *info = user_data;
drivers/usb/core/message.c: * Because there is no usb_interrupt_msg() and no USBDEVFS_INTERRUPT ioctl,
drivers/usb/core/devio.c:	struct usbdevfs_ctrltransfer ctrl;
drivers/usb/core/devio.c:		dev_printk(KERN_DEBUG, &dev->dev, "usbfs: USBDEVFS_CONTROL "
drivers/usb/core/devio.c:	struct usbdevfs_bulktransfer bulk;
drivers/usb/core/devio.c:	struct usbdevfs_getdriver gd;
drivers/usb/core/devio.c:	struct usbdevfs_connectinfo ci = {
drivers/usb/core/devio.c:	struct usbdevfs_setinterface setintf;
drivers/usb/core/devio.c:static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
drivers/usb/core/devio.c:			struct usbdevfs_iso_packet_desc __user *iso_frame_desc,
drivers/usb/core/devio.c:	struct usbdevfs_iso_packet_desc *isopkt = NULL;
drivers/usb/core/devio.c:	if (uurb->flags & ~(USBDEVFS_URB_ISO_ASAP |
drivers/usb/core/devio.c:				USBDEVFS_URB_SHORT_NOT_OK |
drivers/usb/core/devio.c:				USBDEVFS_URB_BULK_CONTINUATION |
drivers/usb/core/devio.c:				USBDEVFS_URB_NO_FSBR |
drivers/usb/core/devio.c:				USBDEVFS_URB_ZERO_PACKET |
drivers/usb/core/devio.c:				USBDEVFS_URB_NO_INTERRUPT))
drivers/usb/core/devio.c:	if (!(uurb->type == USBDEVFS_URB_TYPE_CONTROL &&
drivers/usb/core/devio.c:	case USBDEVFS_URB_TYPE_CONTROL:
drivers/usb/core/devio.c:	case USBDEVFS_URB_TYPE_BULK:
drivers/usb/core/devio.c:			uurb->type = USBDEVFS_URB_TYPE_INTERRUPT;
drivers/usb/core/devio.c:	case USBDEVFS_URB_TYPE_INTERRUPT:
drivers/usb/core/devio.c:	case USBDEVFS_URB_TYPE_ISO:
drivers/usb/core/devio.c:		isofrmlen = sizeof(struct usbdevfs_iso_packet_desc) *
drivers/usb/core/devio.c:		if (is_in && uurb->type == USBDEVFS_URB_TYPE_ISO)
drivers/usb/core/devio.c:	 * the USBDEVFS_URB_* flags are a user API and must not be changed.
drivers/usb/core/devio.c:	if (uurb->flags & USBDEVFS_URB_ISO_ASAP)
drivers/usb/core/devio.c:	if (uurb->flags & USBDEVFS_URB_SHORT_NOT_OK)
drivers/usb/core/devio.c:	if (uurb->flags & USBDEVFS_URB_NO_FSBR)
drivers/usb/core/devio.c:	if (uurb->flags & USBDEVFS_URB_ZERO_PACKET)
drivers/usb/core/devio.c:	if (uurb->flags & USBDEVFS_URB_NO_INTERRUPT)
drivers/usb/core/devio.c:	if (uurb->type == USBDEVFS_URB_TYPE_ISO ||
drivers/usb/core/devio.c:		if (uurb->flags & USBDEVFS_URB_BULK_CONTINUATION)
drivers/usb/core/devio.c:	struct usbdevfs_urb uurb;
drivers/usb/core/devio.c:			(((struct usbdevfs_urb __user *)arg)->iso_frame_desc),
drivers/usb/core/devio.c:	struct usbdevfs_urb __user *userurb = as->userurb;
drivers/usb/core/devio.c:				struct usbdevfs_ctrltransfer32 __user *p32)
drivers/usb/core/devio.c:        struct usbdevfs_ctrltransfer __user *p;
drivers/usb/core/devio.c:			struct usbdevfs_bulktransfer32 __user *p32)
drivers/usb/core/devio.c:        struct usbdevfs_bulktransfer __user *p;
drivers/usb/core/devio.c:	struct usbdevfs_disconnectsignal32 ds;
drivers/usb/core/devio.c:static int get_urb32(struct usbdevfs_urb *kurb,
drivers/usb/core/devio.c:		     struct usbdevfs_urb32 __user *uurb)
drivers/usb/core/devio.c:	struct usbdevfs_urb uurb;
drivers/usb/core/devio.c:	if (get_urb32(&uurb, (struct usbdevfs_urb32 __user *)arg))
drivers/usb/core/devio.c:			((struct usbdevfs_urb32 __user *)arg)->iso_frame_desc,
drivers/usb/core/devio.c:	struct usbdevfs_urb32 __user *userurb = as->userurb;
drivers/usb/core/devio.c:	struct usbdevfs_disconnectsignal ds;
drivers/usb/core/devio.c:static int proc_ioctl(struct dev_state *ps, struct usbdevfs_ioctl *ctl)
drivers/usb/core/devio.c:	case USBDEVFS_DISCONNECT:
drivers/usb/core/devio.c:	case USBDEVFS_CONNECT:
drivers/usb/core/devio.c:	struct usbdevfs_ioctl	ctrl;
drivers/usb/core/devio.c:	struct usbdevfs_ioctl32 __user *uioc;
drivers/usb/core/devio.c:	struct usbdevfs_ioctl ctrl;
drivers/usb/core/devio.c:	case USBDEVFS_CONTROL:
drivers/usb/core/devio.c:	case USBDEVFS_BULK:
drivers/usb/core/devio.c:	case USBDEVFS_RESETEP:
drivers/usb/core/devio.c:	case USBDEVFS_RESET:
drivers/usb/core/devio.c:	case USBDEVFS_CLEAR_HALT:
drivers/usb/core/devio.c:	case USBDEVFS_GETDRIVER:
drivers/usb/core/devio.c:	case USBDEVFS_CONNECTINFO:
drivers/usb/core/devio.c:	case USBDEVFS_SETINTERFACE:
drivers/usb/core/devio.c:	case USBDEVFS_SETCONFIGURATION:
drivers/usb/core/devio.c:	case USBDEVFS_SUBMITURB:
drivers/usb/core/devio.c:	case USBDEVFS_CONTROL32:
drivers/usb/core/devio.c:	case USBDEVFS_BULK32:
drivers/usb/core/devio.c:	case USBDEVFS_DISCSIGNAL32:
drivers/usb/core/devio.c:	case USBDEVFS_SUBMITURB32:
drivers/usb/core/devio.c:	case USBDEVFS_REAPURB32:
drivers/usb/core/devio.c:	case USBDEVFS_REAPURBNDELAY32:
drivers/usb/core/devio.c:	case USBDEVFS_IOCTL32:
drivers/usb/core/devio.c:	case USBDEVFS_DISCARDURB:
drivers/usb/core/devio.c:	case USBDEVFS_REAPURB:
drivers/usb/core/devio.c:	case USBDEVFS_REAPURBNDELAY:
drivers/usb/core/devio.c:	case USBDEVFS_DISCSIGNAL:
drivers/usb/core/devio.c:	case USBDEVFS_CLAIMINTERFACE:
drivers/usb/core/devio.c:	case USBDEVFS_RELEASEINTERFACE:
drivers/usb/core/devio.c:	case USBDEVFS_IOCTL:
drivers/usb/core/devio.c:	case USBDEVFS_CLAIM_PORT:
drivers/usb/core/devio.c:	case USBDEVFS_RELEASE_PORT:
drivers/usb/core/inode.c: *   0.2  10.12.2001  converted to use the vfs layer better
drivers/usb/core/inode.c:static struct vfsmount *usbfs_mount;
drivers/usb/core/inode.c:	 * block. A pointer to that is in the struct vfsmount that we
drivers/usb/class/usblp.c: *	v0.8 - add devfs support
drivers/usb/misc/iowarrior.c: * and to have the device registered with devfs and the driver core
drivers/usb/misc/usbtest.c:/* FIXME make these public somewhere; usbdevfs.h? */
drivers/usb/misc/usbtest.c:	/* FIXME USBDEVFS_CONNECTINFO doesn't say how fast the device is. */
drivers/usb/misc/adutux.c: * and to have the device registered with devfs and the driver core
drivers/usb/gadget/Kconfig:	   for a bursty VFS behaviour. For instance there may be CPU wake up
drivers/usb/gadget/Kconfig:	   latencies that makes the VFS to appear bursty in a system with
drivers/usb/gadget/Kconfig:	   save often and spin up occasionally to move data within VFS.
drivers/usb/gadget/Kconfig:	  Mass-storage performance numbers at the VFS level.
drivers/usb/gadget/f_mtp_samsung.c:		ret = vfs_read(file, req->buf + hdr_length,
drivers/usb/gadget/file_storage.c:		nread = vfs_read(curlun->filp,
drivers/usb/gadget/file_storage.c:			nwritten = vfs_write(curlun->filp,
drivers/usb/gadget/file_storage.c:		nread = vfs_read(curlun->filp,
drivers/usb/gadget/storage_common.c:	return vfs_fsync(filp, 1);
drivers/usb/gadget/f_mass_storage.c:			nread = vfs_read(curlun->filp,
drivers/usb/gadget/f_mass_storage.c:			nread = vfs_read(curlun->filp,
drivers/usb/gadget/f_mass_storage.c:		nread = vfs_read(curlun->filp,
drivers/usb/gadget/f_mass_storage.c:			nwritten = vfs_write(curlun->filp,
drivers/usb/gadget/f_mass_storage.c:		nread = vfs_read(curlun->filp,
drivers/usb/gadget/f_mtp.c:		ret = vfs_read(filp, req->buf + hdr_size, xfer - hdr_size,
drivers/usb/gadget/f_mtp.c:			ret = vfs_write(filp, write_req->buf, write_req->actual,
drivers/usb/gadget/f_mtp.c:			DBG(cdev, "vfs_write %d\n", ret);
drivers/usb/gadget/f_mtp.c:		 * in kernel context, which is necessary for vfs_read and
drivers/usb/gadget/f_mtp.c:		 * vfs_write to use our buffers in the kernel address space.
drivers/mtd/nand/nandsim.c:	tx = vfs_read(file, (char __user *)buf, count, pos);
drivers/mtd/nand/nandsim.c:	tx = vfs_write(file, (char __user *)buf, count, pos);
drivers/mtd/mtdchar.c:static struct vfsmount *mnt;
drivers/tty/tty_io.c: * Added devfs support.
drivers/tty/tty_io.c: * Move do_SAK() into process context.  Less stack use in devfs functions.
drivers/tty/tty_io.c:		res = vfs_write(p, buf, count, &p->f_pos);
drivers/tty/tty_io.c: *	tty_release		-	vfs callback for close
drivers/staging/bcm/InterfaceDld.c:		len = vfs_read(flp, (void __force __user *)buff,
drivers/staging/bcm/InterfaceDld.c:		len = vfs_read(flp, (void __force __user *)buff, MAX_TRANSFER_CTRL_BYTE_USB, &pos);
drivers/staging/bcm/Misc.c:	vfs_llseek(flp, 0, 0);
drivers/staging/bcm/Misc.c:	len = vfs_read(flp, (void __user __force *)buff, BUFFER_1K, &pos);
drivers/staging/vme/bridges/vme_tsi148.h:#define TSI148_LCSR_ITAT_VFS_M         (3<<16)	/* Virtual FIFO Size Mask */
drivers/staging/vme/bridges/vme_tsi148.h:#define TSI148_LCSR_ITAT_VFS_64        (0<<16)	/* 64 bytes Virtual FIFO Size */
drivers/staging/vme/bridges/vme_tsi148.h:#define TSI148_LCSR_ITAT_VFS_128       (1<<16)	/* 128 bytes Virtual FIFO Sz */
drivers/staging/vme/bridges/vme_tsi148.h:#define TSI148_LCSR_ITAT_VFS_256       (2<<16)	/* 256 bytes Virtual FIFO Sz */
drivers/staging/vme/bridges/vme_tsi148.h:#define TSI148_LCSR_ITAT_VFS_512       (3<<16)	/* 512 bytes Virtual FIFO Sz */
drivers/staging/tidspbridge/include/dspbridge/io_sm.h:#ifdef CONFIG_TIDSPBRIDGE_DVFS
drivers/staging/tidspbridge/Kconfig:config TIDSPBRIDGE_DVFS
drivers/staging/tidspbridge/Kconfig:	bool "Enable Bridge Dynamic Voltage and Frequency Scaling (DVFS)"
drivers/staging/tidspbridge/Kconfig:	  DVFS allows DSP Bridge to initiate the operating point change to
drivers/staging/tidspbridge/core/tiomap_io.c:#ifdef CONFIG_TIDSPBRIDGE_DVFS
drivers/staging/tidspbridge/core/tiomap_io.c:#ifdef CONFIG_TIDSPBRIDGE_DVFS
drivers/staging/tidspbridge/core/tiomap3430_pwr.c:#ifdef CONFIG_TIDSPBRIDGE_DVFS
drivers/staging/tidspbridge/core/tiomap3430_pwr.c:#endif /* #ifdef CONFIG_TIDSPBRIDGE_DVFS */
drivers/staging/tidspbridge/core/tiomap3430_pwr.c:#ifdef CONFIG_TIDSPBRIDGE_DVFS
drivers/staging/tidspbridge/core/tiomap3430_pwr.c:#ifdef CONFIG_TIDSPBRIDGE_DVFS
drivers/staging/tidspbridge/core/tiomap3430_pwr.c:#endif /* CONFIG_TIDSPBRIDGE_DVFS */
drivers/staging/tidspbridge/core/tiomap3430_pwr.c:#ifdef CONFIG_TIDSPBRIDGE_DVFS
drivers/staging/tidspbridge/core/tiomap3430_pwr.c:#endif /* CONFIG_TIDSPBRIDGE_DVFS */
drivers/staging/tidspbridge/core/tiomap3430_pwr.c:#ifdef CONFIG_TIDSPBRIDGE_DVFS
drivers/staging/tidspbridge/core/tiomap3430_pwr.c:#endif /* #ifdef CONFIG_TIDSPBRIDGE_DVFS */
drivers/staging/tidspbridge/core/tiomap3430_pwr.c:#ifdef CONFIG_TIDSPBRIDGE_DVFS
drivers/staging/tidspbridge/core/tiomap3430_pwr.c:#endif /* #ifdef CONFIG_TIDSPBRIDGE_DVFS */
drivers/staging/tidspbridge/core/io_sm.c:#ifdef CONFIG_TIDSPBRIDGE_DVFS
drivers/staging/tidspbridge/rmgr/drv_interface.c:#ifdef CONFIG_TIDSPBRIDGE_DVFS
drivers/staging/tidspbridge/rmgr/drv_interface.c:#ifdef CONFIG_TIDSPBRIDGE_DVFS
drivers/staging/tidspbridge/rmgr/drv_interface.c:#ifdef CONFIG_TIDSPBRIDGE_DVFS
drivers/staging/tidspbridge/rmgr/drv_interface.c:#ifdef CONFIG_TIDSPBRIDGE_DVFS
drivers/staging/tidspbridge/rmgr/drv_interface.c: * Initializes recovery, PM and DVFS required data, before calling
drivers/staging/tidspbridge/rmgr/drv_interface.c:#ifdef CONFIG_TIDSPBRIDGE_DVFS
drivers/staging/tidspbridge/rmgr/drv_interface.c:#ifdef CONFIG_TIDSPBRIDGE_DVFS
drivers/staging/tidspbridge/rmgr/drv_interface.c:#ifdef CONFIG_TIDSPBRIDGE_DVFS
drivers/staging/tidspbridge/rmgr/drv_interface.c:#ifdef CONFIG_TIDSPBRIDGE_DVFS
drivers/staging/tidspbridge/rmgr/drv_interface.c:#endif /* #ifdef CONFIG_TIDSPBRIDGE_DVFS */
drivers/staging/tidspbridge/rmgr/proc.c:#if defined(CONFIG_TIDSPBRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
drivers/staging/tidspbridge/rmgr/proc.c:#if defined(CONFIG_TIDSPBRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
drivers/staging/tidspbridge/rmgr/proc.c:#if defined(CONFIG_TIDSPBRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
drivers/staging/tidspbridge/rmgr/node.c:#if defined(CONFIG_TIDSPBRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
drivers/staging/tidspbridge/rmgr/node.c:#if defined(CONFIG_TIDSPBRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
drivers/staging/tidspbridge/rmgr/node.c:#if defined(CONFIG_TIDSPBRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
drivers/staging/prima/CORE/BAP/src/bapRsnSsmEapol.c:void bapRsnEapolHandler( v_PVOID_t pvFsm, tAniPacket *packet, v_BOOL_t fIsAuth )
drivers/staging/prima/CORE/BAP/src/bapRsnSsmEapol.c:            tAuthRsnFsm *fsm = (tAuthRsnFsm *)pvFsm;
drivers/staging/prima/CORE/BAP/src/bapRsnSsmEapol.c:            tSuppRsnFsm *fsm = (tSuppRsnFsm *)pvFsm;
drivers/staging/prima/CORE/BAP/src/bapRsnSsmEapol.h:void bapRsnEapolHandler( v_PVOID_t pvFsm, tAniPacket *packet, v_BOOL_t fIsAuth );
drivers/block/floppy.c: * 1998/1/21 -- Richard Gooch <rgooch@atnf.csiro.au> -- devfs support
drivers/block/floppy.c:	if (WARN(max_buffer_sectors == 0, "VFS: Block I/O scheduled on unopened device\n"))
drivers/block/floppy.c:		 "VFS: %s called on non-open device\n", __func__))
drivers/block/floppy.c:			 "VFS: revalidate called on non-open device.\n"))
drivers/block/umem.c: *			 - unregister umem from devfs at mod unload
drivers/block/loop.c: * Added devfs support - Richard Gooch <rgooch@atnf.csiro.au> 16-Jan-1998
drivers/block/loop.c:			ret = vfs_fsync(file, 0);
drivers/block/loop.c:			ret = vfs_fsync(file, 0);
drivers/block/loop.c:	error = vfs_getattr(file->f_path.mnt, file->f_path.dentry, &stat);
drivers/input/keyboard/gpio_keys.c:	struct delayed_work	work_dvfs_off;
drivers/input/keyboard/gpio_keys.c:	struct delayed_work	work_dvfs_chg;
drivers/input/keyboard/gpio_keys.c:	bool dvfs_lock_status;
drivers/input/keyboard/gpio_keys.c:	struct mutex		dvfs_lock;
drivers/input/keyboard/gpio_keys.c:static void gpio_key_change_dvfs_lock(struct work_struct *work)
drivers/input/keyboard/gpio_keys.c:			struct gpio_button_data, work_dvfs_chg.work);
drivers/input/keyboard/gpio_keys.c:	mutex_lock(&bdata->dvfs_lock);
drivers/input/keyboard/gpio_keys.c:	retval = set_freq_limit(DVFS_TOUCH_ID,
drivers/input/keyboard/gpio_keys.c:	mutex_unlock(&bdata->dvfs_lock);
drivers/input/keyboard/gpio_keys.c:static void gpio_key_set_dvfs_off(struct work_struct *work)
drivers/input/keyboard/gpio_keys.c:			struct gpio_button_data, work_dvfs_off.work);
drivers/input/keyboard/gpio_keys.c:	mutex_lock(&bdata->dvfs_lock);
drivers/input/keyboard/gpio_keys.c:	retval = set_freq_limit(DVFS_TOUCH_ID, -1);
drivers/input/keyboard/gpio_keys.c:	bdata->dvfs_lock_status = false;
drivers/input/keyboard/gpio_keys.c:	mutex_unlock(&bdata->dvfs_lock);
drivers/input/keyboard/gpio_keys.c:static void gpio_key_set_dvfs_lock(struct gpio_button_data *bdata,
drivers/input/keyboard/gpio_keys.c:	mutex_lock(&bdata->dvfs_lock);
drivers/input/keyboard/gpio_keys.c:		if (bdata->dvfs_lock_status) {
drivers/input/keyboard/gpio_keys.c:			schedule_delayed_work(&bdata->work_dvfs_off,
drivers/input/keyboard/gpio_keys.c:		cancel_delayed_work(&bdata->work_dvfs_off);
drivers/input/keyboard/gpio_keys.c:		if (!bdata->dvfs_lock_status) {
drivers/input/keyboard/gpio_keys.c:			ret = set_freq_limit(DVFS_TOUCH_ID,
drivers/input/keyboard/gpio_keys.c:			schedule_delayed_work(&bdata->work_dvfs_chg,
drivers/input/keyboard/gpio_keys.c:			bdata->dvfs_lock_status = true;
drivers/input/keyboard/gpio_keys.c:	mutex_unlock(&bdata->dvfs_lock);
drivers/input/keyboard/gpio_keys.c:static int gpio_key_init_dvfs(struct gpio_button_data *bdata)
drivers/input/keyboard/gpio_keys.c:	mutex_init(&bdata->dvfs_lock);
drivers/input/keyboard/gpio_keys.c:	INIT_DELAYED_WORK(&bdata->work_dvfs_off, gpio_key_set_dvfs_off);
drivers/input/keyboard/gpio_keys.c:	INIT_DELAYED_WORK(&bdata->work_dvfs_chg, gpio_key_change_dvfs_lock);
drivers/input/keyboard/gpio_keys.c:	bdata->dvfs_lock_status = false;
drivers/input/keyboard/gpio_keys.c:		gpio_key_set_dvfs_lock(bdata, !!state);
drivers/input/keyboard/gpio_keys.c:		error = gpio_key_init_dvfs(bdata);
drivers/input/keyboard/gpio_keys.c:			dev_err(dev, "Fail get dvfs level for touch booster\n");
drivers/input/keyboard/tc360-touchkey.c:	nread = vfs_read(fp, (char __user *)data->fw_img, len, &fp->f_pos);
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:	struct delayed_work	work_dvfs_off;
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:	struct delayed_work	work_dvfs_chg;
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:	bool dvfs_lock_status;
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:	struct mutex		dvfs_lock;
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:static void cypress_change_dvfs_lock(struct work_struct *work)
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:			struct cypress_touchkey_info, work_dvfs_chg.work);
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:	mutex_lock(&info->dvfs_lock);
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:	retval = set_freq_limit(DVFS_TOUCH_ID,
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:	mutex_unlock(&info->dvfs_lock);
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:static void cypress_set_dvfs_off(struct work_struct *work)
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:			struct cypress_touchkey_info, work_dvfs_off.work);
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:	mutex_lock(&info->dvfs_lock);
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:	retval = set_freq_limit(DVFS_TOUCH_ID, -1);
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:	info->dvfs_lock_status = false;
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:	mutex_unlock(&info->dvfs_lock);
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:static void cypress_set_dvfs_lock(struct cypress_touchkey_info *info,
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:	mutex_lock(&info->dvfs_lock);
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:		if (info->dvfs_lock_status) {
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:			schedule_delayed_work(&info->work_dvfs_off,
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:		cancel_delayed_work(&info->work_dvfs_off);
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:		if (!info->dvfs_lock_status) {
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:			ret = set_freq_limit(DVFS_TOUCH_ID,
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:			schedule_delayed_work(&info->work_dvfs_chg,
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:			info->dvfs_lock_status = true;
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:		if (info->dvfs_lock_status) {
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:			cancel_delayed_work(&info->work_dvfs_off);
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:			cancel_delayed_work(&info->work_dvfs_chg);
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:			schedule_work(&info->work_dvfs_off.work);
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:	mutex_unlock(&info->dvfs_lock);
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:static void cypress_init_dvfs(struct cypress_touchkey_info *info)
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:	mutex_init(&info->dvfs_lock);
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:	INIT_DELAYED_WORK(&info->work_dvfs_off, cypress_set_dvfs_off);
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:	INIT_DELAYED_WORK(&info->work_dvfs_chg, cypress_change_dvfs_lock);
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:	info->dvfs_lock_status = false;
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:	cypress_set_dvfs_lock(info, !!press);
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:	cypress_init_dvfs(info);
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:	cypress_set_dvfs_lock(info, 2);
drivers/input/keyboard/cypress_touchkey_236/cypress-touchkey-236.c:			"%s: dvfs_lock free.\n", __func__);
drivers/input/touchscreen/synaptics_i2c_rmi.c:static void synaptics_change_dvfs_lock(struct work_struct *work)
drivers/input/touchscreen/synaptics_i2c_rmi.c:			struct synaptics_rmi4_data, work_dvfs_chg.work);
drivers/input/touchscreen/synaptics_i2c_rmi.c:	mutex_lock(&rmi4_data->dvfs_lock);
drivers/input/touchscreen/synaptics_i2c_rmi.c:	if (rmi4_data->dvfs_boost_mode == DVFS_STAGE_DUAL) {
drivers/input/touchscreen/synaptics_i2c_rmi.c:		retval = set_freq_limit(DVFS_TOUCH_ID,
drivers/input/touchscreen/synaptics_i2c_rmi.c:		rmi4_data->dvfs_freq = MIN_TOUCH_LIMIT_SECOND;
drivers/input/touchscreen/synaptics_i2c_rmi.c:	} else if (rmi4_data->dvfs_boost_mode == DVFS_STAGE_NINTH) {
drivers/input/touchscreen/synaptics_i2c_rmi.c:			retval = set_freq_limit(DVFS_TOUCH_ID,
drivers/input/touchscreen/synaptics_i2c_rmi.c:			rmi4_data->dvfs_freq = MIN_TOUCH_HIGH_LIMIT_SECOND;
drivers/input/touchscreen/synaptics_i2c_rmi.c:	} else if (rmi4_data->dvfs_boost_mode == DVFS_STAGE_SINGLE) {
drivers/input/touchscreen/synaptics_i2c_rmi.c:		retval = set_freq_limit(DVFS_TOUCH_ID, -1);
drivers/input/touchscreen/synaptics_i2c_rmi.c:		rmi4_data->dvfs_freq = -1;
drivers/input/touchscreen/synaptics_i2c_rmi.c:	mutex_unlock(&rmi4_data->dvfs_lock);
drivers/input/touchscreen/synaptics_i2c_rmi.c:static void synaptics_set_dvfs_off(struct work_struct *work)
drivers/input/touchscreen/synaptics_i2c_rmi.c:			struct synaptics_rmi4_data, work_dvfs_off.work);
drivers/input/touchscreen/synaptics_i2c_rmi.c:	mutex_lock(&rmi4_data->dvfs_lock);
drivers/input/touchscreen/synaptics_i2c_rmi.c:	retval = set_freq_limit(DVFS_TOUCH_ID, -1);
drivers/input/touchscreen/synaptics_i2c_rmi.c:	rmi4_data->dvfs_freq = -1;
drivers/input/touchscreen/synaptics_i2c_rmi.c:	rmi4_data->dvfs_lock_status = false;
drivers/input/touchscreen/synaptics_i2c_rmi.c:	mutex_unlock(&rmi4_data->dvfs_lock);
drivers/input/touchscreen/synaptics_i2c_rmi.c:static void synaptics_set_dvfs_lock(struct synaptics_rmi4_data *rmi4_data,
drivers/input/touchscreen/synaptics_i2c_rmi.c:	if (rmi4_data->dvfs_boost_mode == DVFS_STAGE_NONE) {
drivers/input/touchscreen/synaptics_i2c_rmi.c:				"%s: DVFS stage is none(%d)\n",
drivers/input/touchscreen/synaptics_i2c_rmi.c:				__func__, rmi4_data->dvfs_boost_mode);
drivers/input/touchscreen/synaptics_i2c_rmi.c:	mutex_lock(&rmi4_data->dvfs_lock);
drivers/input/touchscreen/synaptics_i2c_rmi.c:		if (rmi4_data->dvfs_lock_status) {
drivers/input/touchscreen/synaptics_i2c_rmi.c:			if (rmi4_data->dvfs_boost_mode == DVFS_STAGE_NINTH)
drivers/input/touchscreen/synaptics_i2c_rmi.c:				schedule_delayed_work(&rmi4_data->work_dvfs_off,
drivers/input/touchscreen/synaptics_i2c_rmi.c:				schedule_delayed_work(&rmi4_data->work_dvfs_off,
drivers/input/touchscreen/synaptics_i2c_rmi.c:		cancel_delayed_work(&rmi4_data->work_dvfs_off);
drivers/input/touchscreen/synaptics_i2c_rmi.c:		if (rmi4_data->dvfs_old_stauts != on) {
drivers/input/touchscreen/synaptics_i2c_rmi.c:			cancel_delayed_work(&rmi4_data->work_dvfs_chg);
drivers/input/touchscreen/synaptics_i2c_rmi.c:			if (1/*!rmi4_data->dvfs_lock_status*/) {
drivers/input/touchscreen/synaptics_i2c_rmi.c:				if ((rmi4_data->dvfs_freq != MIN_TOUCH_LIMIT)  &&
drivers/input/touchscreen/synaptics_i2c_rmi.c:					(rmi4_data->dvfs_boost_mode != DVFS_STAGE_NINTH)) {
drivers/input/touchscreen/synaptics_i2c_rmi.c:					ret = set_freq_limit(DVFS_TOUCH_ID,
drivers/input/touchscreen/synaptics_i2c_rmi.c:					rmi4_data->dvfs_freq = MIN_TOUCH_LIMIT;
drivers/input/touchscreen/synaptics_i2c_rmi.c:				} else if ((rmi4_data->dvfs_freq != MIN_TOUCH_HIGH_LIMIT) &&
drivers/input/touchscreen/synaptics_i2c_rmi.c:						(rmi4_data->dvfs_boost_mode == DVFS_STAGE_NINTH)) {
drivers/input/touchscreen/synaptics_i2c_rmi.c:					ret = set_freq_limit(DVFS_TOUCH_ID,
drivers/input/touchscreen/synaptics_i2c_rmi.c:					rmi4_data->dvfs_freq = MIN_TOUCH_HIGH_LIMIT;
drivers/input/touchscreen/synaptics_i2c_rmi.c:				if (rmi4_data->dvfs_boost_mode == DVFS_STAGE_NINTH)
drivers/input/touchscreen/synaptics_i2c_rmi.c:					schedule_delayed_work(&rmi4_data->work_dvfs_chg,
drivers/input/touchscreen/synaptics_i2c_rmi.c:					schedule_delayed_work(&rmi4_data->work_dvfs_chg,
drivers/input/touchscreen/synaptics_i2c_rmi.c:				rmi4_data->dvfs_lock_status = true;
drivers/input/touchscreen/synaptics_i2c_rmi.c:		if (rmi4_data->dvfs_lock_status) {
drivers/input/touchscreen/synaptics_i2c_rmi.c:			cancel_delayed_work(&rmi4_data->work_dvfs_off);
drivers/input/touchscreen/synaptics_i2c_rmi.c:			cancel_delayed_work(&rmi4_data->work_dvfs_chg);
drivers/input/touchscreen/synaptics_i2c_rmi.c:			schedule_work(&rmi4_data->work_dvfs_off.work);
drivers/input/touchscreen/synaptics_i2c_rmi.c:	rmi4_data->dvfs_old_stauts = on;
drivers/input/touchscreen/synaptics_i2c_rmi.c:	mutex_unlock(&rmi4_data->dvfs_lock);
drivers/input/touchscreen/synaptics_i2c_rmi.c:static void synaptics_init_dvfs(struct synaptics_rmi4_data *rmi4_data)
drivers/input/touchscreen/synaptics_i2c_rmi.c:	mutex_init(&rmi4_data->dvfs_lock);
drivers/input/touchscreen/synaptics_i2c_rmi.c:	rmi4_data->dvfs_boost_mode = DVFS_STAGE_DUAL;
drivers/input/touchscreen/synaptics_i2c_rmi.c:	INIT_DELAYED_WORK(&rmi4_data->work_dvfs_off, synaptics_set_dvfs_off);
drivers/input/touchscreen/synaptics_i2c_rmi.c:	INIT_DELAYED_WORK(&rmi4_data->work_dvfs_chg, synaptics_change_dvfs_lock);
drivers/input/touchscreen/synaptics_i2c_rmi.c:	rmi4_data->dvfs_lock_status = false;
drivers/input/touchscreen/synaptics_i2c_rmi.c:		synaptics_set_dvfs_lock(rmi4_data, touch_count);
drivers/input/touchscreen/synaptics_i2c_rmi.c:		synaptics_set_dvfs_lock(rmi4_data, 0);
drivers/input/touchscreen/synaptics_i2c_rmi.c:	synaptics_set_dvfs_lock(rmi4_data, -1);
drivers/input/touchscreen/synaptics_i2c_rmi.c:			"%s: dvfs_lock free.\n", __func__);
drivers/input/touchscreen/synaptics_i2c_rmi.c:	synaptics_init_dvfs(rmi4_data);
drivers/input/touchscreen/rmi_fw_update.c:	retval = set_freq_limit(DVFS_TOUCH_ID,
drivers/input/touchscreen/rmi_fw_update.c:			"%s: dvfs failed at fw update.\n",
drivers/input/touchscreen/rmi_fw_update.c:	retval = set_freq_limit(DVFS_TOUCH_ID, -1);
drivers/input/touchscreen/mms_ts_144.c:#ifdef CONFIG_SEC_DVFS
drivers/input/touchscreen/mms_ts_144.c:	struct delayed_work work_dvfs_off;
drivers/input/touchscreen/mms_ts_144.c:	struct delayed_work	work_dvfs_chg;
drivers/input/touchscreen/mms_ts_144.c:	bool	dvfs_lock_status;
drivers/input/touchscreen/mms_ts_144.c:	struct mutex dvfs_lock;
drivers/input/touchscreen/mms_ts_144.c:static void change_dvfs_lock(struct work_struct *work)
drivers/input/touchscreen/mms_ts_144.c:				struct mms_ts_info, work_dvfs_chg.work);
drivers/input/touchscreen/mms_ts_144.c:	mutex_lock(&info->dvfs_lock);
drivers/input/touchscreen/mms_ts_144.c:	ret = set_freq_limit(DVFS_TOUCH_ID, MIN_TOUCH_LIMIT_SECOND);
drivers/input/touchscreen/mms_ts_144.c:	mutex_unlock(&info->dvfs_lock);
drivers/input/touchscreen/mms_ts_144.c:static void set_dvfs_off(struct work_struct *work)
drivers/input/touchscreen/mms_ts_144.c:				struct mms_ts_info, work_dvfs_off.work);
drivers/input/touchscreen/mms_ts_144.c:	mutex_lock(&info->dvfs_lock);
drivers/input/touchscreen/mms_ts_144.c:	set_freq_limit(DVFS_TOUCH_ID, -1);
drivers/input/touchscreen/mms_ts_144.c:	info->dvfs_lock_status = false;
drivers/input/touchscreen/mms_ts_144.c:	mutex_unlock(&info->dvfs_lock);
drivers/input/touchscreen/mms_ts_144.c:	pr_info("[TSP] DVFS Off!");
drivers/input/touchscreen/mms_ts_144.c:static void set_dvfs_lock(struct mms_ts_info *info, uint32_t on)
drivers/input/touchscreen/mms_ts_144.c:	mutex_lock(&info->dvfs_lock);
drivers/input/touchscreen/mms_ts_144.c:		if (info->dvfs_lock_status) {
drivers/input/touchscreen/mms_ts_144.c:			cancel_delayed_work(&info->work_dvfs_chg);
drivers/input/touchscreen/mms_ts_144.c:			schedule_delayed_work(&info->work_dvfs_off,
drivers/input/touchscreen/mms_ts_144.c:		cancel_delayed_work(&info->work_dvfs_off);
drivers/input/touchscreen/mms_ts_144.c:		if (!info->dvfs_lock_status) {
drivers/input/touchscreen/mms_ts_144.c:			ret = set_freq_limit(DVFS_TOUCH_ID, MIN_TOUCH_LIMIT);
drivers/input/touchscreen/mms_ts_144.c:			schedule_delayed_work(&info->work_dvfs_chg,
drivers/input/touchscreen/mms_ts_144.c:			info->dvfs_lock_status = true;
drivers/input/touchscreen/mms_ts_144.c:			pr_info("[TSP] DVFS On!");
drivers/input/touchscreen/mms_ts_144.c:		cancel_delayed_work(&info->work_dvfs_off);
drivers/input/touchscreen/mms_ts_144.c:		cancel_delayed_work(&info->work_dvfs_chg);
drivers/input/touchscreen/mms_ts_144.c:		schedule_work(&info->work_dvfs_off.work);
drivers/input/touchscreen/mms_ts_144.c:	mutex_unlock(&info->dvfs_lock);
drivers/input/touchscreen/mms_ts_144.c:	set_dvfs_lock(info, 2);
drivers/input/touchscreen/mms_ts_144.c:	pr_info("[TSP] dvfs_lock free.\n ");
drivers/input/touchscreen/mms_ts_144.c:	set_dvfs_lock(info, !!touch_is_pressed);
drivers/input/touchscreen/mms_ts_144.c:		nread = vfs_read(fp, (char __user *)buff, fsize, &fp->f_pos);
drivers/input/touchscreen/mms_ts_144.c:			nwrite = vfs_write(fp, (const char __user *)log_data,
drivers/input/touchscreen/mms_ts_144.c:	mutex_init(&info->dvfs_lock);
drivers/input/touchscreen/mms_ts_144.c:	INIT_DELAYED_WORK(&info->work_dvfs_off, set_dvfs_off);
drivers/input/touchscreen/mms_ts_144.c:	INIT_DELAYED_WORK(&info->work_dvfs_chg, change_dvfs_lock);
drivers/input/touchscreen/mms_ts_144.c:	info->dvfs_lock_status = false;
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.h:/* DVFS feature : TOUCH BOOSTER */
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.h:#ifdef CONFIG_SEC_DVFS
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.h:#define DVFS_STAGE_DUAL		2
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.h:#define DVFS_STAGE_SINGLE	1
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.h:#define DVFS_STAGE_NONE		0
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.h:	struct delayed_work	work_dvfs_off;
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.h:	struct delayed_work	work_dvfs_chg;
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.h:	struct mutex		dvfs_lock;
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.h:	bool dvfs_lock_status;
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.h:	int dvfs_old_stauts;
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.h:	int dvfs_boost_mode;
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.h:	int dvfs_freq;
drivers/input/touchscreen/cyttsp4_mt_common.h:#ifdef CONFIG_SEC_DVFS
drivers/input/touchscreen/cyttsp4_mt_common.h:	struct delayed_work work_dvfs_off;
drivers/input/touchscreen/cyttsp4_mt_common.h:	struct delayed_work work_dvfs_chg;
drivers/input/touchscreen/cyttsp4_mt_common.h:	bool	dvfs_lock_status;
drivers/input/touchscreen/cyttsp4_mt_common.h:	struct mutex dvfs_lock;
drivers/input/touchscreen/cyttsp4_mt_common.h:	int dvfs_old_status;
drivers/input/touchscreen/cyttsp4_mt_common.h:	int dvfs_boost_mode;
drivers/input/touchscreen/cyttsp4_mt_common.h:	int dvfs_freq;
drivers/input/touchscreen/rmi_f54_msm8930.c:		nread = vfs_read(fp, (char __user *)fw_data,
drivers/input/touchscreen/zinitix_bt_532.c:		nread = vfs_read(fp, (char __user *)buff, fsize, &fp->f_pos);
drivers/input/touchscreen/mxt224e.c:#ifdef CONFIG_SEC_DVFS
drivers/input/touchscreen/mxt224e.c:	struct delayed_work work_dvfs_off;
drivers/input/touchscreen/mxt224e.c:	struct delayed_work	work_dvfs_chg;
drivers/input/touchscreen/mxt224e.c:	bool	dvfs_lock_status;
drivers/input/touchscreen/mxt224e.c:	struct mutex dvfs_lock;
drivers/input/touchscreen/mxt224e.c:static bool dvfs_lock_status;
drivers/input/touchscreen/mxt224e.c:static void change_dvfs_lock(struct work_struct *work)
drivers/input/touchscreen/mxt224e.c:				struct mxt224_data, work_dvfs_chg.work);
drivers/input/touchscreen/mxt224e.c:	mutex_lock(&data->dvfs_lock);
drivers/input/touchscreen/mxt224e.c:	mutex_unlock(&data->dvfs_lock);
drivers/input/touchscreen/mxt224e.c:static void set_dvfs_off(struct work_struct *work)
drivers/input/touchscreen/mxt224e.c:				struct mxt224_data, work_dvfs_off.work);
drivers/input/touchscreen/mxt224e.c:	mutex_lock(&data->dvfs_lock);
drivers/input/touchscreen/mxt224e.c:	data->dvfs_lock_status = false;
drivers/input/touchscreen/mxt224e.c:	mutex_unlock(&data->dvfs_lock);
drivers/input/touchscreen/mxt224e.c:	pr_info("[TSP] DVFS Off!\n");
drivers/input/touchscreen/mxt224e.c:static void set_dvfs_lock(struct mxt224_data *data, uint32_t on)
drivers/input/touchscreen/mxt224e.c:	mutex_lock(&data->dvfs_lock);
drivers/input/touchscreen/mxt224e.c:		if (data->dvfs_lock_status) {
drivers/input/touchscreen/mxt224e.c:			cancel_delayed_work(&data->work_dvfs_chg);
drivers/input/touchscreen/mxt224e.c:			schedule_delayed_work(&data->work_dvfs_off,
drivers/input/touchscreen/mxt224e.c:		cancel_delayed_work(&data->work_dvfs_off);
drivers/input/touchscreen/mxt224e.c:		if (!data->dvfs_lock_status) {
drivers/input/touchscreen/mxt224e.c:			schedule_delayed_work(&data->work_dvfs_chg,
drivers/input/touchscreen/mxt224e.c:			data->dvfs_lock_status = true;
drivers/input/touchscreen/mxt224e.c:			pr_info("[TSP] DVFS On!\n");
drivers/input/touchscreen/mxt224e.c:		cancel_delayed_work(&data->work_dvfs_off);
drivers/input/touchscreen/mxt224e.c:		cancel_delayed_work(&data->work_dvfs_chg);
drivers/input/touchscreen/mxt224e.c:		schedule_work(&data->work_dvfs_off.work);
drivers/input/touchscreen/mxt224e.c:	mutex_unlock(&data->dvfs_lock);
drivers/input/touchscreen/mxt224e.c:	set_dvfs_lock(data, 2);
drivers/input/touchscreen/mxt224e.c:	pr_info("[TSP] dvfs_lock free.\n");
drivers/input/touchscreen/mxt224e.c:	set_dvfs_lock(data, !!touch_is_pressed);
drivers/input/touchscreen/mxt224e.c:	set_dvfs_lock(data, 2);
drivers/input/touchscreen/mxt224e.c:	pr_info("[TSP] dvfs_lock free.\n");
drivers/input/touchscreen/mxt224e.c:	mutex_init(&data->dvfs_lock);
drivers/input/touchscreen/mxt224e.c:	INIT_DELAYED_WORK(&data->work_dvfs_off, set_dvfs_off);
drivers/input/touchscreen/mxt224e.c:	INIT_DELAYED_WORK(&data->work_dvfs_chg, change_dvfs_lock);
drivers/input/touchscreen/mxt224e.c:	data->dvfs_lock_status = false;
drivers/input/touchscreen/mxt224e.c://	mutex_destroy(&data->dvfs_lock);
drivers/input/touchscreen/mxts_sec.c:	ret = vfs_read(filp, (char __user *)fw_data, fw.size, &filp->f_pos);
drivers/input/touchscreen/cyttsp4_mt_common.c:#define DVFS_STAGE_DUAL		2
drivers/input/touchscreen/cyttsp4_mt_common.c:#define DVFS_STAGE_SINGLE		1
drivers/input/touchscreen/cyttsp4_mt_common.c:#define DVFS_STAGE_NONE		0
drivers/input/touchscreen/cyttsp4_mt_common.c:static void change_dvfs_lock(struct work_struct *work)
drivers/input/touchscreen/cyttsp4_mt_common.c:	struct cyttsp4_mt_data *md = container_of(work,struct cyttsp4_mt_data, work_dvfs_chg.work);
drivers/input/touchscreen/cyttsp4_mt_common.c:	mutex_lock(&md->dvfs_lock);
drivers/input/touchscreen/cyttsp4_mt_common.c:	if (md->dvfs_boost_mode == DVFS_STAGE_DUAL) {
drivers/input/touchscreen/cyttsp4_mt_common.c:		ret = set_freq_limit(DVFS_TOUCH_ID, MIN_TOUCH_LIMIT_SECOND);
drivers/input/touchscreen/cyttsp4_mt_common.c:		md->dvfs_freq = MIN_TOUCH_LIMIT_SECOND;
drivers/input/touchscreen/cyttsp4_mt_common.c:	} else if (md->dvfs_boost_mode == DVFS_STAGE_SINGLE) {
drivers/input/touchscreen/cyttsp4_mt_common.c:		ret = set_freq_limit(DVFS_TOUCH_ID, -1);
drivers/input/touchscreen/cyttsp4_mt_common.c:		md->dvfs_freq = -1;
drivers/input/touchscreen/cyttsp4_mt_common.c:	mutex_unlock(&md->dvfs_lock);
drivers/input/touchscreen/cyttsp4_mt_common.c:static void set_dvfs_off(struct work_struct *work)
drivers/input/touchscreen/cyttsp4_mt_common.c:	struct cyttsp4_mt_data *md = container_of(work,struct cyttsp4_mt_data, work_dvfs_off.work);
drivers/input/touchscreen/cyttsp4_mt_common.c:	mutex_lock(&md->dvfs_lock);
drivers/input/touchscreen/cyttsp4_mt_common.c:	ret = set_freq_limit(DVFS_TOUCH_ID, -1);
drivers/input/touchscreen/cyttsp4_mt_common.c:	md->dvfs_freq = -1;
drivers/input/touchscreen/cyttsp4_mt_common.c:	md->dvfs_lock_status = false;
drivers/input/touchscreen/cyttsp4_mt_common.c:	mutex_unlock(&md->dvfs_lock);
drivers/input/touchscreen/cyttsp4_mt_common.c:	printk(KERN_INFO "[TSP] DVFS Off!\n");
drivers/input/touchscreen/cyttsp4_mt_common.c:static void set_dvfs_lock(struct cyttsp4_mt_data *md, int on)
drivers/input/touchscreen/cyttsp4_mt_common.c:	if (md->dvfs_boost_mode == DVFS_STAGE_NONE) {
drivers/input/touchscreen/cyttsp4_mt_common.c:		printk(KERN_INFO "%s: DVFS stage is none(%d)\n", __func__, md->dvfs_boost_mode);
drivers/input/touchscreen/cyttsp4_mt_common.c:	mutex_lock(&md->dvfs_lock);
drivers/input/touchscreen/cyttsp4_mt_common.c:		if (md->dvfs_lock_status) {
drivers/input/touchscreen/cyttsp4_mt_common.c:			schedule_delayed_work(&md->work_dvfs_off,msecs_to_jiffies(TOUCH_BOOSTER_OFF_TIME));
drivers/input/touchscreen/cyttsp4_mt_common.c:			printk(KERN_INFO "[TSP] DVFS_touch_release\n");
drivers/input/touchscreen/cyttsp4_mt_common.c:		cancel_delayed_work(&md->work_dvfs_off);
drivers/input/touchscreen/cyttsp4_mt_common.c:		if (md->dvfs_old_status != on) {
drivers/input/touchscreen/cyttsp4_mt_common.c:			cancel_delayed_work(&md->work_dvfs_chg);
drivers/input/touchscreen/cyttsp4_mt_common.c:				if (md->dvfs_freq != MIN_TOUCH_LIMIT) {
drivers/input/touchscreen/cyttsp4_mt_common.c:					ret = set_freq_limit(DVFS_TOUCH_ID,
drivers/input/touchscreen/cyttsp4_mt_common.c:					md->dvfs_freq = MIN_TOUCH_LIMIT;
drivers/input/touchscreen/cyttsp4_mt_common.c:			schedule_delayed_work(&md->work_dvfs_chg,
drivers/input/touchscreen/cyttsp4_mt_common.c:				md->dvfs_lock_status = true;
drivers/input/touchscreen/cyttsp4_mt_common.c:		if (md->dvfs_lock_status) {
drivers/input/touchscreen/cyttsp4_mt_common.c:			cancel_delayed_work(&md->work_dvfs_off);
drivers/input/touchscreen/cyttsp4_mt_common.c:			cancel_delayed_work(&md->work_dvfs_chg);
drivers/input/touchscreen/cyttsp4_mt_common.c:			schedule_work(&md->work_dvfs_off.work);
drivers/input/touchscreen/cyttsp4_mt_common.c:	md->dvfs_old_status = on;
drivers/input/touchscreen/cyttsp4_mt_common.c:	mutex_unlock(&md->dvfs_lock);
drivers/input/touchscreen/cyttsp4_mt_common.c:static void init_dvfs (struct cyttsp4_mt_data *md)
drivers/input/touchscreen/cyttsp4_mt_common.c:	mutex_init(&md->dvfs_lock);
drivers/input/touchscreen/cyttsp4_mt_common.c:	md->dvfs_boost_mode = DVFS_STAGE_DUAL;
drivers/input/touchscreen/cyttsp4_mt_common.c:	INIT_DELAYED_WORK(&md->work_dvfs_off, set_dvfs_off);
drivers/input/touchscreen/cyttsp4_mt_common.c:	INIT_DELAYED_WORK(&md->work_dvfs_chg, change_dvfs_lock);
drivers/input/touchscreen/cyttsp4_mt_common.c:	md->dvfs_lock_status = false;
drivers/input/touchscreen/cyttsp4_mt_common.c:				set_dvfs_lock(md, 0);
drivers/input/touchscreen/cyttsp4_mt_common.c:				set_dvfs_lock(md, 1);
drivers/input/touchscreen/cyttsp4_mt_common.c:	set_dvfs_lock(md, -1);
drivers/input/touchscreen/cyttsp4_mt_common.c:	printk(KERN_INFO "[TSP] dvfs_lock free.\n ");
drivers/input/touchscreen/cyttsp4_mt_common.c:	init_dvfs(md);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:static void synaptics_change_dvfs_lock(struct work_struct *work)
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:			struct synaptics_rmi4_data, work_dvfs_chg.work);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:	mutex_lock(&rmi4_data->dvfs_lock);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:	if (rmi4_data->dvfs_boost_mode == DVFS_STAGE_DUAL) {
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:		retval = set_freq_limit(DVFS_TOUCH_ID,
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:		rmi4_data->dvfs_freq = MIN_TOUCH_LIMIT_SECOND;
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:	} else if (rmi4_data->dvfs_boost_mode == DVFS_STAGE_SINGLE) {
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:		retval = set_freq_limit(DVFS_TOUCH_ID, -1);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:		rmi4_data->dvfs_freq = -1;
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:	mutex_unlock(&rmi4_data->dvfs_lock);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:static void synaptics_set_dvfs_off(struct work_struct *work)
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:			struct synaptics_rmi4_data, work_dvfs_off.work);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:	mutex_lock(&rmi4_data->dvfs_lock);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:	retval = set_freq_limit(DVFS_TOUCH_ID, -1);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:	rmi4_data->dvfs_freq = -1;
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:	rmi4_data->dvfs_lock_status = false;
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:	mutex_unlock(&rmi4_data->dvfs_lock);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:static void synaptics_set_dvfs_lock(struct synaptics_rmi4_data *rmi4_data,
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:	if (rmi4_data->dvfs_boost_mode == DVFS_STAGE_NONE) {
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:				"%s: DVFS stage is none(%d)\n",
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:				__func__, rmi4_data->dvfs_boost_mode);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:	mutex_lock(&rmi4_data->dvfs_lock);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:		if (rmi4_data->dvfs_lock_status) {
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:			schedule_delayed_work(&rmi4_data->work_dvfs_off,
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:		cancel_delayed_work(&rmi4_data->work_dvfs_off);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:		if (rmi4_data->dvfs_old_stauts != on) {
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:			cancel_delayed_work(&rmi4_data->work_dvfs_chg);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:			if (1/*!rmi4_data->dvfs_lock_status*/) {
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:				if (rmi4_data->dvfs_freq != MIN_TOUCH_LIMIT) {
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:					ret = set_freq_limit(DVFS_TOUCH_ID,
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:					rmi4_data->dvfs_freq = MIN_TOUCH_LIMIT;
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:			schedule_delayed_work(&rmi4_data->work_dvfs_chg,
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:				rmi4_data->dvfs_lock_status = true;
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:		if (rmi4_data->dvfs_lock_status) {
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:			cancel_delayed_work(&rmi4_data->work_dvfs_off);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:			cancel_delayed_work(&rmi4_data->work_dvfs_chg);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:			schedule_work(&rmi4_data->work_dvfs_off.work);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:	rmi4_data->dvfs_old_stauts = on;
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:	mutex_unlock(&rmi4_data->dvfs_lock);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:static void synaptics_init_dvfs(struct synaptics_rmi4_data *rmi4_data)
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:	mutex_init(&rmi4_data->dvfs_lock);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:	rmi4_data->dvfs_boost_mode = DVFS_STAGE_DUAL;
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:	INIT_DELAYED_WORK(&rmi4_data->work_dvfs_off, synaptics_set_dvfs_off);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:	INIT_DELAYED_WORK(&rmi4_data->work_dvfs_chg, synaptics_change_dvfs_lock);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:	rmi4_data->dvfs_lock_status = false;
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:		synaptics_set_dvfs_lock(rmi4_data, touch_count);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:		synaptics_set_dvfs_lock(rmi4_data, 0);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:	synaptics_set_dvfs_lock(rmi4_data, -1);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:			"%s: dvfs_lock free.\n", __func__);
drivers/input/touchscreen/synaptics_i2c_rmi_msm8930.c:	synaptics_init_dvfs(rmi4_data);
drivers/input/touchscreen/mxts_sec_msm8930.c:	ret = vfs_read(filp, (char __user *)fw_data, fw.size, &filp->f_pos);
drivers/input/touchscreen/mxts_sec_msm8930.c:	data->booster.dvfs_boost_mode = fdata->cmd_param[0];
drivers/input/touchscreen/mxts_sec_msm8930.c:			"%s: dvfs_boost_mode = %d\n",
drivers/input/touchscreen/mxts_sec_msm8930.c:			__func__, data->booster.dvfs_boost_mode);
drivers/input/touchscreen/mxts_sec_msm8930.c:	if (data->booster.dvfs_boost_mode == DVFS_STAGE_NONE) {
drivers/input/touchscreen/mxts_sec_msm8930.c:			retval = set_freq_limit(DVFS_TOUCH_ID, -1);
drivers/input/touchscreen/mxts_sec_msm8930.c:				data->booster.dvfs_lock_status = false;
drivers/input/touchscreen/mxts_sec_msm8930.c:static void change_dvfs_lock(struct work_struct *work)
drivers/input/touchscreen/mxts_sec_msm8930.c:				struct mxt_data, booster.work_dvfs_chg.work);
drivers/input/touchscreen/mxts_sec_msm8930.c:	mutex_lock(&data->booster.dvfs_lock);
drivers/input/touchscreen/mxts_sec_msm8930.c:	if (data->booster.dvfs_boost_mode == DVFS_STAGE_DUAL) {
drivers/input/touchscreen/mxts_sec_msm8930.c:		retval = set_freq_limit(DVFS_TOUCH_ID,
drivers/input/touchscreen/mxts_sec_msm8930.c:		data->booster.dvfs_freq = MIN_TOUCH_LIMIT_SECOND;
drivers/input/touchscreen/mxts_sec_msm8930.c:	} else if (data->booster.dvfs_boost_mode == DVFS_STAGE_SINGLE) {
drivers/input/touchscreen/mxts_sec_msm8930.c:		retval = set_freq_limit(DVFS_TOUCH_ID, -1);
drivers/input/touchscreen/mxts_sec_msm8930.c:		data->booster.dvfs_freq = -1;
drivers/input/touchscreen/mxts_sec_msm8930.c:	mutex_unlock(&data->booster.dvfs_lock);
drivers/input/touchscreen/mxts_sec_msm8930.c:static void set_dvfs_off(struct work_struct *work)
drivers/input/touchscreen/mxts_sec_msm8930.c:				struct mxt_data, booster.work_dvfs_off.work);
drivers/input/touchscreen/mxts_sec_msm8930.c:	mutex_lock(&data->booster.dvfs_lock);
drivers/input/touchscreen/mxts_sec_msm8930.c:	retval = set_freq_limit(DVFS_TOUCH_ID, -1);
drivers/input/touchscreen/mxts_sec_msm8930.c:	data->booster.dvfs_freq = -1;
drivers/input/touchscreen/mxts_sec_msm8930.c:	data->booster.dvfs_lock_status = false;
drivers/input/touchscreen/mxts_sec_msm8930.c:	mutex_unlock(&data->booster.dvfs_lock);
drivers/input/touchscreen/mxts_sec_msm8930.c:static void set_dvfs_lock(struct mxt_data *data, int on)
drivers/input/touchscreen/mxts_sec_msm8930.c:	if (data->booster.dvfs_boost_mode == DVFS_STAGE_NONE) {
drivers/input/touchscreen/mxts_sec_msm8930.c:				"%s: DVFS stage is none(%d)\n",
drivers/input/touchscreen/mxts_sec_msm8930.c:				__func__, data->booster.dvfs_boost_mode);
drivers/input/touchscreen/mxts_sec_msm8930.c:	mutex_lock(&data->booster.dvfs_lock);
drivers/input/touchscreen/mxts_sec_msm8930.c:		if (data->booster.dvfs_lock_status) {
drivers/input/touchscreen/mxts_sec_msm8930.c:			cancel_delayed_work(&data->booster.work_dvfs_chg);
drivers/input/touchscreen/mxts_sec_msm8930.c:			schedule_delayed_work(&data->booster.work_dvfs_off,
drivers/input/touchscreen/mxts_sec_msm8930.c:		cancel_delayed_work(&data->booster.work_dvfs_off);
drivers/input/touchscreen/mxts_sec_msm8930.c:		if (data->booster.dvfs_old_stauts != on) {
drivers/input/touchscreen/mxts_sec_msm8930.c:			cancel_delayed_work(&data->booster.work_dvfs_chg);
drivers/input/touchscreen/mxts_sec_msm8930.c:			if (data->booster.dvfs_freq != MIN_TOUCH_LIMIT) {
drivers/input/touchscreen/mxts_sec_msm8930.c:				ret = set_freq_limit(DVFS_TOUCH_ID,
drivers/input/touchscreen/mxts_sec_msm8930.c:				data->booster.dvfs_freq = MIN_TOUCH_LIMIT;
drivers/input/touchscreen/mxts_sec_msm8930.c:			schedule_delayed_work(&data->booster.work_dvfs_chg,
drivers/input/touchscreen/mxts_sec_msm8930.c:			data->booster.dvfs_lock_status = true;
drivers/input/touchscreen/mxts_sec_msm8930.c:		if (data->booster.dvfs_lock_status) {
drivers/input/touchscreen/mxts_sec_msm8930.c:			cancel_delayed_work(&data->booster.work_dvfs_off);
drivers/input/touchscreen/mxts_sec_msm8930.c:			cancel_delayed_work(&data->booster.work_dvfs_chg);
drivers/input/touchscreen/mxts_sec_msm8930.c:			schedule_work(&data->booster.work_dvfs_off.work);
drivers/input/touchscreen/mxts_sec_msm8930.c:	data->booster.dvfs_old_stauts = on;
drivers/input/touchscreen/mxts_sec_msm8930.c:	mutex_unlock(&data->booster.dvfs_lock);
drivers/input/touchscreen/mxts_sec_msm8930.c:static void mxt_init_dvfs(struct mxt_data *data)
drivers/input/touchscreen/mxts_sec_msm8930.c:	mutex_init(&data->booster.dvfs_lock);
drivers/input/touchscreen/mxts_sec_msm8930.c:	data->booster.dvfs_boost_mode = DVFS_STAGE_DUAL;
drivers/input/touchscreen/mxts_sec_msm8930.c:	INIT_DELAYED_WORK(&data->booster.work_dvfs_off, set_dvfs_off);
drivers/input/touchscreen/mxts_sec_msm8930.c:	INIT_DELAYED_WORK(&data->booster.work_dvfs_chg, change_dvfs_lock);
drivers/input/touchscreen/mxts_sec_msm8930.c:	data->booster.dvfs_lock_status = false;
drivers/input/touchscreen/rmi_f54.c:		nread = vfs_read(fp, (char __user *)fw_data,
drivers/input/touchscreen/rmi_f54.c:	rmi4_data->dvfs_boost_mode = data->cmd_param[0];
drivers/input/touchscreen/rmi_f54.c:			"%s: dvfs_boost_mode = %d\n",
drivers/input/touchscreen/rmi_f54.c:			__func__, rmi4_data->dvfs_boost_mode);
drivers/input/touchscreen/rmi_f54.c:	if (rmi4_data->dvfs_boost_mode == DVFS_STAGE_NONE) {
drivers/input/touchscreen/rmi_f54.c:			retval = set_freq_limit(DVFS_TOUCH_ID, -1);
drivers/input/touchscreen/rmi_f54.c:				rmi4_data->dvfs_lock_status = false;
drivers/input/touchscreen/synaptics_i2c_rmi.h:/* DVFS feature : TOUCH BOOSTER */
drivers/input/touchscreen/synaptics_i2c_rmi.h:#define DVFS_STAGE_NINTH		9
drivers/input/touchscreen/synaptics_i2c_rmi.h:#define DVFS_STAGE_DUAL		2
drivers/input/touchscreen/synaptics_i2c_rmi.h:#define DVFS_STAGE_SINGLE	1
drivers/input/touchscreen/synaptics_i2c_rmi.h:#define DVFS_STAGE_NONE		0
drivers/input/touchscreen/synaptics_i2c_rmi.h:	struct delayed_work	work_dvfs_off;
drivers/input/touchscreen/synaptics_i2c_rmi.h:	struct delayed_work	work_dvfs_chg;
drivers/input/touchscreen/synaptics_i2c_rmi.h:	struct mutex		dvfs_lock;
drivers/input/touchscreen/synaptics_i2c_rmi.h:	bool dvfs_lock_status;
drivers/input/touchscreen/synaptics_i2c_rmi.h:	int dvfs_old_stauts;
drivers/input/touchscreen/synaptics_i2c_rmi.h:	int dvfs_boost_mode;
drivers/input/touchscreen/synaptics_i2c_rmi.h:	int dvfs_freq;
drivers/input/touchscreen/mxts.c:static void mxt_set_dvfs_off(struct work_struct *work)
drivers/input/touchscreen/mxts.c:		container_of(work, struct mxt_data, work_dvfs_off.work);
drivers/input/touchscreen/mxts.c:	mutex_lock(&data->dvfs_lock);
drivers/input/touchscreen/mxts.c:	set_freq_limit(DVFS_TOUCH_ID, -1);
drivers/input/touchscreen/mxts.c:	data->dvfs_lock_status = false;
drivers/input/touchscreen/mxts.c:	mutex_unlock(&data->dvfs_lock);
drivers/input/touchscreen/mxts.c:	pr_info("[TSP] DVFS Off!\n");
drivers/input/touchscreen/mxts.c:static void mxt_set_dvfs_lock(struct mxt_data *data, uint32_t on)
drivers/input/touchscreen/mxts.c:	mutex_lock(&data->dvfs_lock);
drivers/input/touchscreen/mxts.c:		if (data->dvfs_lock_status) {
drivers/input/touchscreen/mxts.c:			schedule_delayed_work(&data->work_dvfs_off,
drivers/input/touchscreen/mxts.c:		cancel_delayed_work(&data->work_dvfs_off);
drivers/input/touchscreen/mxts.c:		if (!data->dvfs_lock_status) {
drivers/input/touchscreen/mxts.c:			ret = set_freq_limit(DVFS_TOUCH_ID, MIN_TOUCH_LIMIT);
drivers/input/touchscreen/mxts.c:			data->dvfs_lock_status = true;
drivers/input/touchscreen/mxts.c:			pr_info("[TSP] DVFS On!\n");
drivers/input/touchscreen/mxts.c:		cancel_delayed_work(&data->work_dvfs_off);
drivers/input/touchscreen/mxts.c:		schedule_work(&data->work_dvfs_off.work);
drivers/input/touchscreen/mxts.c:	mutex_unlock(&data->dvfs_lock);
drivers/input/touchscreen/mxts.c:	mxt_set_dvfs_lock(data, !!touch_is_pressed);
drivers/input/touchscreen/mxts.c:	/*	mxt_set_dvfs_on(data, true);*/
drivers/input/touchscreen/mxts.c:	mxt_set_dvfs_lock(data, 2);
drivers/input/touchscreen/mxts.c:	pr_info("[TSP] dvfs_lock free.\n");
drivers/input/touchscreen/mxts.c:	mutex_init(&data->dvfs_lock);
drivers/input/touchscreen/mxts.c:	INIT_DELAYED_WORK(&data->work_dvfs_off, mxt_set_dvfs_off);
drivers/input/touchscreen/mxts.c:	data->dvfs_lock_status = false;
drivers/input/touchscreen/mxts_msm8930.c:static void set_dvfs_lock(struct mxt_data *data, int on);
drivers/input/touchscreen/mxts_msm8930.c:	set_dvfs_lock(data, count);
drivers/input/touchscreen/mxts_msm8930.c:	set_dvfs_lock(data, -1);
drivers/input/touchscreen/mxts_msm8930.c:	mxt_init_dvfs(data);
drivers/dma/imx-sdma.c:		per_2_emi = sdma->script_addrs->dptc_dvfs_addr;
drivers/gpu/drm/i915/i915_gem.c:		return cnt / 100 * sysctl_vfs_cache_pressure;
drivers/gpu/drm/i915/i915_gem.c:	return cnt / 100 * sysctl_vfs_cache_pressure;
drivers/watchdog/watchdog_dev.c: *	@file: file from VFS
drivers/watchdog/pcwd.c: * 971107	Took account of recent VFS changes (broke read).
drivers/watchdog/alim1535_wdt.c: *	@file: file from VFS
drivers/watchdog/alim1535_wdt.c: *	@file: VFS file pointer
drivers/watchdog/alim1535_wdt.c: *	@inode: inode from VFS
drivers/watchdog/alim1535_wdt.c: *	@file: file from VFS
drivers/watchdog/alim1535_wdt.c: *	@inode: inode from VFS
drivers/watchdog/alim1535_wdt.c: *	@file: file from VFS
drivers/cpufreq/exynos4x12-cpufreq.c:int exynos4x12_cpufreq_init(struct exynos_dvfs_info *info)
drivers/cpufreq/Kconfig:config SEC_DVFS
drivers/cpufreq/Kconfig:	bool "DVFS job"
drivers/cpufreq/exynos-cpufreq.c:static struct exynos_dvfs_info *exynos_info;
drivers/cpufreq/exynos-cpufreq.c:	exynos_info = kzalloc(sizeof(struct exynos_dvfs_info), GFP_KERNEL);
drivers/cpufreq/exynos4210-cpufreq.c:int exynos4210_cpufreq_init(struct exynos_dvfs_info *info)
drivers/cpufreq/exynos5250-cpufreq.c:int exynos5250_cpufreq_init(struct exynos_dvfs_info *info)
drivers/cpufreq/s3c2416-cpufreq.c:struct s3c2416_dvfs {
drivers/cpufreq/s3c2416-cpufreq.c:static struct s3c2416_dvfs s3c2416_dvfs_table[] = {
drivers/cpufreq/s3c2416-cpufreq.c:	struct s3c2416_dvfs *dvfs;
drivers/cpufreq/s3c2416-cpufreq.c:		dvfs = &s3c2416_dvfs_table[idx];
drivers/cpufreq/s3c2416-cpufreq.c:			 dvfs->vddarm_min, dvfs->vddarm_max);
drivers/cpufreq/s3c2416-cpufreq.c:					    dvfs->vddarm_min,
drivers/cpufreq/s3c2416-cpufreq.c:					    dvfs->vddarm_max);
drivers/cpufreq/s3c2416-cpufreq.c:	struct s3c2416_dvfs *dvfs;
drivers/cpufreq/s3c2416-cpufreq.c:		dvfs = &s3c2416_dvfs_table[idx];
drivers/cpufreq/s3c2416-cpufreq.c:			 dvfs->vddarm_min, dvfs->vddarm_max);
drivers/cpufreq/s3c2416-cpufreq.c:					    dvfs->vddarm_min,
drivers/cpufreq/s3c2416-cpufreq.c:					    dvfs->vddarm_max);
drivers/cpufreq/s3c2416-cpufreq.c:	struct s3c2416_dvfs *dvfs;
drivers/cpufreq/s3c2416-cpufreq.c:		dvfs = &s3c2416_dvfs_table[freq->index];
drivers/cpufreq/s3c2416-cpufreq.c:			if (v >= dvfs->vddarm_min)
drivers/cpufreq/cpufreq_ondemand.c:#if !defined(CONFIG_SEC_DVFS)
drivers/cpufreq/cpufreq_ondemand.c:#if !defined(CONFIG_SEC_DVFS)
drivers/cpufreq/cpufreq_ondemand.c:#if !defined(CONFIG_SEC_DVFS)
drivers/cpufreq/s3c64xx-cpufreq.c:struct s3c64xx_dvfs {
drivers/cpufreq/s3c64xx-cpufreq.c:static struct s3c64xx_dvfs s3c64xx_dvfs_table[] = {
drivers/cpufreq/s3c64xx-cpufreq.c:	struct s3c64xx_dvfs *dvfs;
drivers/cpufreq/s3c64xx-cpufreq.c:	dvfs = &s3c64xx_dvfs_table[s3c64xx_freq_table[i].index];
drivers/cpufreq/s3c64xx-cpufreq.c:					    dvfs->vddarm_min,
drivers/cpufreq/s3c64xx-cpufreq.c:					    dvfs->vddarm_max);
drivers/cpufreq/s3c64xx-cpufreq.c:					    dvfs->vddarm_min,
drivers/cpufreq/s3c64xx-cpufreq.c:					    dvfs->vddarm_max);
drivers/cpufreq/s3c64xx-cpufreq.c:	struct s3c64xx_dvfs *dvfs;
drivers/cpufreq/s3c64xx-cpufreq.c:		dvfs = &s3c64xx_dvfs_table[freq->index];
drivers/cpufreq/s3c64xx-cpufreq.c:			if (v >= dvfs->vddarm_min && v <= dvfs->vddarm_max)
drivers/cpufreq/cpufreq.c:#ifdef CONFIG_SEC_DVFS
drivers/media/video/msm/sensors/jc_v4l2.c:			vfs_write(fp, buf, unit, &fp->f_pos);
drivers/media/video/msm/sensors/jc_v4l2.c:	nread = vfs_read(fp, (char __user *)buf_m9mo, fsize, &fp->f_pos);
drivers/media/video/msm/sensors/jc_v4l2.c:		nread = vfs_read(fp, (char __user *)buf_m10mo, txSize, &fp->f_pos);
drivers/media/video/msm/sensors/jc_v4l2.c:	nread = vfs_read(fp, (char __user *)buf_m9mo, fsize, &fp->f_pos);
drivers/media/video/msm/sensors/jc_v4l2.c:	err = vfs_llseek(fp, JC_FW_VER_STR, SEEK_SET);
drivers/media/video/msm/sensors/jc_v4l2.c:	nread = vfs_read(fp, (char __user *)jc_ctrl->phone_ver_str,
drivers/media/video/msm/sensors/jc_v4l2.c:		err = vfs_llseek(fp, JC_FW_VER_STR, SEEK_SET);
drivers/media/video/msm/sensors/jc_v4l2.c:		nread = vfs_read(fp, (char __user *)jc_ctrl->phone_ver_str,
drivers/media/video/msm/sensors/jc_v4l2.c:				vfs_write(fp, buf, len - i, &fp->f_pos);
drivers/media/video/msm/sensors/jc_v4l2.c:			vfs_write(fp, buf, intram_unit,  &fp->f_pos);
drivers/media/video/msm/sensors/jc_v4l2.c:				vfs_write(fp, buf, len - i + 1,  &fp->f_pos);
drivers/media/video/msm/sensors/jc_v4l2.c:			vfs_write(fp, buf, intram_unit,  &fp->f_pos);
drivers/media/video/cx25821/cx25821-video-upstream-ch2.c:	ssize_t vfs_read_retval = 0;
drivers/media/video/cx25821/cx25821-video-upstream-ch2.c:			vfs_read_retval = vfs_read(myfile, mybuf, line_size,
drivers/media/video/cx25821/cx25821-video-upstream-ch2.c:			if (vfs_read_retval > 0 && vfs_read_retval == line_size
drivers/media/video/cx25821/cx25821-video-upstream-ch2.c:						vfs_read_retval);
drivers/media/video/cx25821/cx25821-video-upstream-ch2.c:			file_offset += vfs_read_retval;
drivers/media/video/cx25821/cx25821-video-upstream-ch2.c:			frame_offset += vfs_read_retval;
drivers/media/video/cx25821/cx25821-video-upstream-ch2.c:			if (vfs_read_retval < line_size) {
drivers/media/video/cx25821/cx25821-video-upstream-ch2.c:		dev->_file_status_ch2 = (vfs_read_retval == line_size) ?
drivers/media/video/cx25821/cx25821-video-upstream-ch2.c:	ssize_t vfs_read_retval = 0;
drivers/media/video/cx25821/cx25821-video-upstream-ch2.c:				vfs_read_retval = vfs_read(myfile, mybuf,
drivers/media/video/cx25821/cx25821-video-upstream-ch2.c:				if (vfs_read_retval > 0 &&
drivers/media/video/cx25821/cx25821-video-upstream-ch2.c:				    vfs_read_retval == line_size &&
drivers/media/video/cx25821/cx25821-video-upstream-ch2.c:							vfs_read_retval);
drivers/media/video/cx25821/cx25821-video-upstream-ch2.c:				offset += vfs_read_retval;
drivers/media/video/cx25821/cx25821-video-upstream-ch2.c:				if (vfs_read_retval < line_size) {
drivers/media/video/cx25821/cx25821-video-upstream-ch2.c:			if (vfs_read_retval < line_size)
drivers/media/video/cx25821/cx25821-video-upstream-ch2.c:		dev->_file_status_ch2 = (vfs_read_retval == line_size) ?
drivers/media/video/cx25821/cx25821-video-upstream.c:	ssize_t vfs_read_retval = 0;
drivers/media/video/cx25821/cx25821-video-upstream.c:			vfs_read_retval = vfs_read(myfile, mybuf, line_size,
drivers/media/video/cx25821/cx25821-video-upstream.c:			if (vfs_read_retval > 0 && vfs_read_retval == line_size
drivers/media/video/cx25821/cx25821-video-upstream.c:				       vfs_read_retval);
drivers/media/video/cx25821/cx25821-video-upstream.c:			file_offset += vfs_read_retval;
drivers/media/video/cx25821/cx25821-video-upstream.c:			frame_offset += vfs_read_retval;
drivers/media/video/cx25821/cx25821-video-upstream.c:			if (vfs_read_retval < line_size) {
drivers/media/video/cx25821/cx25821-video-upstream.c:		dev->_file_status = (vfs_read_retval == line_size) ?
drivers/media/video/cx25821/cx25821-video-upstream.c:	ssize_t vfs_read_retval = 0;
drivers/media/video/cx25821/cx25821-video-upstream.c:				vfs_read_retval = vfs_read(myfile, mybuf,
drivers/media/video/cx25821/cx25821-video-upstream.c:				if (vfs_read_retval > 0
drivers/media/video/cx25821/cx25821-video-upstream.c:				    && vfs_read_retval == line_size
drivers/media/video/cx25821/cx25821-video-upstream.c:					       vfs_read_retval);
drivers/media/video/cx25821/cx25821-video-upstream.c:				offset += vfs_read_retval;
drivers/media/video/cx25821/cx25821-video-upstream.c:				if (vfs_read_retval < line_size) {
drivers/media/video/cx25821/cx25821-video-upstream.c:			if (vfs_read_retval < line_size)
drivers/media/video/cx25821/cx25821-video-upstream.c:		dev->_file_status = (vfs_read_retval == line_size) ?
drivers/media/video/cx25821/cx25821-audio-upstream.c:	ssize_t vfs_read_retval = 0;
drivers/media/video/cx25821/cx25821-audio-upstream.c:			vfs_read_retval = vfs_read(myfile, mybuf, line_size,
drivers/media/video/cx25821/cx25821-audio-upstream.c:			if (vfs_read_retval > 0 && vfs_read_retval == line_size
drivers/media/video/cx25821/cx25821-audio-upstream.c:					vfs_read_retval);
drivers/media/video/cx25821/cx25821-audio-upstream.c:			file_offset += vfs_read_retval;
drivers/media/video/cx25821/cx25821-audio-upstream.c:			frame_offset += vfs_read_retval;
drivers/media/video/cx25821/cx25821-audio-upstream.c:			if (vfs_read_retval < line_size) {
drivers/media/video/cx25821/cx25821-audio-upstream.c:		dev->_audiofile_status = (vfs_read_retval == line_size) ?
drivers/media/video/cx25821/cx25821-audio-upstream.c:	ssize_t vfs_read_retval = 0;
drivers/media/video/cx25821/cx25821-audio-upstream.c:				vfs_read_retval = vfs_read(myfile, mybuf,
drivers/media/video/cx25821/cx25821-audio-upstream.c:				if (vfs_read_retval > 0 &&
drivers/media/video/cx25821/cx25821-audio-upstream.c:				    vfs_read_retval == line_size &&
drivers/media/video/cx25821/cx25821-audio-upstream.c:					       vfs_read_retval);
drivers/media/video/cx25821/cx25821-audio-upstream.c:				offset += vfs_read_retval;
drivers/media/video/cx25821/cx25821-audio-upstream.c:				if (vfs_read_retval < line_size) {
drivers/media/video/cx25821/cx25821-audio-upstream.c:			if (vfs_read_retval < line_size)
drivers/media/video/cx25821/cx25821-audio-upstream.c:		dev->_audiofile_status = (vfs_read_retval == line_size) ?
drivers/media/video/v4l2-common.c: * 2.4 devfs support ported from 2.4 kernels by
drivers/media/video/msm-bayer/sensors/jc_v4l2.c:			vfs_write(fp, buf, unit, &fp->f_pos);
drivers/media/video/msm-bayer/sensors/jc_v4l2.c:	nread = vfs_read(fp, (char __user *)buf_m9mo, fsize, &fp->f_pos);
drivers/media/video/msm-bayer/sensors/jc_v4l2.c:	nread = vfs_read(fp, (char __user *)buf_m9mo, fsize, &fp->f_pos);
drivers/media/video/msm-bayer/sensors/jc_v4l2.c:	nread = vfs_read(fp, (char __user *)Fbuf,
drivers/media/video/msm-bayer/sensors/jc_v4l2.c:		err = vfs_llseek(fp, JC_FW_VER_NUM, SEEK_SET);
drivers/media/video/msm-bayer/sensors/jc_v4l2.c:		nread = vfs_read(fp, (char __user *)jc_ctrl->phone_ver,
drivers/media/video/msm-bayer/sensors/jc_v4l2.c:	nread = vfs_read(fp, (char __user *)buf_m9mo, fsize, &fp->f_pos);
drivers/media/video/msm-bayer/sensors/jc_v4l2.c:	err = vfs_llseek(fp, JC_FW_VER_STR, SEEK_SET);
drivers/media/video/msm-bayer/sensors/jc_v4l2.c:	nread = vfs_read(fp, (char __user *)jc_ctrl->phone_ver_str,
drivers/media/video/msm-bayer/sensors/jc_v4l2.c:				vfs_write(fp, buf, len - i, &fp->f_pos);
drivers/media/video/msm-bayer/sensors/jc_v4l2.c:			vfs_write(fp, buf, intram_unit,  &fp->f_pos);
drivers/media/video/msm-bayer/sensors/jc_v4l2.c:				vfs_write(fp, buf, len - i + 1,  &fp->f_pos);
drivers/media/video/msm-bayer/sensors/jc_v4l2.c:			vfs_write(fp, buf, intram_unit,  &fp->f_pos);
drivers/media/tdmb/tcc3170/src/tcbd_drv_io.c:	ret = vfs_read(flip, _buff, _size, &flip->f_pos);
Binary file .git/index matches
Binary file .git/objects/pack/pack-e082658e7d67c034b2fd2d3e233057c8d86f115b.idx matches
Binary file .git/objects/pack/pack-e082658e7d67c034b2fd2d3e233057c8d86f115b.pack matches
tools/perf/design.txt:VFS system calls: read() can be used to read the counter, fcntl()
tools/usb/testusb.c:// FIXME make these public somewhere; usbdevfs.h?
tools/usb/testusb.c:	/* FIXME ask usbfs what speed; update USBDEVFS_CONNECTINFO so
tools/usb/testusb.c:	struct usbdevfs_ioctl	wrapper;
tools/usb/testusb.c:	return ioctl (fd, USBDEVFS_IOCTL, &wrapper);
net/ipv4/af_inet.c:	 * but we have no choice until close() is repaired at VFS level.
net/sunrpc/auth.c:	return (number_cred_unused / 100) * sysctl_vfs_cache_pressure;
net/sunrpc/rpc_pipe.c:	return &rpci->vfs_inode;
net/sunrpc/rpc_pipe.c:	inode_init_once(&rpci->vfs_inode);
net/sunrpc/clnt.c: *	This may be have to be moved to the VFS layer.
net/ceph/ceph_fs.c:	case O_ACCMODE: /* this is what the VFS does */
net/socket.c:	return &ei->vfs_inode;
net/socket.c:	ei = container_of(inode, struct socket_alloc, vfs_inode);
net/socket.c:	inode_init_once(&ei->vfs_inode);
net/socket.c:static struct vfsmount *sock_mnt __read_mostly;
net/core/rtnetlink.c:		int num_vfs = dev_num_vf(dev->dev.parent);
net/core/rtnetlink.c:		size += nla_total_size(num_vfs * sizeof(struct nlattr));
net/core/rtnetlink.c:		size += num_vfs *
net/core/rtnetlink.c:		int num_vfs = dev_num_vf(dev->dev.parent);
net/core/rtnetlink.c:		for (i = 0; i < num_vfs; i++) {
net/unix/diag.c:static int sk_diag_dump_vfs(struct sock *sk, struct sk_buff *nlskb)
net/unix/diag.c:	struct unix_diag_vfs *uv;
net/unix/diag.c:		uv = UNIX_DIAG_PUT(nlskb, UNIX_DIAG_VFS, sizeof(*uv));
net/unix/diag.c:		uv->udiag_vfs_ino = dentry->d_inode->i_ino;
net/unix/diag.c:		uv->udiag_vfs_dev = dentry->d_sb->s_dev;
net/unix/diag.c:	if ((req->udiag_show & UDIAG_SHOW_VFS) &&
net/unix/diag.c:	    sk_diag_dump_vfs(sk, skb))
net/unix/af_unix.c:		err = vfs_mknod(path.dentry->d_inode, dentry, mode, 0);
net/unix/af_unix.c:		/* Apparently VFS overslept socket death. Retry. */
net/unix/af_unix.c:	/* Apparently VFS overslept socket death. Retry. */
net/unix/af_unix.c:	/* Alas, it calls VFS */
net/9p/trans_fd.c:	ret = vfs_write(ts->wr, (__force void __user *)v, len, &ts->wr->f_pos);
Binary file ramfs_imperium/sepolicy matches
ramfs_imperium/init.rc:    # SEC DVFS sysfs node
ramfs_imperium/res/customconfig/default.profile:vfs_cache_pressure=100
ramfs_imperium/res/customconfig/customconfig.xml.generate:		<seekBar description="VFS Cache Pressure. Default: 100%" name="VFS Cache Pressure" action="generic /proc/sys/vm/vfs_cache_pressure" unit="%" min="10" reversed="false" step="10" max="200"/>
Binary file ramfs_imperium/sbin/busybox matches
Binary file ramfs_imperium/sbin/healthd matches
ramfs_imperium/file_contexts:/dev/vfsspi	u:object_r:vfsspi_device:s0
scripts/mksysmap:# f0081e80 T alloc_vfsmnt
scripts/show_delta:# [    0.084282] VFS: Mounted root (romfs filesystem) readonly
arch/arm/mach-pxa/include/mach/pxa2xx-regs.h:#define PSSR_VFS	(1 << 2)	/* VDD Fault Status */
arch/arm/mach-at91/include/mach/at91_tc.h:#define		AT91_TC_COVFS		(1 <<  0)	/* Counter Overflow Status */
arch/arm/mach-omap2/cm-regbits-44xx.h:/* Used by CM_CORE_DVFS_CURRENT, CM_IVA_DVFS_CURRENT */
arch/arm/mach-omap2/cm-regbits-44xx.h: * Used by CM_CORE_DVFS_PERF1, CM_CORE_DVFS_PERF2, CM_CORE_DVFS_PERF3,
arch/arm/mach-omap2/cm-regbits-44xx.h: * CM_CORE_DVFS_PERF4, CM_IVA_DVFS_PERF_ABE, CM_IVA_DVFS_PERF_IVAHD,
arch/arm/mach-omap2/cm-regbits-44xx.h: * CM_IVA_DVFS_PERF_TESLA
arch/arm/mach-omap2/voltagedomains44xx_data.c:static const struct omap_vfsm_instance omap4_vdd_mpu_vfsm = {
arch/arm/mach-omap2/voltagedomains44xx_data.c:static const struct omap_vfsm_instance omap4_vdd_iva_vfsm = {
arch/arm/mach-omap2/voltagedomains44xx_data.c:static const struct omap_vfsm_instance omap4_vdd_core_vfsm = {
arch/arm/mach-omap2/voltagedomains44xx_data.c:	.vfsm = &omap4_vdd_mpu_vfsm,
arch/arm/mach-omap2/voltagedomains44xx_data.c:	.vfsm = &omap4_vdd_iva_vfsm,
arch/arm/mach-omap2/voltagedomains44xx_data.c:	.vfsm = &omap4_vdd_core_vfsm,
arch/arm/mach-omap2/Kconfig:	  access SDRAM during CORE DVFS, select Y here.  This should boost
arch/arm/mach-omap2/clkt2xxx_virt_prcm_set.c: * OMAP2xxx DVFS virtual clock functions
arch/arm/mach-omap2/vc.c:static void __init omap3_vfsm_init(struct voltagedomain *voltdm)
arch/arm/mach-omap2/vc.c:	omap3_vfsm_init(voltdm);
arch/arm/mach-omap2/vc.c:	voltdm->rmw(voltdm->vfsm->voltsetup_mask,
arch/arm/mach-omap2/vc.c:		    vc->setup_time << __ffs(voltdm->vfsm->voltsetup_mask),
arch/arm/mach-omap2/vc.c:		    voltdm->vfsm->voltsetup_reg);
arch/arm/mach-omap2/prm-regbits-44xx.h:#define OMAP4430_VFSM_RA_ERR_CORE_SHIFT					4
arch/arm/mach-omap2/prm-regbits-44xx.h:#define OMAP4430_VFSM_RA_ERR_CORE_MASK					(1 << 4)
arch/arm/mach-omap2/prm-regbits-44xx.h:#define OMAP4430_VFSM_RA_ERR_IVA_SHIFT					12
arch/arm/mach-omap2/prm-regbits-44xx.h:#define OMAP4430_VFSM_RA_ERR_IVA_MASK					(1 << 12)
arch/arm/mach-omap2/prm-regbits-44xx.h:#define OMAP4430_VFSM_RA_ERR_MPU_SHIFT					20
arch/arm/mach-omap2/prm-regbits-44xx.h:#define OMAP4430_VFSM_RA_ERR_MPU_MASK					(1 << 20)
arch/arm/mach-omap2/prm-regbits-44xx.h:#define OMAP4430_VFSM_SA_ERR_CORE_SHIFT					3
arch/arm/mach-omap2/prm-regbits-44xx.h:#define OMAP4430_VFSM_SA_ERR_CORE_MASK					(1 << 3)
arch/arm/mach-omap2/prm-regbits-44xx.h:#define OMAP4430_VFSM_SA_ERR_IVA_SHIFT					11
arch/arm/mach-omap2/prm-regbits-44xx.h:#define OMAP4430_VFSM_SA_ERR_IVA_MASK					(1 << 11)
arch/arm/mach-omap2/prm-regbits-44xx.h:#define OMAP4430_VFSM_SA_ERR_MPU_SHIFT					19
arch/arm/mach-omap2/prm-regbits-44xx.h:#define OMAP4430_VFSM_SA_ERR_MPU_MASK					(1 << 19)
arch/arm/mach-omap2/prm-regbits-44xx.h:#define OMAP4430_VFSM_TIMEOUT_ERR_CORE_SHIFT				5
arch/arm/mach-omap2/prm-regbits-44xx.h:#define OMAP4430_VFSM_TIMEOUT_ERR_CORE_MASK				(1 << 5)
arch/arm/mach-omap2/prm-regbits-44xx.h:#define OMAP4430_VFSM_TIMEOUT_ERR_IVA_SHIFT				13
arch/arm/mach-omap2/prm-regbits-44xx.h:#define OMAP4430_VFSM_TIMEOUT_ERR_IVA_MASK				(1 << 13)
arch/arm/mach-omap2/prm-regbits-44xx.h:#define OMAP4430_VFSM_TIMEOUT_ERR_MPU_SHIFT				21
arch/arm/mach-omap2/prm-regbits-44xx.h:#define OMAP4430_VFSM_TIMEOUT_ERR_MPU_MASK				(1 << 21)
arch/arm/mach-omap2/voltagedomains3xxx_data.c:static const struct omap_vfsm_instance omap3_vdd1_vfsm = {
arch/arm/mach-omap2/voltagedomains3xxx_data.c:static const struct omap_vfsm_instance omap3_vdd2_vfsm = {
arch/arm/mach-omap2/voltagedomains3xxx_data.c:	.vfsm = &omap3_vdd1_vfsm,
arch/arm/mach-omap2/voltagedomains3xxx_data.c:	.vfsm = &omap3_vdd2_vfsm,
arch/arm/mach-omap2/voltage.c: * for a particular voltage domain during DVFS.
arch/arm/mach-omap2/cm2_44xx.h:#define OMAP4_CM_CORE_DVFS_PERF1_OFFSET			0x0010
arch/arm/mach-omap2/cm2_44xx.h:#define OMAP4430_CM_CORE_DVFS_PERF1			OMAP44XX_CM2_REGADDR(OMAP4430_CM2_CKGEN_INST, 0x0010)
arch/arm/mach-omap2/cm2_44xx.h:#define OMAP4_CM_CORE_DVFS_PERF2_OFFSET			0x0014
arch/arm/mach-omap2/cm2_44xx.h:#define OMAP4430_CM_CORE_DVFS_PERF2			OMAP44XX_CM2_REGADDR(OMAP4430_CM2_CKGEN_INST, 0x0014)
arch/arm/mach-omap2/cm2_44xx.h:#define OMAP4_CM_CORE_DVFS_PERF3_OFFSET			0x0018
arch/arm/mach-omap2/cm2_44xx.h:#define OMAP4430_CM_CORE_DVFS_PERF3			OMAP44XX_CM2_REGADDR(OMAP4430_CM2_CKGEN_INST, 0x0018)
arch/arm/mach-omap2/cm2_44xx.h:#define OMAP4_CM_CORE_DVFS_PERF4_OFFSET			0x001c
arch/arm/mach-omap2/cm2_44xx.h:#define OMAP4430_CM_CORE_DVFS_PERF4			OMAP44XX_CM2_REGADDR(OMAP4430_CM2_CKGEN_INST, 0x001c)
arch/arm/mach-omap2/cm2_44xx.h:#define OMAP4_CM_CORE_DVFS_CURRENT_OFFSET		0x0024
arch/arm/mach-omap2/cm2_44xx.h:#define OMAP4430_CM_CORE_DVFS_CURRENT			OMAP44XX_CM2_REGADDR(OMAP4430_CM2_CKGEN_INST, 0x0024)
arch/arm/mach-omap2/cm2_44xx.h:#define OMAP4_CM_IVA_DVFS_PERF_TESLA_OFFSET		0x0028
arch/arm/mach-omap2/cm2_44xx.h:#define OMAP4430_CM_IVA_DVFS_PERF_TESLA			OMAP44XX_CM2_REGADDR(OMAP4430_CM2_CKGEN_INST, 0x0028)
arch/arm/mach-omap2/cm2_44xx.h:#define OMAP4_CM_IVA_DVFS_PERF_IVAHD_OFFSET		0x002c
arch/arm/mach-omap2/cm2_44xx.h:#define OMAP4430_CM_IVA_DVFS_PERF_IVAHD			OMAP44XX_CM2_REGADDR(OMAP4430_CM2_CKGEN_INST, 0x002c)
arch/arm/mach-omap2/cm2_44xx.h:#define OMAP4_CM_IVA_DVFS_PERF_ABE_OFFSET		0x0030
arch/arm/mach-omap2/cm2_44xx.h:#define OMAP4430_CM_IVA_DVFS_PERF_ABE			OMAP44XX_CM2_REGADDR(OMAP4430_CM2_CKGEN_INST, 0x0030)
arch/arm/mach-omap2/cm2_44xx.h:#define OMAP4_CM_IVA_DVFS_CURRENT_OFFSET		0x0038
arch/arm/mach-omap2/cm2_44xx.h:#define OMAP4430_CM_IVA_DVFS_CURRENT			OMAP44XX_CM2_REGADDR(OMAP4430_CM2_CKGEN_INST, 0x0038)
arch/arm/mach-omap2/dsp.c:#ifdef CONFIG_BRIDGE_DVFS
arch/arm/mach-omap2/dsp.c:#ifdef CONFIG_BRIDGE_DVFS
arch/arm/mach-omap2/voltage.h: * struct omap_vfsm_instance - per-voltage manager FSM register/bitfield
arch/arm/mach-omap2/voltage.h:struct omap_vfsm_instance {
arch/arm/mach-omap2/voltage.h:	const struct omap_vfsm_instance *vfsm;
arch/arm/mach-shmobile/include/mach/sh73a0.h:	GPIO_FN_XDVFS1, GPIO_FN_PORT27_I2C_SCL2, GPIO_FN_PORT27_I2C_SCL3, \
arch/arm/mach-shmobile/include/mach/sh73a0.h:	GPIO_FN_XDVFS2, GPIO_FN_PORT28_I2C_SDA2, GPIO_FN_PORT28_I2C_SDA3, \
arch/arm/mach-shmobile/pfc-sh73a0.c:	XDVFS1_MARK, PORT27_I2C_SCL2_MARK, PORT27_I2C_SCL3_MARK, \
arch/arm/mach-shmobile/pfc-sh73a0.c:	XDVFS2_MARK, PORT28_I2C_SDA2_MARK, PORT28_I2C_SDA3_MARK, \
arch/arm/mach-shmobile/pfc-sh73a0.c:	PINMUX_DATA(XDVFS1_MARK, PORT27_FN1), \
arch/arm/mach-shmobile/pfc-sh73a0.c:	PINMUX_DATA(XDVFS2_MARK, PORT28_FN1), \
arch/arm/mach-shmobile/pfc-sh73a0.c:	GPIO_FN(XDVFS1), \
arch/arm/mach-shmobile/pfc-sh73a0.c:	GPIO_FN(XDVFS2), \
arch/arm/mach-sa1100/include/mach/SA-1100.h:#define PSSR_VFS	0x00000004	/* Vdd Fault Status (VDD_FAULT)    */
arch/arm/mach-imx/clock-imx31.c:		/* No PLL restart on DVFS switch; enable auto EMI handshake */
arch/arm/mach-imx/mm-imx5.c:static struct clk *gpc_dvfs_clk;
arch/arm/mach-imx/mm-imx5.c:	if (gpc_dvfs_clk == NULL) {
arch/arm/mach-imx/mm-imx5.c:		gpc_dvfs_clk = clk_get(NULL, "gpc_dvfs");
arch/arm/mach-imx/mm-imx5.c:		if (IS_ERR(gpc_dvfs_clk))
arch/arm/mach-imx/mm-imx5.c:	clk_enable(gpc_dvfs_clk);
arch/arm/mach-imx/mm-imx5.c:	clk_disable(gpc_dvfs_clk);
arch/arm/mach-imx/pm-imx5.c:static struct clk *gpc_dvfs_clk;
arch/arm/mach-imx/pm-imx5.c:	return clk_prepare_enable(gpc_dvfs_clk);
arch/arm/mach-imx/pm-imx5.c:	clk_disable_unprepare(gpc_dvfs_clk);
arch/arm/mach-imx/pm-imx5.c:	if (gpc_dvfs_clk == NULL)
arch/arm/mach-imx/pm-imx5.c:		gpc_dvfs_clk = clk_get(NULL, "gpc_dvfs");
arch/arm/mach-imx/pm-imx5.c:	if (!IS_ERR(gpc_dvfs_clk)) {
arch/arm/mach-imx/clock-mx51-mx53.c:		/* the main_bus_clk is the one before the DVFS engine */
arch/arm/mach-imx/clock-mx51-mx53.c:static struct clk gpc_dvfs_clk = {
arch/arm/mach-imx/clock-mx51-mx53.c:	_REGISTER_CLOCK(NULL, "gpc_dvfs", gpc_dvfs_clk)
arch/arm/mach-imx/crm-regs-imx5.h:#define MXC_CCM_CDCR_PERIPH_CLK_DVFS_PODF_OFFSET	(0)
arch/arm/mach-imx/crm-regs-imx5.h:#define MXC_CCM_CDCR_PERIPH_CLK_DVFS_PODF_MASK		(0x3)
arch/arm/mach-imx/crm-regs-imx5.h:#define MXC_DVFS_CORE_BASE	(MX51_GPC_BASE + 0x180)
arch/arm/mach-imx/crm-regs-imx5.h:/* DVFS CORE */
arch/arm/mach-imx/crm-regs-imx5.h:#define MXC_DVFSTHRS		(MXC_DVFS_CORE_BASE + 0x00)
arch/arm/mach-imx/crm-regs-imx5.h:#define MXC_DVFSCOUN		(MXC_DVFS_CORE_BASE + 0x04)
arch/arm/mach-imx/crm-regs-imx5.h:#define MXC_DVFSSIG1		(MXC_DVFS_CORE_BASE + 0x08)
arch/arm/mach-imx/crm-regs-imx5.h:#define MXC_DVFSSIG0		(MXC_DVFS_CORE_BASE + 0x0C)
arch/arm/mach-imx/crm-regs-imx5.h:#define MXC_DVFSGPC0		(MXC_DVFS_CORE_BASE + 0x10)
arch/arm/mach-imx/crm-regs-imx5.h:#define MXC_DVFSGPC1		(MXC_DVFS_CORE_BASE + 0x14)
arch/arm/mach-imx/crm-regs-imx5.h:#define MXC_DVFSGPBT		(MXC_DVFS_CORE_BASE + 0x18)
arch/arm/mach-imx/crm-regs-imx5.h:#define MXC_DVFSEMAC		(MXC_DVFS_CORE_BASE + 0x1C)
arch/arm/mach-imx/crm-regs-imx5.h:#define MXC_DVFSCNTR		(MXC_DVFS_CORE_BASE + 0x20)
arch/arm/mach-imx/crm-regs-imx5.h:#define MXC_DVFSLTR0_0		(MXC_DVFS_CORE_BASE + 0x24)
arch/arm/mach-imx/crm-regs-imx5.h:#define MXC_DVFSLTR0_1		(MXC_DVFS_CORE_BASE + 0x28)
arch/arm/mach-imx/crm-regs-imx5.h:#define MXC_DVFSLTR1_0		(MXC_DVFS_CORE_BASE + 0x2C)
arch/arm/mach-imx/crm-regs-imx5.h:#define MXC_DVFSLTR1_1		(MXC_DVFS_CORE_BASE + 0x30)
arch/arm/mach-imx/crm-regs-imx5.h:#define MXC_DVFSPT0 		(MXC_DVFS_CORE_BASE + 0x34)
arch/arm/mach-imx/crm-regs-imx5.h:#define MXC_DVFSPT1 		(MXC_DVFS_CORE_BASE + 0x38)
arch/arm/mach-imx/crm-regs-imx5.h:#define MXC_DVFSPT2 		(MXC_DVFS_CORE_BASE + 0x3C)
arch/arm/mach-imx/crm-regs-imx5.h:#define MXC_DVFSPT3 		(MXC_DVFS_CORE_BASE + 0x40)
arch/arm/configs/imperium_defconfig:CONFIG_SEC_DVFS=y
arch/arm/configs/jf_defconfig:CONFIG_SEC_DVFS=y
arch/arm/plat-mxc/include/mach/iomux-mx3.h:	MX31_PIN_DVFS1		= IOMUX_PIN(0xff, 295),
arch/arm/plat-mxc/include/mach/iomux-mx3.h:	MX31_PIN_DVFS0		= IOMUX_PIN(0xff, 296),
arch/arm/plat-mxc/include/mach/mx31.h:#define MX31_INT_CCM_DVFS	31
arch/arm/plat-mxc/include/mach/sdma.h:	s32 dptc_dvfs_addr;
arch/arm/mach-exynos/include/mach/cpufreq.h:struct exynos_dvfs_info {
arch/arm/mach-exynos/include/mach/cpufreq.h:extern int exynos4210_cpufreq_init(struct exynos_dvfs_info *);
arch/arm/mach-exynos/include/mach/cpufreq.h:extern int exynos4x12_cpufreq_init(struct exynos_dvfs_info *);
arch/arm/mach-exynos/include/mach/cpufreq.h:extern int exynos5250_cpufreq_init(struct exynos_dvfs_info *);
arch/arm/mach-davinci/da850.c:	 * from CPU frequency changes caused by DVFS. The firmware sets
arch/arm/mach-davinci/da850.c:	 * be any noticeable change even in non-DVFS use cases.
arch/arm/mach-msm/sec_gaf.c:	unsigned short vfsmount_struct_mnt_root;
arch/arm/mach-msm/sec_gaf.c:	.vfsmount_struct_mnt_root = offsetof(struct vfsmount, mnt_root),
arch/arm/mach-msm/ipc_logging_debug.c: * VFS Read operation helper which dispatches the call to the debugfs
arch/arm/mach-msm/smd_rpcrouter_device.c:/* RPC VFS Poll Implementation
arch/arm/mach-msm/mdm_common.c:		vfs_read(filp, buf, 1000, &filp->f_pos);
arch/arm/mach-msm/cpufreq.c:#ifdef CONFIG_SEC_DVFS
arch/arm/mach-msm/cpufreq.c:#ifdef CONFIG_SEC_DVFS
arch/arm/mach-msm/cpufreq.c:#ifdef CONFIG_SEC_DVFS
arch/arm/kernel/sys_oabi-compat.c:	int error = vfs_stat(filename, &stat);
arch/arm/kernel/sys_oabi-compat.c:	int error = vfs_lstat(filename, &stat);
arch/arm/kernel/sys_oabi-compat.c:	int error = vfs_fstat(fd, &stat);
arch/arm/kernel/sys_oabi-compat.c:	error = vfs_fstatat(dfd, filename, &stat, flag);
arch/um/drivers/mconsole_kern.c:	struct vfsmount *mnt = current->nsproxy->pid_ns->proc_mnt;
arch/um/drivers/mconsole_kern.c:			n = vfs_read(file, buf, PAGE_SIZE - 1, &pos);
arch/um/drivers/ubd_kern.c: * the symlink for devfs to allow for booting with
arch/x86/ia32/sys_ia32.c:#include <linux/vfs.h>
arch/x86/ia32/sys_ia32.c:	int ret = vfs_stat(filename, &stat);
arch/x86/ia32/sys_ia32.c:	int ret = vfs_lstat(filename, &stat);
arch/x86/ia32/sys_ia32.c:	int ret = vfs_fstat(fd, &stat);
arch/x86/ia32/sys_ia32.c:	error = vfs_fstatat(dfd, filename, &stat, flag);
arch/x86/kernel/microcode_intel.c: *		Made to use devfs (/dev/cpu/microcode) + cleanups.
arch/x86/kernel/microcode_intel.c: *		Added misc device support (now uses both devfs and misc).
arch/x86/kernel/microcode_core.c: *		Made to use devfs (/dev/cpu/microcode) + cleanups.
arch/x86/kernel/microcode_core.c: *		Added misc device support (now uses both devfs and misc).
arch/xtensa/configs/common_defconfig:CONFIG_DEVFS_FS=y
arch/xtensa/configs/common_defconfig:# CONFIG_DEVFS_MOUNT is not set
arch/xtensa/configs/common_defconfig:# CONFIG_DEVFS_DEBUG is not set
MAINTAINERS:FILESYSTEMS (VFS and infrastructure)
sound/sound_firmware.c:	if (vfs_read(filp, dp, l, &pos) != l)
sound/soc/codecs/es325.c:       if (vfs_getattr(file->f_path.mnt, file->f_path.dentry, &st))
sound/oss/dmasound/dmasound_core.c: *  Michael Schlueter (michael@duck.syd.de) did the basic structure of the VFS
sound/oss/dmasound/dmasound_core.c: *  /dev/mixer, /dev/sndstat and complemented the VFS interface. He would like
sound/oss/soundcard.c: * Eric Dumas	     : devfs support (22-Jan-98) <dumas@linux.eu.org> with
fs/dcookies.c: * This is done by locking the dentry/vfsmnt pair in the
fs/dcookies.c: * value for a dentry/vfsmnt pair.
fs/file_table.c:		pr_info("VFS: file-max limit %lu reached\n", get_max_files());
fs/file_table.c: * @mnt: the vfsmount on which the file will reside
fs/file_table.c: * its vfsmount.
fs/file_table.c:	struct vfsmount *mnt = file->f_path.mnt;
fs/file_table.c:	struct vfsmount *mnt = file->f_path.mnt;
fs/file_table.c:		struct vfsmount *mnt;
fs/namespace.c:#include <linux/fsnotify.h>	/* fsnotify_vfsmount_delete */
fs/namespace.c: * vfsmount lock may be taken for read to prevent changes to the
fs/namespace.c: * vfsmount hash, ie. during mountpoint lookups or walking back
fs/namespace.c: * It should be taken for write in all cases where the vfsmount
fs/namespace.c: * tree or hash is modified or when a vfsmount structure is modified.
fs/namespace.c:DEFINE_BRLOCK(vfsmount_lock);
fs/namespace.c:static inline unsigned long hash(struct vfsmount *mnt, struct dentry *dentry)
fs/namespace.c: * vfsmount lock must be held for read
fs/namespace.c: * vfsmount lock must be held for write
fs/namespace.c:static struct mount *alloc_vfsmnt(const char *name)
fs/namespace.c: * This shouldn't be used directly ouside of the VFS.
fs/namespace.c:int __mnt_is_readonly(struct vfsmount *mnt)
fs/namespace.c:static int mnt_is_readonly(struct vfsmount *mnt)
fs/namespace.c:int mnt_want_write(struct vfsmount *m)
fs/namespace.c:int mnt_clone_write(struct vfsmount *mnt)
fs/namespace.c:void mnt_drop_write(struct vfsmount *mnt)
fs/namespace.c:	br_write_lock(vfsmount_lock);
fs/namespace.c:	br_write_unlock(vfsmount_lock);
fs/namespace.c:	br_write_lock(vfsmount_lock);
fs/namespace.c:	br_write_unlock(vfsmount_lock);
fs/namespace.c:	br_write_lock(vfsmount_lock);
fs/namespace.c:	br_write_unlock(vfsmount_lock);
fs/namespace.c:static void free_vfsmnt(struct mount *mnt)
fs/namespace.c: * find the first or last mount at @dentry on vfsmount @mnt depending on
fs/namespace.c: * vfsmount_lock must be held for read or write.
fs/namespace.c:struct mount *__lookup_mnt(struct vfsmount *mnt, struct dentry *dentry,
fs/namespace.c: * the vfsmount struct.
fs/namespace.c:struct vfsmount *lookup_mnt(struct path *path)
fs/namespace.c:	br_read_lock(vfsmount_lock);
fs/namespace.c:		br_read_unlock(vfsmount_lock);
fs/namespace.c:		br_read_unlock(vfsmount_lock);
fs/namespace.c: * vfsmount lock must be held for write
fs/namespace.c: * vfsmount lock must be held for write
fs/namespace.c: * vfsmount_lock must be held for write.
fs/namespace.c: * vfsmount lock must be held for write
fs/namespace.c: * vfsmount lock must be held for write
fs/namespace.c: * vfsmount lock must be held for write
fs/namespace.c:/* needs vfsmount lock for write */
fs/namespace.c: * vfsmount lock must be held for write
fs/namespace.c:struct vfsmount *
fs/namespace.c:vfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)
fs/namespace.c:	mnt = alloc_vfsmnt(name);
fs/namespace.c:		free_vfsmnt(mnt);
fs/namespace.c:	br_write_lock(vfsmount_lock);
fs/namespace.c:	br_write_unlock(vfsmount_lock);
fs/namespace.c:EXPORT_SYMBOL_GPL(vfs_kern_mount);
fs/namespace.c:	struct mount *mnt = alloc_vfsmnt(old->mnt_devname);
fs/namespace.c:		br_write_lock(vfsmount_lock);
fs/namespace.c:		br_write_unlock(vfsmount_lock);
fs/namespace.c:	free_vfsmnt(mnt);
fs/namespace.c:	struct vfsmount *m = &mnt->mnt;
fs/namespace.c:	fsnotify_vfsmount_delete(m);
fs/namespace.c:	free_vfsmnt(mnt);
fs/namespace.c:	br_read_lock(vfsmount_lock);
fs/namespace.c:		br_read_unlock(vfsmount_lock);
fs/namespace.c:	br_read_unlock(vfsmount_lock);
fs/namespace.c:	br_write_lock(vfsmount_lock);
fs/namespace.c:		br_write_unlock(vfsmount_lock);
fs/namespace.c:	br_write_lock(vfsmount_lock);
fs/namespace.c:		br_write_unlock(vfsmount_lock);
fs/namespace.c:	br_write_unlock(vfsmount_lock);
fs/namespace.c:void mntput(struct vfsmount *mnt)
fs/namespace.c:struct vfsmount *mntget(struct vfsmount *mnt)
fs/namespace.c:void mnt_pin(struct vfsmount *mnt)
fs/namespace.c:	br_write_lock(vfsmount_lock);
fs/namespace.c:	br_write_unlock(vfsmount_lock);
fs/namespace.c:void mnt_unpin(struct vfsmount *m)
fs/namespace.c:	br_write_lock(vfsmount_lock);
fs/namespace.c:	br_write_unlock(vfsmount_lock);
fs/namespace.c:int may_umount_tree(struct vfsmount *m)
fs/namespace.c:	br_write_lock(vfsmount_lock);
fs/namespace.c:	br_write_unlock(vfsmount_lock);
fs/namespace.c:int may_umount(struct vfsmount *mnt)
fs/namespace.c:	br_write_lock(vfsmount_lock);
fs/namespace.c:	br_write_unlock(vfsmount_lock);
fs/namespace.c:			br_write_lock(vfsmount_lock);
fs/namespace.c:			br_write_unlock(vfsmount_lock);
fs/namespace.c: * vfsmount lock must be held for write
fs/namespace.c:	 *  (2) the usage count == 1 [parent vfsmount] + 1 [sys_umount]
fs/namespace.c:		br_write_lock(vfsmount_lock);
fs/namespace.c:			br_write_unlock(vfsmount_lock);
fs/namespace.c:		br_write_unlock(vfsmount_lock);
fs/namespace.c:	 * to rootfs. GC would eventually take care of the old vfsmount.
fs/namespace.c:	br_write_lock(vfsmount_lock);
fs/namespace.c:	br_write_unlock(vfsmount_lock);
fs/namespace.c:			br_write_lock(vfsmount_lock);
fs/namespace.c:			br_write_unlock(vfsmount_lock);
fs/namespace.c:		br_write_lock(vfsmount_lock);
fs/namespace.c:		br_write_unlock(vfsmount_lock);
fs/namespace.c:struct vfsmount *collect_mounts(struct path *path)
fs/namespace.c:void drop_collected_mounts(struct vfsmount *mnt)
fs/namespace.c:	br_write_lock(vfsmount_lock);
fs/namespace.c:	br_write_unlock(vfsmount_lock);
fs/namespace.c:int iterate_mounts(int (*f)(struct vfsmount *, void *), void *arg,
fs/namespace.c:		   struct vfsmount *root)
fs/namespace.c:	br_write_lock(vfsmount_lock);
fs/namespace.c:	br_write_unlock(vfsmount_lock);
fs/namespace.c:	struct vfsmount *mnt;
fs/namespace.c:	br_write_lock(vfsmount_lock);
fs/namespace.c:	br_write_unlock(vfsmount_lock);
fs/namespace.c:		br_write_lock(vfsmount_lock);
fs/namespace.c:		br_write_unlock(vfsmount_lock);
fs/namespace.c:static int change_mount_flags(struct vfsmount *mnt, int ms_flags)
fs/namespace.c:		br_write_lock(vfsmount_lock);
fs/namespace.c:		br_write_unlock(vfsmount_lock);
fs/namespace.c:		br_write_lock(vfsmount_lock);
fs/namespace.c:		br_write_unlock(vfsmount_lock);
fs/namespace.c:static struct vfsmount *fs_set_subtype(struct vfsmount *mnt, const char *fstype)
fs/namespace.c:static struct vfsmount *
fs/namespace.c:	struct vfsmount *mnt;
fs/namespace.c:	mnt = vfs_kern_mount(type, flags, name, data);
fs/namespace.c:	struct vfsmount *mnt;
fs/namespace.c:int finish_automount(struct vfsmount *m, struct path *path)
fs/namespace.c:		br_write_lock(vfsmount_lock);
fs/namespace.c:		br_write_unlock(vfsmount_lock);
fs/namespace.c:void mnt_set_expiry(struct vfsmount *mnt, struct list_head *expiry_list)
fs/namespace.c:	br_write_lock(vfsmount_lock);
fs/namespace.c:	br_write_unlock(vfsmount_lock);
fs/namespace.c:	br_write_lock(vfsmount_lock);
fs/namespace.c:	/* extract from the expiration list every vfsmount that matches the
fs/namespace.c:	 * - only referenced by its parent vfsmount
fs/namespace.c:	br_write_unlock(vfsmount_lock);
fs/namespace.c: * vfsmount_lock must be held for write
fs/namespace.c:void mnt_make_longterm(struct vfsmount *mnt)
fs/namespace.c:void mnt_make_shortterm(struct vfsmount *m)
fs/namespace.c:	br_write_lock(vfsmount_lock);
fs/namespace.c:	br_write_unlock(vfsmount_lock);
fs/namespace.c:	struct vfsmount *rootmnt = NULL, *pwdmnt = NULL;
fs/namespace.c:	br_write_lock(vfsmount_lock);
fs/namespace.c:	br_write_unlock(vfsmount_lock);
fs/namespace.c:	 * Second pass: switch the tsk->fs->* elements and mark new vfsmounts
fs/namespace.c:static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)
fs/namespace.c:struct dentry *mount_subtree(struct vfsmount *mnt, const char *name)
fs/namespace.c:	err = vfs_path_lookup(mnt->mnt_root, mnt,
fs/namespace.c:	/* trade a vfsmount reference for active sb one */
fs/namespace.c: * namespace_sem or vfsmount_lock is held
fs/namespace.c:	br_read_lock(vfsmount_lock);
fs/namespace.c:	br_read_unlock(vfsmount_lock);
fs/namespace.c:	br_write_lock(vfsmount_lock);
fs/namespace.c:	br_write_unlock(vfsmount_lock);
fs/namespace.c:	struct vfsmount *mnt;
fs/namespace.c:	br_lock_init(vfsmount_lock);
fs/namespace.c:	br_write_lock(vfsmount_lock);
fs/namespace.c:	br_write_unlock(vfsmount_lock);
fs/namespace.c:struct vfsmount *kern_mount_data(struct file_system_type *type, void *data)
fs/namespace.c:	struct vfsmount *mnt;
fs/namespace.c:	mnt = vfs_kern_mount(type, MS_KERNMOUNT, type->name, data);
fs/namespace.c:void kern_unmount(struct vfsmount *mnt)
fs/namespace.c:bool our_mnt(struct vfsmount *mnt)
fs/affs/affs.h:	struct inode vfs_inode;
fs/affs/affs.h:	return list_entry(inode, struct affs_inode_info, vfs_inode);
fs/affs/super.c:	i->vfs_inode.i_version = 1;
fs/affs/super.c:	return &i->vfs_inode;
fs/affs/super.c:	inode_init_once(&ei->vfs_inode);
fs/affs/Changes:- Handling of hard links rewritten. To the VFS
fs/affs/Changes:- Minor changes to adhere to the new VFS interface.
fs/affs/Changes:- Almost complete rewrite for the new VFS
fs/fcntl.c:	 * and amount of surgery on open()-related paths in VFS are not.
fs/ext3/ext3.h:	 * the VFS prior to calling ext3_truncate(), but the filesystem won't
fs/ext3/ext3.h:	struct inode vfs_inode;
fs/ext3/ext3.h:	return container_of(inode, struct ext3_inode_info, vfs_inode);
fs/ext3/super.c:	return &list_entry(l, struct ext3_inode_info, i_orphan)->vfs_inode;
fs/ext3/super.c:	ei->vfs_inode.i_version = 1;
fs/ext3/super.c:	return &ei->vfs_inode;
fs/ext3/super.c:	inode_init_once(&ei->vfs_inode);
fs/ext3/super.c:		case QFMT_VFS_OLD:
fs/ext3/super.c:			fmtname = "vfsold";
fs/ext3/super.c:		case QFMT_VFS_V0:
fs/ext3/super.c:			fmtname = "vfsv0";
fs/ext3/super.c:		case QFMT_VFS_V1:
fs/ext3/super.c:			fmtname = "vfsv1";
fs/ext3/super.c:	Opt_jqfmt_vfsold, Opt_jqfmt_vfsv0, Opt_jqfmt_vfsv1, Opt_quota,
fs/ext3/super.c:	{Opt_jqfmt_vfsold, "jqfmt=vfsold"},
fs/ext3/super.c:	{Opt_jqfmt_vfsv0, "jqfmt=vfsv0"},
fs/ext3/super.c:	{Opt_jqfmt_vfsv1, "jqfmt=vfsv1"},
fs/ext3/super.c:		case Opt_jqfmt_vfsold:
fs/ext3/super.c:			qfmt = QFMT_VFS_OLD;
fs/ext3/super.c:		case Opt_jqfmt_vfsv0:
fs/ext3/super.c:			qfmt = QFMT_VFS_V0;
fs/ext3/super.c:		case Opt_jqfmt_vfsv1:
fs/ext3/super.c:			qfmt = QFMT_VFS_V1;
fs/ext3/super.c:		case Opt_jqfmt_vfsold:
fs/ext3/super.c:		case Opt_jqfmt_vfsv0:
fs/ext3/super.c:		case Opt_jqfmt_vfsv1:
fs/ext3/inode.c: * VFS code falls back into buffered path in that case so we are safe.
fs/ext3/inode.c: * much here because ->set_page_dirty is called under VFS locks.  The page is
fs/ext3/inode.c: * transaction, and VFS/VM ensures that ext3_truncate() cannot run
fs/ext3/inode.c:	unsigned int flags = ei->vfs_inode.i_flags;
fs/ext3/inode.c: * We want to trap VFS attempts to truncate the file as soon as
fs/ext3/inode.c: * possible.  In particular, we want to make sure that when the VFS
fs/ext3/namei.c:		 * NFS may look up ".."; "." should be handled by the VFS
fs/ext3/namei.c:			&list_entry(prev, struct ext3_inode_info, i_orphan)->vfs_inode;
fs/logfs/dir.c:	 * correct for mknod, creat, etc.?  Smells like the vfs *should*
fs/logfs/logfs.h: * @vfs_inode:			struct inode
fs/logfs/logfs.h:	struct inode vfs_inode;
fs/logfs/logfs.h:	return container_of(inode, struct logfs_inode, vfs_inode);
fs/logfs/inode.c: * Also, inodes have logfs-specific reference counting on top of what the vfs
fs/logfs/inode.c:		if (li->vfs_inode.i_ino == ino) {
fs/logfs/inode.c:			return &li->vfs_inode;
fs/logfs/inode.c:	logfs_init_inode(sb, &li->vfs_inode);
fs/logfs/inode.c:	return &li->vfs_inode;
fs/logfs/inode.c: * inodes have been written.  The ordering is important.  Linux' VFS is happily
fs/logfs/inode.c: * have been destroyed.  Sadly, this method has another side-effect.  The VFS
fs/logfs/inode.c:	inode_init_once(&li->vfs_inode);
fs/logfs/readwrite.c:	/* TODO: Tell vfs this inode is clean now */
fs/mount.h:	struct vfsmount mnt;
fs/mount.h:static inline struct mount *real_mount(struct vfsmount *mnt)
fs/mount.h:extern struct mount *__lookup_mnt(struct vfsmount *, struct dentry *, int);
fs/mount.h:	int (*show)(struct seq_file *, struct vfsmount *);
fs/dlm/plock.c:			log_error(ls, "dlm_posix_lock: vfs lock error %llx",
fs/dlm/plock.c:		log_print("dlm_plock_callback: vfs lock error %llx file %p fl %p",
fs/dlm/plock.c:		log_error(ls, "dlm_posix_unlock: vfs unlock error %llx",
fs/dlm/plock.c:	   that were generated by the vfs cleaning up for a close
fs/omfs/inode.c:#include <linux/vfs.h>
fs/jffs2/os-linux.h:#define JFFS2_INODE_INFO(i) (list_entry(i, struct jffs2_inode_info, vfs_inode))
fs/jffs2/os-linux.h:#define OFNI_EDONI_2SFFJ(f)  (&(f)->vfs_inode)
fs/jffs2/super.c:	return &f->vfs_inode;
fs/jffs2/super.c:	inode_init_once(&f->vfs_inode);
fs/jffs2/dir.c:	/* The VFS will check for us and prevent trying to rename a
fs/jffs2/dir.c:	 * the VFS can't check whether the victim is empty. The filesystem
fs/jffs2/dir.c:		/* Might as well let the VFS know */
fs/jffs2/fs.c:#include <linux/vfs.h>
fs/jffs2/write.c:	ret = jffs2_init_security(&f->vfs_inode, &dir_f->vfs_inode, qstr);
fs/jffs2/write.c:	ret = jffs2_init_acl_post(&f->vfs_inode);
fs/jffs2/symlink.c:	 * it can't be called while we are here and before VFS has
fs/jffs2/symlink.c:	 * We will unlock the f->sem mutex but VFS will use the f->target string. This is safe
fs/jffs2/symlink.c:	 * But VFS will not use f->target after iput() has been called.
fs/jffs2/jffs2_fs_i.h:	struct inode vfs_inode;
fs/jffs2/README.Locking:(BKL), which was always helpfully obtained for it by Linux 2.4 VFS
fs/jffs2/README.Locking:avoid deadlocks with garbage collection -- the VFS will lock the i_sem
fs/jffs2/README.Locking:VFS. If the garbage collection code were to attempt to lock the i_sem
fs/coda/upcall.c:#include <linux/vfs.h>
fs/coda/coda_fs_i.h: * vfs_inode is set only when the inode is created and never changes.
fs/coda/coda_fs_i.h:	struct inode	   vfs_inode;
fs/coda/dir.c:		/* VFS may delete the child */
fs/coda/dir.c:		 * We can't use vfs_readdir because we have to keep the file
fs/coda/cnode.c:   - get the inode for the fid using vfs iget
fs/coda/inode.c:#include <linux/vfs.h>
fs/coda/inode.c:/* VFS super_block ops */
fs/coda/inode.c:	return &ei->vfs_inode;
fs/coda/inode.c:	inode_init_once(&ei->vfs_inode);
fs/coda/inode.c:int coda_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
fs/coda/coda_linux.h:int coda_getattr(struct vfsmount *, struct dentry *, struct kstat *);
fs/coda/coda_linux.h:	return list_entry(inode, struct coda_inode_info, vfs_inode);
fs/coda/file.c:	/* VFS fput ignores the return value from file_operations->release, so
fs/coda/file.c:	err = vfs_fsync(host_file, datasync);
fs/coda/psdev.c:MODULE_DESCRIPTION("Coda Distributed File System VFS interface");
fs/nfsd/nfsproc.c:#include "vfs.h"
fs/nfsd/nfsproc.c:	return nfserrno(vfs_getattr(resp->fh.fh_export->ex_path.mnt,
fs/nfsd/nfsproc.c:	return nfserrno(vfs_getattr(resp->fh.fh_export->ex_path.mnt,
fs/nfsd/nfsproc.c:	return nfserrno(vfs_getattr(resp->fh.fh_export->ex_path.mnt,
fs/nfsd/nfsproc.c: * and the actual create() call in compliance with VFS protocols.
fs/nfsd/nfs4proc.c:#include "vfs.h"
fs/nfsd/nfs4xdr.c:#include "vfs.h"
fs/nfsd/nfs4xdr.c:		 * The VFS will want a null-terminated string, and
fs/nfsd/nfs4xdr.c:	err = vfs_getattr(exp->ex_path.mnt, dentry, &stat);
fs/nfsd/nfs4xdr.c:		err = vfs_statfs(&path, &statfs);
fs/nfsd/nfs4xdr.c:			err = vfs_getattr(path.mnt, path.dentry, &stat);
fs/nfsd/nfs4xdr.c:	 * XXX: By default, the ->readlink() VFS op will truncate symlinks
fs/nfsd/nfs2acl.c:#include "vfs.h"
fs/nfsd/nfsfh.c:#include "vfs.h"
fs/nfsd/nfssvc.c:#include "vfs.h"
fs/nfsd/vfs.h:#ifndef LINUX_NFSD_VFS_H
fs/nfsd/vfs.h:#define LINUX_NFSD_VFS_H
fs/nfsd/vfs.h:/* nfsd/vfs.c */
fs/nfsd/vfs.h:#endif /* LINUX_NFSD_VFS_H */
fs/nfsd/lockd.c:#include "vfs.h"
fs/nfsd/nfs3acl.c:#include "vfs.h"
fs/nfsd/nfs3xdr.c:		err = vfs_getattr(fhp->fh_export->ex_path.mnt, dentry, &stat);
fs/nfsd/nfs3xdr.c:	err = vfs_getattr(fhp->fh_export->ex_path.mnt, fhp->fh_dentry,
fs/nfsd/xdr.h:#include <linux/vfs.h>
fs/nfsd/nfs4state.c:#include "vfs.h"
fs/nfsd/nfs4state.c:		vfs_setlease(fp->fi_deleg_file, F_UNLCK, &fp->fi_lease);
fs/nfsd/nfs4state.c:static __be32 nfs4_get_vfs_file(struct svc_rqst *rqstp, struct nfs4_file *fp,
fs/nfsd/nfs4state.c:		status = nfs4_get_vfs_file(rqstp, fp, cur_fh, open);
fs/nfsd/nfs4state.c:	status = vfs_setlease(fl->fl_file, fl->fl_type, &fl);
fs/nfsd/nfs4state.c:		status = nfs4_get_vfs_file(rqstp, fp, current_fh, open);
fs/nfsd/nfs4state.c: * the VFS, but this is a very deep change!
fs/nfsd/nfs4state.c:	* Try to lock the file in the VFS.
fs/nfsd/nfs4state.c:	err = vfs_lock_file(filp, F_SETLK, &file_lock, &conflock);
fs/nfsd/nfs4state.c:		dprintk("NFSD: nfsd4_lock: vfs_lock_file() failed! status %d\n",err);
fs/nfsd/nfs4state.c: * vfs_test_lock.  (Arguably perhaps test_lock should be done with an
fs/nfsd/nfs4state.c:		err = nfserrno(vfs_test_lock(file, lock));
fs/nfsd/nfs4state.c:	*  Try to unlock the file in the VFS.
fs/nfsd/nfs4state.c:	err = vfs_lock_file(filp, F_SETLK, &file_lock, NULL);
fs/nfsd/nfs4state.c:		dprintk("NFSD: nfs4_locku: vfs_lock_file failed!\n");
fs/nfsd/vfs.c:#include "vfs.h"
fs/nfsd/vfs.c: * and let the VFS handle things.
fs/nfsd/vfs.c:			/* set ATTR_KILL_* bits and let VFS handle it */
fs/nfsd/vfs.c:	buflen = vfs_getxattr(dentry, key, NULL, 0);
fs/nfsd/vfs.c:	ret = vfs_getxattr(dentry, key, *buf, buflen);
fs/nfsd/vfs.c:		return vfs_setxattr(dentry, key, NULL, 0, 0);
fs/nfsd/vfs.c:	error = vfs_setxattr(dentry, key, buf, len, 0);
fs/nfsd/vfs.c:	if (vfs_getxattr(dentry, NFSD_JUNCTION_XATTR_NAME, NULL, 0) <= 0)
fs/nfsd/vfs.c:nfsd_vfs_read(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file *file,
fs/nfsd/vfs.c:		host_err = vfs_readv(file, (struct iovec __user *)vec, vlen, &offset);
fs/nfsd/vfs.c:		err = vfs_fsync(file, 0);
fs/nfsd/vfs.c:nfsd_vfs_write(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file *file,
fs/nfsd/vfs.c:	host_err = vfs_writev(file, (struct iovec __user *)vec, vlen, &offset);
fs/nfsd/vfs.c:	err = nfsd_vfs_read(rqstp, fhp, file, offset, vec, vlen, count);
fs/nfsd/vfs.c:		err = nfsd_vfs_read(rqstp, fhp, file, offset, vec, vlen, count);
fs/nfsd/vfs.c:		err = nfsd_vfs_write(rqstp, fhp, file, offset, vec, vlen, cnt,
fs/nfsd/vfs.c:			err = nfsd_vfs_write(rqstp, fhp, file, offset, vec, vlen,
fs/nfsd/vfs.c:		int err2 = vfs_fsync_range(file, offset, end, 0);
fs/nfsd/vfs.c: * call this only after vfs_create() is called.
fs/nfsd/vfs.c:		host_err = vfs_create(dirp, dchild, iap->ia_mode, NULL);
fs/nfsd/vfs.c:		host_err = vfs_mkdir(dirp, dchild, iap->ia_mode);
fs/nfsd/vfs.c:		host_err = vfs_mknod(dirp, dchild, iap->ia_mode, rdev);
fs/nfsd/vfs.c:	host_err = vfs_create(dirp, dchild, iap->ia_mode, NULL);
fs/nfsd/vfs.c:			host_err = vfs_symlink(dentry->d_inode, dnew, path_alloced);
fs/nfsd/vfs.c:		host_err = vfs_symlink(dentry->d_inode, dnew, path);
fs/nfsd/vfs.c:	host_err = vfs_link(dold, dirp, dnew);
fs/nfsd/vfs.c:	host_err = vfs_rename(fdir, odentry, tdir, ndentry);
fs/nfsd/vfs.c:		host_err = vfs_unlink(dirp, rdentry);
fs/nfsd/vfs.c:		host_err = vfs_rmdir(dirp, rdentry);
fs/nfsd/vfs.c:		host_err = vfs_readdir(file, nfsd_buffered_filldir, &buf);
fs/nfsd/vfs.c:		offset = vfs_llseek(file, 0, SEEK_CUR);
fs/nfsd/vfs.c:	offset = vfs_llseek(file, offset, 0);
fs/nfsd/vfs.c:		if (vfs_statfs(&path, stat))
fs/nfsd/vfs.c:		error = vfs_setxattr(fhp->fh_dentry, name, value, size, 0);
fs/nfsd/vfs.c:			error = vfs_removexattr(fhp->fh_dentry, name);
fs/nfsd/export.c: * One maps client+vfsmnt+dentry to export options - the export map
fs/nfsd/nfs4recover.c:#include "vfs.h"
fs/nfsd/nfs4recover.c:	status = vfs_mkdir(dir->d_inode, dentry, S_IRWXU);
fs/nfsd/nfs4recover.c:		vfs_fsync(rec_file, 0);
fs/nfsd/nfs4recover.c:	status = vfs_llseek(rec_file, 0, SEEK_SET);
fs/nfsd/nfs4recover.c:	status = vfs_readdir(rec_file, nfsd4_build_namelist, &names);
fs/nfsd/nfs4recover.c:	status = vfs_rmdir(dir->d_inode, dentry);
fs/nfsd/nfs4recover.c:		vfs_fsync(rec_file, 0);
fs/nfsd/nfs4recover.c:	status = vfs_rmdir(parent->d_inode, child);
fs/nfsd/nfs4recover.c:		vfs_fsync(rec_file, 0);
fs/nfsd/nfsxdr.c:	vfs_getattr(fhp->fh_export->ex_path.mnt, fhp->fh_dentry, &stat);
fs/nfsd/nfsfh.h: * vfs.c:nfsd_rename as it needs to grab 2 i_mutex's at once
fs/nfsd/nfs3proc.c:#include "vfs.h"
fs/nfsd/nfs3proc.c:	err = vfs_getattr(resp->fh.fh_export->ex_path.mnt,
fs/nfsd/Makefile:nfsd-y 			:= nfssvc.o nfsctl.o nfsproc.o nfsfh.o vfs.o \
fs/romfs/super.c: *	Aug 1998			2.1.118+ VFS changes
fs/romfs/super.c: *	Sep 1998	2.1.122		another VFS change (follow_link)
fs/romfs/super.c:	return inode ? &inode->vfs_inode : NULL;
fs/romfs/super.c:			printk(KERN_WARNING "VFS:"
fs/romfs/super.c:	inode_init_once(&inode->vfs_inode);
fs/romfs/internal.h:	struct inode	vfs_inode;
fs/romfs/internal.h:	return container_of(inode, struct romfs_inode_info, vfs_inode);
fs/jbd2/journal.c:	jinode->i_vfs_inode = inode;
fs/jbd2/commit.c:		mapping = jinode->i_vfs_inode->i_mapping;
fs/jbd2/commit.c:		trace_jbd2_submit_inode_data(jinode->i_vfs_inode);
fs/jbd2/commit.c:		err = filemap_fdatawait(jinode->i_vfs_inode->i_mapping);
fs/jbd2/commit.c:				&jinode->i_vfs_inode->i_mapping->flags);
fs/jbd2/transaction.c:	jbd_debug(4, "Adding inode %lu, tid:%d\n", jinode->i_vfs_inode->i_ino,
fs/jbd2/transaction.c:		ret = filemap_fdatawrite_range(jinode->i_vfs_inode->i_mapping,
fs/afs/flock.c:	/* ... but we do still need to get the VFS's blessing */
fs/afs/flock.c:		goto vfs_rejected_lock;
fs/afs/flock.c:vfs_rejected_lock:
fs/afs/flock.c:	/* the VFS rejected the lock we just obtained, so we have to discard
fs/afs/flock.c:	_debug("vfs refused %d", ret);
fs/afs/flock.c:		_leave(" = %d [vfs]", ret);
fs/afs/flock.c:	mutex_lock(&vnode->vfs_inode.i_mutex);
fs/afs/flock.c:	mutex_unlock(&vnode->vfs_inode.i_mutex);
fs/afs/flock.c:	if (__mandatory_lock(&vnode->vfs_inode) && fl->fl_type != F_UNLCK)
fs/afs/flock.c: * the POSIX lock management core VFS code copies the lock record and adds the
fs/afs/flock.c: * VFS's list
fs/afs/super.c:	inode_init_once(&vnode->vfs_inode);
fs/afs/super.c:	_leave(" = %p", &vnode->vfs_inode);
fs/afs/super.c:	return &vnode->vfs_inode;
fs/afs/dir.c:	ret = afs_do_lookup(&dir->vfs_inode, dentry, &fid, key);
fs/afs/dir.c: * allow the VFS to enquire as to whether a dentry should be unhashed (mustn't
fs/afs/dir.c:		clear_nlink(&vnode->vfs_inode);
fs/afs/dir.c:		_debug("nlink %d [val %d]", vnode->vfs_inode.i_nlink, ret);
fs/afs/dir.c:	ihold(&vnode->vfs_inode);
fs/afs/dir.c:	d_instantiate(dentry, &vnode->vfs_inode);
fs/afs/callback.c:		if (S_ISDIR(vnode->vfs_inode.i_mode))
fs/afs/callback.c:	iput(&vnode->vfs_inode);
fs/afs/callback.c:	_debug("GIVE UP INODE %p", &vnode->vfs_inode);
fs/afs/security.c:	if (S_ISDIR(vnode->vfs_inode.i_mode)) {
fs/afs/security.c:		auth_inode = igrab(&vnode->vfs_inode);
fs/afs/security.c:		auth_inode = afs_iget(vnode->vfs_inode.i_sb, key,
fs/afs/security.c:	iput(&auth_vnode->vfs_inode);
fs/afs/security.c:	ASSERT(S_ISDIR(auth_vnode->vfs_inode.i_mode));
fs/afs/security.c:			iput(&auth_vnode->vfs_inode);
fs/afs/security.c:	iput(&auth_vnode->vfs_inode);
fs/afs/fsclient.c:			i_size_write(&vnode->vfs_inode, size);
fs/afs/fsclient.c:			vnode->vfs_inode.i_uid = status->owner;
fs/afs/fsclient.c:			vnode->vfs_inode.i_gid = status->group;
fs/afs/fsclient.c:			vnode->vfs_inode.i_generation = vnode->fid.unique;
fs/afs/fsclient.c:			set_nlink(&vnode->vfs_inode, status->nlink);
fs/afs/fsclient.c:			mode = vnode->vfs_inode.i_mode;
fs/afs/fsclient.c:			vnode->vfs_inode.i_mode = mode;
fs/afs/fsclient.c:		vnode->vfs_inode.i_ctime.tv_sec	= status->mtime_server;
fs/afs/fsclient.c:		vnode->vfs_inode.i_mtime	= vnode->vfs_inode.i_ctime;
fs/afs/fsclient.c:		vnode->vfs_inode.i_atime	= vnode->vfs_inode.i_ctime;
fs/afs/fsclient.c:		vnode->vfs_inode.i_version	= data_version;
fs/afs/fsclient.c:	call->mapping = vnode->vfs_inode.i_mapping;
fs/afs/fsclient.c:	i_size = i_size_read(&vnode->vfs_inode);
fs/afs/fsclient.c:	call->mapping = vnode->vfs_inode.i_mapping;
fs/afs/inode.c:	if (S_ISREG(vnode->vfs_inode.i_mode))
fs/afs/inode.c:		invalidate_remote_inode(&vnode->vfs_inode);
fs/afs/inode.c:		invalidate_inode_pages2(vnode->vfs_inode.i_mapping);
fs/afs/inode.c:int afs_getattr(struct vfsmount *mnt, struct dentry *dentry,
fs/afs/inode.c:	if (S_ISREG(vnode->vfs_inode.i_mode)) {
fs/afs/inode.c:		filemap_write_and_wait(vnode->vfs_inode.i_mapping);
fs/afs/write.c:	i_size = i_size_read(&vnode->vfs_inode);
fs/afs/write.c:	i_size = i_size_read(&vnode->vfs_inode);
fs/afs/write.c:		i_size = i_size_read(&vnode->vfs_inode);
fs/afs/write.c:			i_size_write(&vnode->vfs_inode, maybe_i_size);
fs/afs/write.c:		pv.nr = find_get_pages_contig(vnode->vfs_inode.i_mapping,
fs/afs/write.c:		n = find_get_pages_contig(wb->vnode->vfs_inode.i_mapping,
fs/afs/write.c:				&wb->vnode->vfs_inode.i_mapping->flags);
fs/afs/write.c:			set_bit(AS_EIO, &wb->vnode->vfs_inode.i_mapping->flags);
fs/afs/write.c:	if (IS_SWAPFILE(&vnode->vfs_inode)) {
fs/afs/write.c:	struct address_space *mapping = vnode->vfs_inode.i_mapping;
fs/afs/cache.c:		nr_pages = pagevec_lookup(&pvec, vnode->vfs_inode.i_mapping,
fs/afs/internal.h:	struct inode		vfs_inode;	/* the VFS's inode record */
fs/afs/internal.h:extern int afs_getattr(struct vfsmount *, struct dentry *, struct kstat *);
fs/afs/internal.h:extern struct vfsmount *afs_d_automount(struct path *);
fs/afs/internal.h:	return container_of(inode, struct afs_vnode, vfs_inode);
fs/afs/internal.h:	return &vnode->vfs_inode;
fs/afs/mntpt.c:static LIST_HEAD(afs_vfsmounts);
fs/afs/mntpt.c:		vnode->vfs_inode.i_flags |= S_AUTOMOUNT;
fs/afs/mntpt.c: * create a vfsmount to be automounted
fs/afs/mntpt.c:static struct vfsmount *afs_mntpt_do_automount(struct dentry *mntpt)
fs/afs/mntpt.c:	struct vfsmount *mnt;
fs/afs/mntpt.c:	mnt = vfs_kern_mount(&afs_fs_type, 0, devname, options);
fs/afs/mntpt.c:struct vfsmount *afs_d_automount(struct path *path)
fs/afs/mntpt.c:	struct vfsmount *newmnt;
fs/afs/mntpt.c:	mnt_set_expiry(newmnt, &afs_vfsmounts);
fs/afs/mntpt.c:	if (!list_empty(&afs_vfsmounts)) {
fs/afs/mntpt.c:		mark_mounts_for_expiry(&afs_vfsmounts);
fs/afs/mntpt.c:	ASSERT(list_empty(&afs_vfsmounts));
fs/hfsplus/hfsplus_fs.h:	struct inode vfs_inode;
fs/hfsplus/hfsplus_fs.h:	return list_entry(inode, struct hfsplus_inode_info, vfs_inode);
fs/hfsplus/super.c:#include <linux/vfs.h>
fs/hfsplus/super.c:	return i ? &i->vfs_inode : NULL;
fs/hfsplus/super.c:	inode_init_once(&i->vfs_inode);
fs/hpfs/super.c:	ei->vfs_inode.i_version = 1;
fs/hpfs/super.c:	return &ei->vfs_inode;
fs/hpfs/super.c:	inode_init_once(&ei->vfs_inode);
fs/hpfs/dir.c: *  directory VFS functions
fs/hpfs/hpfs_fn.h:	struct inode vfs_inode;
fs/hpfs/hpfs_fn.h:	return list_entry(inode, struct hpfs_inode_info, vfs_inode);
fs/hpfs/hpfs_fn.h: * on any method called by the VFS.
fs/hpfs/inode.c: *  inode VFS functions
fs/hpfs/file.c: *  file VFS functions
fs/hpfs/namei.c:	/* order doesn't matter, due to VFS exclusion */
fs/block_dev.c:	struct inode vfs_inode;
fs/block_dev.c:	return container_of(inode, struct bdev_inode, vfs_inode);
fs/block_dev.c:	return &ei->vfs_inode;
fs/block_dev.c:	inode_init_once(&ei->vfs_inode);
fs/block_dev.c:	return mount_pseudo(fs_type, "bdev:", &bdev_sops, NULL, BDEVFS_MAGIC);
fs/block_dev.c:	static struct vfsmount *bd_mnt;
fs/block_dev.c:		printk(KERN_WARNING "VFS: busy inodes on changed media or "
fs/devpts/inode.c:static struct vfsmount *devpts_mnt;
fs/qnx4/inode.c:	return &ei->vfs_inode;
fs/qnx4/inode.c:	inode_init_once(&ei->vfs_inode);
fs/qnx4/qnx4.h:	struct inode vfs_inode;
fs/qnx4/qnx4.h:	return container_of(inode, struct qnx4_inode_info, vfs_inode);
fs/hfs/super.c:#include <linux/vfs.h>
fs/hfs/super.c: *   This function is called by the VFS only. When the filesystem
fs/hfs/super.c:	return i ? &i->vfs_inode : NULL;
fs/hfs/super.c:	inode_init_once(&i->vfs_inode);
fs/hfs/hfs_fs.h:	struct inode vfs_inode;
fs/hfs/hfs_fs.h:#define HFS_I(inode)	(list_entry(inode, struct hfs_inode_info, vfs_inode))
fs/super.c: *  Added devfs support: Richard Gooch <rgooch@atnf.csiro.au>, 13-JAN-1998
fs/super.c:	total_objects = (total_objects / 100) * sysctl_vfs_cache_pressure;
fs/super.c:		mutex_init(&s->s_vfs_rename_mutex);
fs/super.c:		lockdep_set_class(&s->s_vfs_rename_mutex, &type->s_vfs_rename_key);
fs/super.c:			printk("VFS: Busy inodes after unmount of %s. "
fs/super.c:		vfs_check_frozen(s, SB_FREEZE_WRITE);
fs/super.c:				"VFS:Filesystem freeze failed\n");
fs/super.c:				"VFS:Filesystem thaw failed\n");
fs/openpromfs/inode.c:	struct inode		vfs_inode;
fs/openpromfs/inode.c:	return container_of(inode, struct op_inode_info, vfs_inode);
fs/openpromfs/inode.c:	return &oi->vfs_inode;
fs/openpromfs/inode.c:	inode_init_once(&oi->vfs_inode);
fs/bad_inode.c:static int bad_inode_getattr(struct vfsmount *mnt, struct dentry *dentry,
fs/ceph/caps.c:	dout("__cap_set_timeouts %p min %lu max %lu\n", &ci->vfs_inode,
fs/ceph/caps.c:	dout("__cap_delay_requeue %p flags %d at %lu\n", &ci->vfs_inode,
fs/ceph/caps.c:	dout("__cap_delay_requeue_front %p\n", &ci->vfs_inode);
fs/ceph/caps.c:	dout("__cap_delay_cancel %p\n", &ci->vfs_inode);
fs/ceph/caps.c:		if (S_ISDIR(ci->vfs_inode.i_mode))
fs/ceph/caps.c:			ceph_dir_clear_complete(&ci->vfs_inode);
fs/ceph/caps.c:		     "but STALE (gen %u vs %u)\n", &cap->ci->vfs_inode,
fs/ceph/caps.c:		     &ci->vfs_inode, cap, ceph_cap_string(cap->issued));
fs/ceph/caps.c:		dout("__touch_cap %p cap %p mds%d\n", &cap->ci->vfs_inode, cap,
fs/ceph/caps.c:		     &cap->ci->vfs_inode, cap, s->s_mds);
fs/ceph/caps.c:		     " (mask %s)\n", &ci->vfs_inode,
fs/ceph/caps.c:			     " (mask %s)\n", &ci->vfs_inode, cap,
fs/ceph/caps.c:			     " (mask %s)\n", &ci->vfs_inode,
fs/ceph/caps.c:	struct inode *inode = &ci->vfs_inode;
fs/ceph/caps.c:	if (ci->i_rdcache_ref || ci->vfs_inode.i_data.nrpages)
fs/ceph/caps.c:		ceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;
fs/ceph/caps.c:	dout("__ceph_remove_cap %p from %p\n", cap, &ci->vfs_inode);
fs/ceph/caps.c:	struct inode *inode = &ci->vfs_inode;
fs/ceph/caps.c:	struct inode *inode = &ci->vfs_inode;
fs/ceph/caps.c:		ceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;
fs/ceph/caps.c:	struct inode *inode = &ci->vfs_inode;
fs/ceph/caps.c:	dout("__mark_dirty_caps %p %s dirty %s -> %s\n", &ci->vfs_inode,
fs/ceph/caps.c:		     &ci->vfs_inode, ci->i_head_snapc, ci->i_auth_cap);
fs/ceph/caps.c:	struct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);
fs/ceph/caps.c:	struct inode *inode = &ci->vfs_inode;
fs/ceph/caps.c:		struct inode *inode = &ci->vfs_inode;
fs/ceph/caps.c:		struct inode *inode = &ci->vfs_inode;
fs/ceph/caps.c:			ihold(&ci->vfs_inode);
fs/ceph/caps.c:		     &ci->vfs_inode, ci->i_wb_ref-1, ci->i_wb_ref);
fs/ceph/caps.c:	struct inode *inode = &ci->vfs_inode;
fs/ceph/caps.c:		check_max_size(&ci->vfs_inode, endoff);
fs/ceph/caps.c:	struct inode *inode = &ci->vfs_inode;
fs/ceph/caps.c:	struct inode *inode = &ci->vfs_inode;
fs/ceph/caps.c:					 i_flushing_item)->vfs_inode);
fs/ceph/caps.c:		dout("check_delayed_caps on %p\n", &ci->vfs_inode);
fs/ceph/caps.c:		inode = &ci->vfs_inode;
fs/ceph/caps.c:	struct inode *inode = &ci->vfs_inode;
fs/ceph/mds_client.c:		inode = igrab(&cap->ci->vfs_inode);
fs/ceph/mds_client.c:	     cap, ci, &ci->vfs_inode);
fs/ceph/mds_client.c:			struct inode *inode = &ci->vfs_inode;
fs/ceph/super.c:	inode_init_once(&ci->vfs_inode);
fs/ceph/super.c:	int first = 0;   /* first vfsmount for this super_block */
fs/ceph/mds_client.h:	struct inode *r_locked_dir; /* dir (if any) i_mutex locked by vfs */
fs/ceph/dir.c: * existed) in place of the original VFS-provided dentry when they
fs/ceph/dir.c: * a lookup (the VFS expects us to link up the provided dentry).
fs/ceph/dir.c:		 * case the VFS wants to dereference it.
fs/ceph/dir.c:		   rehashing bug in vfs_rename_dir */
fs/ceph/dir.c: * When the VFS prunes a dentry from the cache, we need to clear the
fs/ceph/snap.c:	struct inode *inode = &ci->vfs_inode;
fs/ceph/snap.c:	struct inode *inode = &ci->vfs_inode;
fs/ceph/snap.c:		struct inode *inode = igrab(&ci->vfs_inode);
fs/ceph/snap.c:		inode = &ci->vfs_inode;
fs/ceph/super.h:	struct inode vfs_inode; /* at end */
fs/ceph/super.h:	return container_of(inode, struct ceph_inode_info, vfs_inode);
fs/ceph/super.h:extern int ceph_getattr(struct vfsmount *mnt, struct dentry *dentry,
fs/ceph/addr.c:		err = 0;  /* vfs expects us to return 0 */
fs/ceph/inode.c:		       "frag %x\n", &ci->vfs_inode,
fs/ceph/inode.c:		       ceph_vinop(&ci->vfs_inode), f);
fs/ceph/inode.c:	     ceph_vinop(&ci->vfs_inode), f);
fs/ceph/inode.c:	dout("alloc_inode %p\n", &ci->vfs_inode);
fs/ceph/inode.c:	return &ci->vfs_inode;
fs/ceph/inode.c:			ceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;
fs/ceph/inode.c:			   rehashing bug in vfs_rename_dir */
fs/ceph/inode.c:	struct inode *inode = &ci->vfs_inode;
fs/ceph/inode.c:	struct inode *inode = &ci->vfs_inode;
fs/ceph/inode.c:	struct inode *inode = &ci->vfs_inode;
fs/ceph/inode.c:int ceph_getattr(struct vfsmount *mnt, struct dentry *dentry,
fs/ceph/file.c:	/* filter out O_CREAT|O_EXCL; vfs did that already.  yuck. */
fs/ceph/file.c: * If this succeeds, but some subsequent check in the vfs
fs/ceph/file.c:			err = vfs_fsync_range(file, pos, pos + ret - 1, 1);
fs/ceph/xattr.c:	     ceph_vinop(&ci->vfs_inode), xattr, name, val_len, val);
fs/ceph/xattr.c:	dout("__build_xattrs_blob %p\n", &ci->vfs_inode);
fs/statfs.c:static int calculate_f_flags(struct vfsmount *mnt)
fs/statfs.c:int vfs_statfs(struct path *path, struct kstatfs *buf)
fs/statfs.c:EXPORT_SYMBOL(vfs_statfs);
fs/statfs.c:		error = vfs_statfs(&path, st);
fs/statfs.c:		error = vfs_statfs(&file->f_path, st);
fs/statfs.c:int vfs_ustat(dev_t dev, struct kstatfs *sbuf)
fs/statfs.c:	int err = vfs_ustat(new_decode_dev(dev), &sbuf);
fs/ntfs/attrib.c:		 * ctx->vfs_ino, ctx->mrec, and ctx->attr now point to the
fs/ntfs/attrib.c: * always know it.  The reason we cannot simply read the size from the vfs
fs/ntfs/attrib.c:	struct inode *vi = VFS_I(ni);
fs/ntfs/attrib.c: * vfs inode is not updated.  Only the data size in the base attribute record
fs/ntfs/attrib.c:	struct inode *vi = VFS_I(ni);
fs/ntfs/attrib.c:	mapping = VFS_I(ni)->i_mapping;
fs/ntfs/attrib.c:	if (unlikely(end > i_size_read(VFS_I(ni)))) {
fs/ntfs/ntfs.h: * NTFS_SB - return the ntfs volume given a vfs super block
fs/ntfs/ntfs.h: * @sb:		VFS super block
fs/ntfs/ntfs.h: * NTFS_SB() returns the ntfs volume associated with the VFS super block @sb.
fs/ntfs/mft.c: * Q: Do we want to recycle one of the VFS inode state bits instead?
fs/ntfs/mft.c:	 * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to
fs/ntfs/mft.c: * vfs inode dirty.  This ensures that any changes to the mft record are
fs/ntfs/mft.c: * on the base vfs inode, because even though file data may have been modified,
fs/ntfs/mft.c: * necessarily hit the device synchronously, even though the vfs inode has the
fs/ntfs/mft.c:	/* Determine the base vfs inode and mark it dirty, too. */
fs/ntfs/mft.c:	__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);
fs/ntfs/mft.c: * and possible the ntfs inode of the mft record is locked and the base vfs
fs/ntfs/mft.c: * vfs inode.
fs/ntfs/mft.c: * record.  If it is dirty, we do not write it and return 'false' as the vfs
fs/ntfs/mft.c: * relying on the vfs inode dirty code paths is that we can have mft records
fs/ntfs/mft.c: * relied on the vfs inode dirty code paths.  And these cases can really occur
fs/ntfs/mft.c:	 * Check if the inode corresponding to this mft record is in the VFS
fs/ntfs/mft.c:		 * Allocate a new VFS inode and set it up.  NOTE: @vi->i_nlink
fs/ntfs/lcnalloc.c: * described by the vfs inode @ni.
fs/ntfs/aops.c:		iput(VFS_I(base_tni));
fs/ntfs/aops.c: * vfs inode dirty code path for the inode the mft record belongs to or via the
fs/ntfs/aops.c: * The latter also marks the vfs inode the ntfs record belongs to dirty
fs/ntfs/aops.c:	bh_size = VFS_I(ni)->i_sb->s_blocksize;
fs/ntfs/super.c:#include <linux/vfs.h>
fs/ntfs/super.c: * NOTE:  The VFS sets the @sb->s_flags remount flags to @flags after
fs/ntfs/super.c:	/* No VFS initiated operations allowed for $MFTMirr. */
fs/ntfs/super.c: * ntfs_put_super - called by the vfs to unmount a volume
fs/ntfs/super.c: * @sb:		vfs superblock of volume to unmount
fs/ntfs/super.c: * ntfs_put_super() is called by the VFS (from fs/super.c::do_umount()) when
fs/ntfs/super.c: * Called from vfs_statfs which is used to handle the statfs, fstatfs, and
fs/ntfs/super.c:	.alloc_inode	= ntfs_alloc_big_inode,	  /* VFS: Allocate new inode. */
fs/ntfs/super.c:	.destroy_inode	= ntfs_destroy_big_inode, /* VFS: Deallocate inode. */
fs/ntfs/super.c:	//.dirty_inode	= NULL,			/* VFS: Called from
fs/ntfs/super.c:	.write_inode	= ntfs_write_inode,	/* VFS: Write dirty inode to
fs/ntfs/super.c:	//.drop_inode	= NULL,			/* VFS: Called just after the
fs/ntfs/super.c:	//.delete_inode	= NULL,			/* VFS: Delete inode from disk.
fs/ntfs/super.c:	.evict_inode	= ntfs_evict_big_inode,	/* VFS: Called when an inode is
fs/ntfs/super.c: * ntfs_fill_super() is called by the VFS to mount the device described by @sb
fs/ntfs/super.c:	inode_init_once(VFS_I(ni));
fs/ntfs/index.c:	ia_mapping = VFS_I(idx_ni)->i_mapping;
fs/ntfs/volume.h:	struct inode *mft_ino;		/* The VFS inode of $MFT. */
fs/ntfs/volume.h:	struct inode *mftmirr_ino;	/* The VFS inode of $MFTMirr. */
fs/ntfs/volume.h:	struct inode *logfile_ino;	/* The VFS inode of $LogFile. */
fs/ntfs/volume.h:	struct inode *lcnbmp_ino;	/* The VFS inode of $Bitmap. */
fs/ntfs/volume.h:	struct inode *vol_ino;		/* The VFS inode of $Volume. */
fs/ntfs/volume.h:	struct inode *root_ino;		/* The VFS inode of the root
fs/ntfs/volume.h:	struct inode *secure_ino;	/* The VFS inode of $Secure (NTFS3.0+
fs/ntfs/volume.h:	struct inode *extend_ino;	/* The VFS inode of $Extend (NTFS3.0+
fs/ntfs/volume.h:	struct inode *quota_ino;	/* The VFS inode of $Quota. */
fs/ntfs/volume.h:	struct inode *usnjrnl_ino;	/* The VFS inode of $UsnJrnl. */
fs/ntfs/compress.c:	i_size = i_size_read(VFS_I(ni));
fs/ntfs/index.h: * VFS inode of the ntfs index inode to which the index entry belongs dirty,
fs/ntfs/dir.c:	BUG_ON(!S_ISDIR(VFS_I(dir_ni)->i_mode));
fs/ntfs/dir.c:	ia_mapping = VFS_I(dir_ni)->i_mapping;
fs/ntfs/dir.c:	ia_mapping = VFS_I(dir_ni)->i_mapping;
fs/ntfs/dir.c: * @dirent:	vfs filldir callback context
fs/ntfs/dir.c: * @filldir:	vfs filldir callback
fs/ntfs/dir.c: * VFS calls ->readdir without BKL but with i_mutex held. This protects the VFS
fs/ntfs/inode.h: * fields already provided in the VFS inode.
fs/ntfs/inode.h: * should be independent of the (ntfs/vfs) inode structure so that an inode can
fs/ntfs/inode.h: * The full structure containing a ntfs_inode and a vfs struct inode. Used for
fs/ntfs/inode.h: * all real and fake inodes but not for extent inodes which lack the vfs struct
fs/ntfs/inode.h:	struct inode vfs_inode;		/* The vfs inode structure. */
fs/ntfs/inode.h: * NTFS_I - return the ntfs inode given a vfs inode
fs/ntfs/inode.h: * @inode:	VFS inode
fs/ntfs/inode.h: * NTFS_I() returns the ntfs inode associated with the VFS @inode.
fs/ntfs/inode.h:	return (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);
fs/ntfs/inode.h:static inline struct inode *VFS_I(ntfs_inode *ni)
fs/ntfs/inode.h:	return &((big_ntfs_inode *)ni)->vfs_inode;
fs/ntfs/inode.h:extern void ntfs_truncate_vfs(struct inode *vi);
fs/ntfs/inode.c: * @vi:		vfs inode which to test
fs/ntfs/inode.c: * Compare the ntfs attribute embedded in the ntfs specific part of the vfs
fs/ntfs/inode.c: * @vi:		vfs inode to initialize
fs/ntfs/inode.c: * Initialize the vfs inode @vi with the values from the ntfs attribute @na in
fs/ntfs/inode.c: * @base_vi:	vfs base inode containing the attribute
fs/ntfs/inode.c: * specified by the vfs inode @base_vi.
fs/ntfs/inode.c: * @base_vi:	vfs base inode containing the index related attributes
fs/ntfs/inode.c: * and @name_len, which is present in the base mft record specified by the vfs
fs/ntfs/inode.c:		return VFS_I(ni);
fs/ntfs/inode.c:	/* Setup the generic vfs inode parts now. */
fs/ntfs/inode.c:	/* Transfer information from mft record into vfs and ntfs inodes. */
fs/ntfs/inode.c:	 * might be tricky due to vfs interactions. Need to think about this
fs/ntfs/inode.c: * accessed from the VFS side (or even internally), only by the
fs/ntfs/inode.c:			/* No VFS initiated operations allowed for $MFT. */
fs/ntfs/inode.c:		if (!is_bad_inode(VFS_I(ni->ext.base_ntfs_ino)))
fs/ntfs/inode.c: * @vi:		vfs inode pending annihilation
fs/ntfs/inode.c: * When the VFS is going to remove an inode from memory, ntfs_clear_big_inode()
fs/ntfs/inode.c:			iput(VFS_I(ni->ext.base_ntfs_ino));
fs/ntfs/inode.c: * Called by the VFS once for each mounted ntfs volume when someone reads
fs/ntfs/inode.c:	 * The i_size of the vfs inode is the new size for the attribute value.
fs/ntfs/inode.c:			/* Reset the vfs inode size to the old size. */
fs/ntfs/inode.c:	if (!IS_NOCMTIME(VFS_I(base_ni)) && !IS_RDONLY(VFS_I(base_ni))) {
fs/ntfs/inode.c:		struct timespec now = current_fs_time(VFS_I(base_ni)->i_sb);
fs/ntfs/inode.c:		if (!timespec_equal(&VFS_I(base_ni)->i_mtime, &now) ||
fs/ntfs/inode.c:		    !timespec_equal(&VFS_I(base_ni)->i_ctime, &now))
fs/ntfs/inode.c:		VFS_I(base_ni)->i_mtime = now;
fs/ntfs/inode.c:		VFS_I(base_ni)->i_ctime = now;
fs/ntfs/inode.c:			mark_inode_dirty_sync(VFS_I(base_ni));
fs/ntfs/inode.c: * ntfs_truncate_vfs - wrapper for ntfs_truncate() that has no return value
fs/ntfs/inode.c:void ntfs_truncate_vfs(struct inode *vi) {
fs/ntfs/inode.c: * We have to trap VFS attempts to truncate the file described by @dentry as
fs/ntfs/inode.c:				"Marking the inode dirty again, so the VFS "
fs/ntfs/mft.h: * vfs inode dirty.  This ensures that any changes to the mft record are
fs/ntfs/file.c: * As a side-effect, the file size (vfs inode->i_size) may be incremented as,
fs/ntfs/file.c: * Locking: i_mutex on the vfs inode corrseponsind to the ntfs inode @ni must be
fs/ntfs/file.c:	struct inode *vi = VFS_I(ni);
fs/ntfs/file.c:	/* Finally, update the sizes in the vfs and ntfs inodes. */
fs/ntfs/file.c:	 * size (vfs inode->i_size), we need to extend the file size to the
fs/ntfs/file.c:		/* Update the file size in the vfs inode. */
fs/ntfs/file.c: * Locking: The vfs is holding ->i_mutex on the inode.
fs/ntfs/file.c:	 * increments the vfs inode->i_size to keep it above or equal to the
fs/ntfs/file.c:	vfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);
fs/ntfs/file.c:	.truncate	= ntfs_truncate_vfs,
fs/ntfs/bitmap.h: * @vi:			vfs inode describing the bitmap
fs/ntfs/bitmap.h: * vfs inode @vi to @value, where @value is either 0 or 1.
fs/ntfs/bitmap.h: * @vi:		vfs inode describing the bitmap
fs/ntfs/bitmap.h: * vfs inode @vi.
fs/ntfs/bitmap.h: * @vi:		vfs inode describing the bitmap
fs/ntfs/bitmap.h: * vfs inode @vi.
fs/ntfs/bitmap.h: * @vi:		vfs inode describing the bitmap
fs/ntfs/bitmap.h: * Set bit @bit in the bitmap described by the vfs inode @vi.
fs/ntfs/bitmap.h: * @vi:		vfs inode describing the bitmap
fs/ntfs/bitmap.h: * Clear bit @bit in the bitmap described by the vfs inode @vi.
fs/ntfs/namei.c: *    which we deal with appropriately (see the code comments).  The VFS will
fs/ntfs/namei.c:	.lookup	= ntfs_lookup,	/* VFS: Lookup directory. */
fs/ntfs/bitmap.c: * @vi:			vfs inode describing the bitmap
fs/ntfs/bitmap.c: * vfs inode @vi to @value, where @value is either 0 or 1.
fs/befs/befs.h:	struct inode vfs_inode;
fs/befs/befs.h:	return list_entry(inode, struct befs_inode_info, vfs_inode);
fs/befs/ChangeLog:* Segregated the functions that interface directly with the linux  vfs 
fs/befs/ChangeLog:	interface into their own file called linuxvfs.c. [WD]
fs/befs/ChangeLog:* Remove the typedef of struct super_block to vfs_sb, as it offended
fs/befs/ChangeLog:	linux VFS doesn't allow us to keep any state between calls. Updated 
fs/befs/ChangeLog:* Converted all non vfs-callback functions to use befs_sb_info as the 
fs/befs/ChangeLog:* Removed superblock locking calls in befs_read_super(). In 2.4, the VFS 
fs/befs/linuxvfs.c: * linux/fs/befs/linuxvfs.c
fs/befs/linuxvfs.c:#include <linux/vfs.h>
fs/befs/linuxvfs.c:/* The units the vfs expects inode->i_blocks to be in */
fs/befs/linuxvfs.c:#define VFS_BLOCK_SIZE 512
fs/befs/linuxvfs.c:        return &bi->vfs_inode;
fs/befs/linuxvfs.c:	inode_init_once(&bi->vfs_inode);
fs/befs/linuxvfs.c:	/* convert from vfs's inode number to befs's inode number */
fs/befs/linuxvfs.c:	 * BEFS's time is 64 bits, but current VFS is 32 bits...
fs/befs/linuxvfs.c:	 * BEFS don't have access time. Nor inode change time. VFS
fs/befs/linuxvfs.c:		inode->i_blocks = befs_sb->block_size / VFS_BLOCK_SIZE;
fs/befs/linuxvfs.c:		    num_blks * (befs_sb->block_size / VFS_BLOCK_SIZE);
fs/befs/inode.c:		befs_error(sb, "inode blocknr field disagrees with vfs "
fs/befs/inode.c:			   "VFS: %lu, Inode %lu",
fs/befs/Makefile:befs-objs := datastream.o btree.o super.o inode.o debug.o io.o linuxvfs.o
fs/notify/dnotify/dnotify.c:				struct fsnotify_mark *vfsmount_mark,
fs/notify/dnotify/dnotify.c:	BUG_ON(vfsmount_mark);
fs/notify/dnotify/dnotify.c:				      struct fsnotify_mark *vfsmount_mark,
fs/notify/mark.c:	} else if (mark->flags & FSNOTIFY_MARK_FLAG_VFSMOUNT)
fs/notify/mark.c:		fsnotify_destroy_vfsmount_mark(mark);
fs/notify/mark.c:		      struct vfsmount *mnt, int allow_dups)
fs/notify/mark.c:		ret = fsnotify_add_vfsmount_mark(mark, group, mnt, allow_dups);
fs/notify/fsnotify.c:void __fsnotify_vfsmount_delete(struct vfsmount *mnt)
fs/notify/fsnotify.c:static int send_to_group(struct inode *to_tell, struct vfsmount *mnt,
fs/notify/fsnotify.c:			 struct fsnotify_mark *vfsmount_mark,
fs/notify/fsnotify.c:	__u32 vfsmount_test_mask = 0;
fs/notify/fsnotify.c:	if (unlikely(!inode_mark && !vfsmount_mark)) {
fs/notify/fsnotify.c:		if (vfsmount_mark &&
fs/notify/fsnotify.c:		    !(vfsmount_mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY))
fs/notify/fsnotify.c:			vfsmount_mark->ignored_mask = 0;
fs/notify/fsnotify.c:	/* does the vfsmount_mark tell us to do something? */
fs/notify/fsnotify.c:	if (vfsmount_mark) {
fs/notify/fsnotify.c:		vfsmount_test_mask = (mask & ~FS_EVENT_ON_CHILD);
fs/notify/fsnotify.c:		group = vfsmount_mark->group;
fs/notify/fsnotify.c:		vfsmount_test_mask &= vfsmount_mark->mask;
fs/notify/fsnotify.c:		vfsmount_test_mask &= ~vfsmount_mark->ignored_mask;
fs/notify/fsnotify.c:			vfsmount_test_mask &= ~inode_mark->ignored_mask;
fs/notify/fsnotify.c:		 " inode_test_mask=%x vfsmount_mark=%p vfsmount_test_mask=%x"
fs/notify/fsnotify.c:		 inode_test_mask, vfsmount_mark, vfsmount_test_mask, data,
fs/notify/fsnotify.c:	if (!inode_test_mask && !vfsmount_test_mask)
fs/notify/fsnotify.c:					  vfsmount_mark, mask, data,
fs/notify/fsnotify.c:	return group->ops->handle_event(group, inode_mark, vfsmount_mark, *event);
fs/notify/fsnotify.c: * This is the main call to fsnotify.  The VFS calls into hook specific functions
fs/notify/fsnotify.c:	struct hlist_node *inode_node = NULL, *vfsmount_node = NULL;
fs/notify/fsnotify.c:	struct fsnotify_mark *inode_mark = NULL, *vfsmount_mark = NULL;
fs/notify/fsnotify.c:	struct fsnotify_group *inode_group, *vfsmount_group;
fs/notify/fsnotify.c:	 * otherwise return if neither the inode nor the vfsmount care about
fs/notify/fsnotify.c:		vfsmount_node = srcu_dereference(mnt->mnt_fsnotify_marks.first,
fs/notify/fsnotify.c:	while (inode_node || vfsmount_node) {
fs/notify/fsnotify.c:		inode_group = vfsmount_group = NULL;
fs/notify/fsnotify.c:		if (vfsmount_node) {
fs/notify/fsnotify.c:			vfsmount_mark = hlist_entry(srcu_dereference(vfsmount_node, &fsnotify_mark_srcu),
fs/notify/fsnotify.c:			vfsmount_group = vfsmount_mark->group;
fs/notify/fsnotify.c:		if (inode_group > vfsmount_group) {
fs/notify/fsnotify.c:			/* we didn't use the vfsmount_mark */
fs/notify/fsnotify.c:			vfsmount_group = NULL;
fs/notify/fsnotify.c:		} else if (vfsmount_group > inode_group) {
fs/notify/fsnotify.c:			ret = send_to_group(to_tell, &mnt->mnt, NULL, vfsmount_mark, mask, data,
fs/notify/fsnotify.c:			ret = send_to_group(to_tell, &mnt->mnt, inode_mark, vfsmount_mark,
fs/notify/fsnotify.c:		if (vfsmount_group)
fs/notify/fsnotify.c:			vfsmount_node = srcu_dereference(vfsmount_node->next,
fs/notify/vfsmount_mark.c:void fsnotify_clear_marks_by_mount(struct vfsmount *mnt)
fs/notify/vfsmount_mark.c:void fsnotify_clear_vfsmount_marks_by_group(struct fsnotify_group *group)
fs/notify/vfsmount_mark.c:	fsnotify_clear_marks_by_group_flags(group, FSNOTIFY_MARK_FLAG_VFSMOUNT);
fs/notify/vfsmount_mark.c: * Recalculate the mask of events relevant to a given vfsmount locked.
fs/notify/vfsmount_mark.c:static void fsnotify_recalc_vfsmount_mask_locked(struct vfsmount *mnt)
fs/notify/vfsmount_mark.c:void fsnotify_recalc_vfsmount_mask(struct vfsmount *mnt)
fs/notify/vfsmount_mark.c:	fsnotify_recalc_vfsmount_mask_locked(mnt);
fs/notify/vfsmount_mark.c:void fsnotify_destroy_vfsmount_mark(struct fsnotify_mark *mark)
fs/notify/vfsmount_mark.c:	struct vfsmount *mnt = mark->m.mnt;
fs/notify/vfsmount_mark.c:	fsnotify_recalc_vfsmount_mask_locked(mnt);
fs/notify/vfsmount_mark.c:static struct fsnotify_mark *fsnotify_find_vfsmount_mark_locked(struct fsnotify_group *group,
fs/notify/vfsmount_mark.c:								struct vfsmount *mnt)
fs/notify/vfsmount_mark.c: * given a group and vfsmount, find the mark associated with that combination.
fs/notify/vfsmount_mark.c:struct fsnotify_mark *fsnotify_find_vfsmount_mark(struct fsnotify_group *group,
fs/notify/vfsmount_mark.c:						  struct vfsmount *mnt)
fs/notify/vfsmount_mark.c:	mark = fsnotify_find_vfsmount_mark_locked(group, mnt);
fs/notify/vfsmount_mark.c: * Attach an initialized mark to a given group and vfsmount.
fs/notify/vfsmount_mark.c:int fsnotify_add_vfsmount_mark(struct fsnotify_mark *mark,
fs/notify/vfsmount_mark.c:			       struct fsnotify_group *group, struct vfsmount *mnt,
fs/notify/vfsmount_mark.c:	mark->flags |= FSNOTIFY_MARK_FLAG_VFSMOUNT;
fs/notify/vfsmount_mark.c:	fsnotify_recalc_vfsmount_mask_locked(mnt);
fs/notify/inotify/inotify_user.c: * error because we have compiled-in VFS hooks.  So an (unlikely) failure here
fs/notify/inotify/inotify_fsnotify.c:				struct fsnotify_mark *vfsmount_mark,
fs/notify/inotify/inotify_fsnotify.c:	BUG_ON(vfsmount_mark);
fs/notify/inotify/inotify_fsnotify.c:				      struct fsnotify_mark *vfsmount_mark,
fs/notify/fanotify/fanotify_user.c:	struct vfsmount *mnt;
fs/notify/fanotify/fanotify_user.c:static int fanotify_remove_vfsmount_mark(struct fsnotify_group *group,
fs/notify/fanotify/fanotify_user.c:					 struct vfsmount *mnt, __u32 mask,
fs/notify/fanotify/fanotify_user.c:	fsn_mark = fsnotify_find_vfsmount_mark(group, mnt);
fs/notify/fanotify/fanotify_user.c:		fsnotify_recalc_vfsmount_mask(mnt);
fs/notify/fanotify/fanotify_user.c:static int fanotify_add_vfsmount_mark(struct fsnotify_group *group,
fs/notify/fanotify/fanotify_user.c:				      struct vfsmount *mnt, __u32 mask,
fs/notify/fanotify/fanotify_user.c:	fsn_mark = fsnotify_find_vfsmount_mark(group, mnt);
fs/notify/fanotify/fanotify_user.c:		fsnotify_recalc_vfsmount_mask(mnt);
fs/notify/fanotify/fanotify_user.c:	struct vfsmount *mnt = NULL;
fs/notify/fanotify/fanotify_user.c:			ret = fanotify_add_vfsmount_mark(group, mnt, mask, flags);
fs/notify/fanotify/fanotify_user.c:			ret = fanotify_remove_vfsmount_mark(group, mnt, mask, flags);
fs/notify/fanotify/fanotify_user.c:			fsnotify_clear_vfsmount_marks_by_group(group);
fs/notify/fanotify/fanotify_user.c: * error because we have compiled-in VFS hooks.  So an (unlikely) failure here
fs/notify/fanotify/fanotify.c:				       struct fsnotify_mark *vfsmnt_mark,
fs/notify/fanotify/fanotify.c:	pr_debug("%s: group=%p to_tell=%p inode_mark=%p vfsmnt_mark=%p "
fs/notify/fanotify/fanotify.c:		 inode_mark, vfsmnt_mark, event_mask, data, data_type);
fs/notify/fanotify/fanotify.c:	if (inode_mark && vfsmnt_mark) {
fs/notify/fanotify/fanotify.c:		marks_mask = (vfsmnt_mark->mask | inode_mark->mask);
fs/notify/fanotify/fanotify.c:		marks_ignored_mask = (vfsmnt_mark->ignored_mask | inode_mark->ignored_mask);
fs/notify/fanotify/fanotify.c:	} else if (vfsmnt_mark) {
fs/notify/fanotify/fanotify.c:		marks_mask = vfsmnt_mark->mask;
fs/notify/fanotify/fanotify.c:		marks_ignored_mask = vfsmnt_mark->ignored_mask;
fs/notify/fsnotify.h:/* protects reads of inode and vfsmount marks list */
fs/notify/fsnotify.h:/* add a mark to a vfsmount */
fs/notify/fsnotify.h:extern int fsnotify_add_vfsmount_mark(struct fsnotify_mark *mark,
fs/notify/fsnotify.h:				      struct fsnotify_group *group, struct vfsmount *mnt,
fs/notify/fsnotify.h:/* vfsmount specific destruction of a mark */
fs/notify/fsnotify.h:extern void fsnotify_destroy_vfsmount_mark(struct fsnotify_mark *mark);
fs/notify/fsnotify.h:/* run the list of all marks associated with vfsmount and flag them to be freed */
fs/notify/fsnotify.h:extern void fsnotify_clear_marks_by_mount(struct vfsmount *mnt);
fs/notify/Makefile:				   mark.o vfsmount_mark.o
fs/quota/quota_tree.h: *	Definitions of structures for vfsv0 quota format
fs/quota/quota_tree.c: *	vfsv0 quota IO operations on file
fs/quota/quota_tree.c:		       "VFS: Not enough memory for quota buffers.\n");
fs/quota/Kconfig:	tristate "Quota format vfsv0 and vfsv1 support"
fs/quota/Kconfig:	  This config option enables kernel support for vfsv0 and vfsv1 quota
fs/quota/Kconfig:	  formats. Both these formats support 32-bit UIDs/GIDs and vfsv1 format
fs/quota/quota.c: * Quota code necessary even when VFS quota support is not compiled
fs/quota/quota_v1.c:	       "VFS: %s: Refusing to turn on old quota format on given file."
fs/quota/quota_v1.c:	.qf_fmt_id	= QFMT_VFS_OLD,
fs/quota/quota_v2.c: *	vfsv0 quota IO operations on file
fs/quota/quota_v2.c:/* Check whether given file is really vfsv0 quotafile */
fs/quota/quota_v2.c:	if ((info->dqi_fmt_id == QFMT_VFS_V0 && version != 0) ||
fs/quota/quota_v2.c:	    (info->dqi_fmt_id == QFMT_VFS_V1 && version != 1))
fs/quota/quota_v2.c:	.qf_fmt_id	= QFMT_VFS_V0,
fs/quota/quota_v2.c:	.qf_fmt_id	= QFMT_VFS_V1,
fs/quota/dquot.c: * Lock ordering (including related VFS locks) is the following:
fs/quota/dquot.c:		/100) * sysctl_vfs_cache_pressure;
fs/quota/dquot.c:		printk(KERN_WARNING "VFS (%s): Writes happened after quota"
fs/quota/dquot.c:	       (info->dqi_format->qf_fmt_id != QFMT_VFS_OLD ||
fs/quota/dquot.c:static int vfs_load_quota_inode(struct inode *inode, int type, int format_id,
fs/quota/dquot.c:		ret = vfs_load_quota_inode(inode, cnt,
fs/quota/dquot.c:		error = vfs_load_quota_inode(path->dentry->d_inode, type,
fs/quota/dquot.c:	return vfs_load_quota_inode(inode, type, format_id, flags);
fs/quota/dquot.c:		error = vfs_load_quota_inode(dentry->d_inode, type, format_id,
fs/quota/dquot.c:#define VFS_FS_DQ_MASK \
fs/quota/dquot.c:	if (di->d_fieldmask & ~VFS_FS_DQ_MASK)
fs/quota/dquot.c:	printk(KERN_NOTICE "VFS: Disk quotas %s\n", __DQUOT_VERSION__);
fs/quota/quotaio_v2.h: *	Definitions of structures for vfsv0 quota format
fs/quota/netlink.c:	.name = "VFS_DQUOT",
fs/quota/netlink.c:		  "VFS: Not enough memory to send quota warning.\n");
fs/quota/netlink.c:		  "VFS: Cannot store netlink header in quota warning.\n");
fs/quota/netlink.c:	printk(KERN_ERR "VFS: Not enough space to compose quota message!\n");
fs/quota/netlink.c:		       "VFS: Failed to create quota netlink interface.\n");
fs/squashfs/id.c:#include <linux/vfs.h>
fs/squashfs/squashfs_fs_i.h:	struct inode	vfs_inode;
fs/squashfs/squashfs_fs_i.h:	return list_entry(inode, struct squashfs_inode_info, vfs_inode);
fs/squashfs/super.c: * in-memory structures at mount time, and all the VFS glue code to register
fs/squashfs/super.c:#include <linux/vfs.h>
fs/squashfs/super.c:	inode_init_once(&ei->vfs_inode);
fs/squashfs/super.c:	return ei ? &ei->vfs_inode : NULL;
fs/squashfs/dir.c:#include <linux/vfs.h>
fs/squashfs/inode.c:#include <linux/vfs.h>
fs/squashfs/inode.c: * Initialise VFS inode with the base inode information common to all
fs/squashfs/inode.c: * Initialise VFS inode by reading inode from inode table (compressed
fs/squashfs/cache.c:#include <linux/vfs.h>
fs/squashfs/export.c:#include <linux/vfs.h>
fs/squashfs/file.c:#include <linux/vfs.h>
fs/squashfs/block.c:#include <linux/vfs.h>
fs/squashfs/xattr_id.c:#include <linux/vfs.h>
fs/squashfs/namei.c:#include <linux/vfs.h>
fs/squashfs/symlink.c:#include <linux/vfs.h>
fs/squashfs/fragment.c:#include <linux/vfs.h>
fs/squashfs/xattr.c:#include <linux/vfs.h>
fs/pipe.c:static struct vfsmount *pipe_mnt __read_mostly;
fs/nfs/namespace.c:#include <linux/vfs.h>
fs/nfs/namespace.c:#define NFSDBG_FACILITY		NFSDBG_VFS
fs/nfs/namespace.c:static struct vfsmount *nfs_do_submount(struct dentry *dentry,
fs/nfs/namespace.c:struct vfsmount *nfs_d_automount(struct path *path)
fs/nfs/namespace.c:	struct vfsmount *mnt;
fs/nfs/namespace.c:nfs_namespace_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
fs/nfs/namespace.c:static struct vfsmount *nfs_do_clone_mount(struct nfs_server *server,
fs/nfs/namespace.c:	struct vfsmount *mnt = ERR_PTR(-EINVAL);
fs/nfs/namespace.c:			mnt = vfs_kern_mount(&nfs_xdev_fs_type, 0, devname, mountdata);
fs/nfs/namespace.c:			mnt = vfs_kern_mount(&nfs4_xdev_fs_type, 0, devname, mountdata);
fs/nfs/namespace.c:	return vfs_kern_mount(&nfs_xdev_fs_type, 0, devname, mountdata);
fs/nfs/namespace.c:static struct vfsmount *nfs_do_submount(struct dentry *dentry,
fs/nfs/namespace.c:	struct vfsmount *mnt = ERR_PTR(-ENOMEM);
fs/nfs/namespace.c:	mnt = (struct vfsmount *)devname;
fs/nfs/nfs4proc.c: * after the sys_close call (which hits the vfs layer as a flush).
fs/nfs/nfs4proc.c: * VFS layer lookup-intents are implemented.
fs/nfs/nfs4proc.c: * This will be fixed with VFS changes (lookup-intent).
fs/nfs/nfs4proc.c: * We will need to arrange for the VFS layer to provide an atomic open.
fs/nfs/nfs4proc.c: * conditions due to the lookup, create, and open VFS calls from sys_open()
fs/nfs/nfs4proc.c: * The file will be opened again in the subsequent VFS open call
fs/nfs/nfs4proc.c: * opens the file O_RDONLY. This will all be resolved with the VFS changes.
fs/nfs/nfs4proc.c:static int do_vfs_lock(struct file *file, struct file_lock *fl)
fs/nfs/nfs4proc.c:	if (do_vfs_lock(request->fl_file, request) == -ENOENT) {
fs/nfs/nfs4proc.c:	status = do_vfs_lock(request->fl_file, request);
fs/nfs/nfs4proc.c:		status = do_vfs_lock(request->fl_file, request);
fs/nfs/nfs4proc.c:	if (do_vfs_lock(request->fl_file, request) < 0)
fs/nfs/nfs4proc.c:		printk(KERN_WARNING "NFS: %s: VFS is out of sync with lock "
fs/nfs/nfs4proc.c:	 * Don't rely on the VFS having checked the file open mode,
fs/nfs/nfs4xdr.c:	 * and and null-terminate the text (the VFS expects
fs/nfs/pnfs.c:	spin_lock(&nfsi->vfs_inode.i_lock);
fs/nfs/pnfs.c:	spin_unlock(&nfsi->vfs_inode.i_lock);
fs/nfs/pnfs.c:	spin_lock(&nfsi->vfs_inode.i_lock);
fs/nfs/pnfs.c:	spin_unlock(&nfsi->vfs_inode.i_lock);
fs/nfs/super.c:#include <linux/vfs.h>
fs/nfs/super.c:#define NFSDBG_FACILITY		NFSDBG_VFS
fs/nfs/super.c: * Describe the mount options on this VFS mountpoint
fs/nfs/super.c: * Present statistical information for this VFS mountpoint
fs/nfs/super.c:		/* The VFS shouldn't apply the umask to mode bits. We will do
fs/nfs/super.c:		/* The VFS shouldn't apply the umask to mode bits. We will do
fs/nfs/super.c:	 * The VFS shouldn't apply the umask to mode bits. We will do
fs/nfs/super.c:	 * The VFS shouldn't apply the umask to mode bits. We will do
fs/nfs/super.c:static struct vfsmount *nfs_do_root_mount(struct file_system_type *fs_type,
fs/nfs/super.c:	struct vfsmount *root_mnt;
fs/nfs/super.c:	root_mnt = vfs_kern_mount(fs_type, flags, root_devname, data);
fs/nfs/super.c:static struct dentry *nfs_follow_remote_path(struct vfsmount *root_mnt,
fs/nfs/super.c:	struct vfsmount *root_mnt;
fs/nfs/super.c:	struct vfsmount *root_mnt;
fs/nfs/direct.c: * 31 Mar 2004	Handle direct I/O without VFS support  --cel
fs/nfs/direct.c:#define NFSDBG_FACILITY		NFSDBG_VFS
fs/nfs/direct.c: * read and write requests before the VFS gets them, so this method
fs/nfs/client.c:#include <linux/vfs.h>
fs/nfs/fscache-index.c:	*size = nfsi->vfs_inode.i_size;
fs/nfs/fscache-index.c:	auxdata.size = nfsi->vfs_inode.i_size;
fs/nfs/fscache-index.c:	auxdata.mtime = nfsi->vfs_inode.i_mtime;
fs/nfs/fscache-index.c:	auxdata.ctime = nfsi->vfs_inode.i_ctime;
fs/nfs/fscache-index.c:	if (NFS_SERVER(&nfsi->vfs_inode)->nfs_client->rpc_ops->version == 4)
fs/nfs/fscache-index.c:		auxdata.change_attr = nfsi->vfs_inode.i_version;
fs/nfs/fscache-index.c:	auxdata.size = nfsi->vfs_inode.i_size;
fs/nfs/fscache-index.c:	auxdata.mtime = nfsi->vfs_inode.i_mtime;
fs/nfs/fscache-index.c:	auxdata.ctime = nfsi->vfs_inode.i_ctime;
fs/nfs/fscache-index.c:	if (NFS_SERVER(&nfsi->vfs_inode)->nfs_client->rpc_ops->version == 4)
fs/nfs/fscache-index.c:		auxdata.change_attr = nfsi->vfs_inode.i_version;
fs/nfs/fscache-index.c:					  nfsi->vfs_inode.i_mapping,
fs/nfs/dir.c:	nfs_inc_stats(inode, NFSIOS_VFSOPEN);
fs/nfs/dir.c:	nfs_inc_stats(inode, NFSIOS_VFSGETDENTS);
fs/nfs/dir.c:	nfs_inc_stats(dentry->d_inode, NFSIOS_VFSFSYNC);
fs/nfs/dir.c: * We force revalidation in the cases where the VFS sets LOOKUP_REVAL,
fs/nfs/dir.c:		/* VFS wants an on-the-wire revalidation */
fs/nfs/dir.c:	dfprintk(VFS, "NFS: dentry_delete(%s/%s, %x)\n",
fs/nfs/dir.c:	dfprintk(VFS, "NFS: lookup(%s/%s)\n",
fs/nfs/dir.c:	nfs_inc_stats(dir, NFSIOS_VFSLOOKUP);
fs/nfs/dir.c:	dfprintk(VFS, "NFS: atomic_lookup(%s/%ld), %s\n",
fs/nfs/dir.c:	/* Let vfs_create() deal with O_EXCL. Instantiate, but don't hash
fs/nfs/dir.c:	dfprintk(VFS, "NFS: create(%s/%ld), %s\n",
fs/nfs/dir.c:	dfprintk(VFS, "NFS: create(%s/%ld), %s\n",
fs/nfs/dir.c:	dfprintk(VFS, "NFS: mknod(%s/%ld), %s\n",
fs/nfs/dir.c:	dfprintk(VFS, "NFS: mkdir(%s/%ld), %s\n",
fs/nfs/dir.c:	dfprintk(VFS, "NFS: rmdir(%s/%ld), %s\n",
fs/nfs/dir.c:	/* Ensure the VFS deletes this inode */
fs/nfs/dir.c:	dfprintk(VFS, "NFS: safe_remove(%s/%s)\n",
fs/nfs/dir.c:	dfprintk(VFS, "NFS: unlink(%s/%ld, %s)\n", dir->i_sb->s_id,
fs/nfs/dir.c:	dfprintk(VFS, "NFS: symlink(%s/%ld, %s, %s)\n", dir->i_sb->s_id,
fs/nfs/dir.c:		dfprintk(VFS, "NFS: symlink(%s/%ld, %s, %s) error %d\n",
fs/nfs/dir.c:	dfprintk(VFS, "NFS: link(%s/%s -> %s/%s)\n",
fs/nfs/dir.c:	dfprintk(VFS, "NFS: rename(%s/%s -> %s/%s, ct=%d)\n",
fs/nfs/dir.c:		inode = &nfsi->vfs_inode;
fs/nfs/dir.c:	return (atomic_long_read(&nfs_access_nr_entries) / 100) * sysctl_vfs_cache_pressure;
fs/nfs/dir.c:	nfs_inc_stats(inode, NFSIOS_VFSACCESS);
fs/nfs/dir.c:	dfprintk(VFS, "NFS: permission(%s/%ld), mask=0x%x, res=%d\n",
fs/nfs/read.c:	nfs_inc_stats(inode, NFSIOS_VFSREADPAGE);
fs/nfs/read.c:	nfs_inc_stats(inode, NFSIOS_VFSREADPAGES);
fs/nfs/inode.c:#include <linux/vfs.h>
fs/nfs/inode.c:#define NFSDBG_FACILITY		NFSDBG_VFS
fs/nfs/inode.c:	nfs_inc_stats(inode, NFSIOS_VFSSETATTR);
fs/nfs/inode.c:int nfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
fs/nfs/inode.c:	 * Note that we only have to check the vfsmount flags here:
fs/nfs/inode.c:	dfprintk(VFS, "NFS: %s(%s/%ld fh_crc=0x%08x ct=%d info=0x%x)\n",
fs/nfs/inode.c:	return &nfsi->vfs_inode;
fs/nfs/inode.c:	inode_init_once(&nfsi->vfs_inode);
fs/nfs/unlink.c:	dfprintk(VFS, "NFS: silly-rename(%s/%s, ct=%d)\n",
fs/nfs/unlink.c:		dfprintk(VFS, "NFS: trying to rename %s to %s\n",
fs/nfs/write.c:	nfs_inc_stats(inode, NFSIOS_VFSWRITEPAGE);
fs/nfs/write.c:	nfs_inc_stats(inode, NFSIOS_VFSWRITEPAGES);
fs/nfs/write.c:	nfs_inc_stats(inode, NFSIOS_VFSUPDATEPAGE);
fs/nfs/nfs4namespace.c:#include <linux/vfs.h>
fs/nfs/nfs4namespace.c:#define NFSDBG_FACILITY		NFSDBG_VFS
fs/nfs/nfs4namespace.c:static struct vfsmount *try_location(struct nfs_clone_mount *mountdata,
fs/nfs/nfs4namespace.c:	struct vfsmount *mnt = ERR_PTR(-ENOENT);
fs/nfs/nfs4namespace.c:		mnt = vfs_kern_mount(&nfs4_referral_fs_type, 0, page, mountdata);
fs/nfs/nfs4namespace.c:static struct vfsmount *nfs_follow_referral(struct dentry *dentry,
fs/nfs/nfs4namespace.c:	struct vfsmount *mnt = ERR_PTR(-ENOENT);
fs/nfs/nfs4namespace.c:struct vfsmount *nfs_do_refmount(struct rpc_clnt *client, struct dentry *dentry)
fs/nfs/nfs4namespace.c:	struct vfsmount *mnt = ERR_PTR(-ENOMEM);
fs/nfs/internal.h:extern struct vfsmount *nfs_do_refmount(struct rpc_clnt *client, struct dentry *dentry);
fs/nfs/internal.h:struct vfsmount *nfs_do_refmount(struct rpc_clnt *client, struct dentry *dentry)
fs/nfs/internal.h:extern struct vfsmount *nfs_d_automount(struct path *path);
fs/nfs/file.c:	nfs_inc_stats(inode, NFSIOS_VFSOPEN);
fs/nfs/file.c:	nfs_inc_stats(inode, NFSIOS_VFSRELEASE);
fs/nfs/file.c:	nfs_inc_stats(inode, NFSIOS_VFSFLUSH);
fs/nfs/file.c:	return vfs_fsync(file, 0);
fs/nfs/file.c:	nfs_inc_stats(inode, NFSIOS_VFSFSYNC);
fs/nfs/file.c:		int err = vfs_fsync(iocb->ki_filp, 0);
fs/nfs/file.c:		int err = vfs_fsync(filp, 0);
fs/nfs/file.c:static int do_vfs_lock(struct file *file, struct file_lock *fl)
fs/nfs/file.c:		status = do_vfs_lock(filp, fl);
fs/nfs/file.c:		status = do_vfs_lock(filp, fl);
fs/nfs/file.c:	nfs_inc_stats(inode, NFSIOS_VFSLOCK);
fs/nfs/getroot.c:#include <linux/vfs.h>
fs/sdcardfs/super.c: * vfs inode.
fs/sdcardfs/super.c:	err = vfs_statfs(&lower_path, buf);
fs/sdcardfs/super.c:	 * The VFS will take care of "ro" and "rw" flags among others.  We
fs/sdcardfs/super.c:	memset(i, 0, offsetof(struct sdcardfs_inode_info, vfs_inode));
fs/sdcardfs/super.c:	i->vfs_inode.i_version = 1;
fs/sdcardfs/super.c:	return &i->vfs_inode;
fs/sdcardfs/super.c:	inode_init_once(&i->vfs_inode);
fs/sdcardfs/dentry.c: *          0: tell VFS to invalidate dentry
fs/sdcardfs/sdcardfs.h:	struct inode vfs_inode;
fs/sdcardfs/sdcardfs.h:	return container_of(inode, struct sdcardfs_inode_info, vfs_inode);
fs/sdcardfs/sdcardfs.h:	err = vfs_mkdir(path.dentry->d_inode, dent, mode);
fs/sdcardfs/sdcardfs.h:		err = vfs_statfs(&lower_path, &statfs);
fs/sdcardfs/sdcardfs.h:	printk(KERN_INFO "vfs_statfs error#    : %d\n", err);
fs/sdcardfs/inode.c:	err = vfs_create(lower_parent_dentry->d_inode, lower_dentry, mode, nd);
fs/sdcardfs/inode.c:	err = vfs_link(lower_old_dentry, lower_dir_dentry->d_inode,
fs/sdcardfs/inode.c:	err = vfs_unlink(lower_dir_inode, lower_dentry);
fs/sdcardfs/inode.c:	d_drop(dentry); /* this is needed, else LTP fails (VFS won't do it) */
fs/sdcardfs/inode.c:	err = vfs_symlink(lower_parent_dentry->d_inode, lower_dentry, symname);
fs/sdcardfs/inode.c:	err = vfs_mkdir(lower_parent_dentry->d_inode, lower_dentry, mode);
fs/sdcardfs/inode.c:	err = vfs_rmdir(lower_dir_dentry->d_inode, lower_dentry);
fs/sdcardfs/inode.c:	d_drop(dentry);	/* drop our dentry on success (why not VFS's job?) */
fs/sdcardfs/inode.c:	err = vfs_mknod(lower_parent_dentry->d_inode, lower_dentry, mode, dev);
fs/sdcardfs/inode.c:	err = vfs_rename(lower_old_dir_dentry->d_inode, lower_old_dentry,
fs/sdcardfs/inode.c:	 * such as vfs_create, vfs_unlink, vfs_rename, and etc, 
fs/sdcardfs/inode.c:static int sdcardfs_getattr(struct vfsmount *mnt, struct dentry *dentry,
fs/sdcardfs/inode.c:	/* no vfs_XXX operations required, cred overriding will be skipped. wj*/
fs/sdcardfs/inode.c:	 * VFS should update our inode size, and notify_change on
fs/sdcardfs/lookup.c:	struct vfsmount *lower_dir_mnt;
fs/sdcardfs/lookup.c:	/* Use vfs_path_lookup to check if the dentry exists or not */
fs/sdcardfs/lookup.c:		err = vfs_path_lookup(lower_dir_dentry, lower_dir_mnt, name,
fs/sdcardfs/lookup.c:		err = vfs_path_lookup(lower_dir_dentry, lower_dir_mnt, name, 0,
fs/sdcardfs/lookup.c:	 * the VFS will continue the process of making this negative dentry
fs/sdcardfs/file.c:	err = vfs_read(lower_file, buf, count, ppos);
fs/sdcardfs/file.c:	err = vfs_write(lower_file, buf, count, ppos);
fs/sdcardfs/file.c:	err = vfs_readdir(lower_file, filldir, dirent);
fs/sdcardfs/file.c:	/* XXX: use vfs_ioctl if/when VFS exports it */
fs/sdcardfs/file.c:	/* XXX: use vfs_ioctl if/when VFS exports it */
fs/sdcardfs/file.c:	 * XXX: the VFS should have a cleaner way of finding the lower vm_ops
fs/sdcardfs/file.c:	err = vfs_fsync_range(lower_file, start, end, datasync);
fs/sdcardfs/xattr.c:	rc = vfs_setxattr(lower_dentry, name, value, size, flags);
fs/stat.c:int vfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
fs/stat.c:EXPORT_SYMBOL(vfs_getattr);
fs/stat.c:int vfs_fstat(unsigned int fd, struct kstat *stat)
fs/stat.c:		error = vfs_getattr(f->f_path.mnt, f->f_path.dentry, stat);
fs/stat.c:EXPORT_SYMBOL(vfs_fstat);
fs/stat.c:int vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,
fs/stat.c:	error = vfs_getattr(path.mnt, path.dentry, stat);
fs/stat.c:EXPORT_SYMBOL(vfs_fstatat);
fs/stat.c:int vfs_stat(const char __user *name, struct kstat *stat)
fs/stat.c:	return vfs_fstatat(AT_FDCWD, name, stat, 0);
fs/stat.c:EXPORT_SYMBOL(vfs_stat);
fs/stat.c:int vfs_lstat(const char __user *name, struct kstat *stat)
fs/stat.c:	return vfs_fstatat(AT_FDCWD, name, stat, AT_SYMLINK_NOFOLLOW);
fs/stat.c:EXPORT_SYMBOL(vfs_lstat);
fs/stat.c:		printk(KERN_WARNING "VFS: Warning: %s using old stat() call. Recompile your binary.\n",
fs/stat.c:	error = vfs_stat(filename, &stat);
fs/stat.c:	error = vfs_lstat(filename, &stat);
fs/stat.c:	int error = vfs_fstat(fd, &stat);
fs/stat.c:	int error = vfs_stat(filename, &stat);
fs/stat.c:	error = vfs_lstat(filename, &stat);
fs/stat.c:	error = vfs_fstatat(dfd, filename, &stat, flag);
fs/stat.c:	int error = vfs_fstat(fd, &stat);
fs/stat.c:	int error = vfs_stat(filename, &stat);
fs/stat.c:	int error = vfs_lstat(filename, &stat);
fs/stat.c:	int error = vfs_fstat(fd, &stat);
fs/stat.c:	error = vfs_fstatat(dfd, filename, &stat, flag);
fs/isofs/isofs.h:	struct inode vfs_inode;
fs/isofs/isofs.h:	return container_of(inode, struct iso_inode_info, vfs_inode);
fs/isofs/inode.c:	return &ei->vfs_inode;
fs/isofs/inode.c:	inode_init_once(&ei->vfs_inode);
fs/sync.c: * vfs_fsync_range - helper to sync a range of data & metadata to disk
fs/sync.c:int vfs_fsync_range(struct file *file, loff_t start, loff_t end, int datasync)
fs/sync.c:EXPORT_SYMBOL(vfs_fsync_range);
fs/sync.c: * vfs_fsync - perform a fsync or fdatasync on a file
fs/sync.c:int vfs_fsync(struct file *file, int datasync)
fs/sync.c:	return vfs_fsync_range(file, 0, LLONG_MAX, datasync);
fs/sync.c:EXPORT_SYMBOL(vfs_fsync);
fs/sync.c:		ret = vfs_fsync(file, datasync);
fs/sync.c:	return vfs_fsync_range(file, pos, pos + count - 1,
fs/ocfs2/file.h:int ocfs2_getattr(struct vfsmount *mnt, struct dentry *dentry,
fs/ocfs2/file.h:			      struct vfsmount *vfsmnt);
fs/ocfs2/journal.c: * the inodes in the orphan dir and iget/iput them. The VFS does
fs/ocfs2/dlmglue.h:			  struct vfsmount *vfsmnt,
fs/ocfs2/quota.h:	struct dquot dq_dquot;	/* Generic VFS dquot */
fs/ocfs2/super.c:	jbd2_journal_init_jbd_inode(&oi->ip_jinode, &oi->vfs_inode);
fs/ocfs2/super.c:	return &oi->vfs_inode;
fs/ocfs2/super.c:	 * that's what we expose to the VFS.
fs/ocfs2/super.c:	ocfs2_extent_map_init(&oi->vfs_inode);
fs/ocfs2/super.c:	ocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),
fs/ocfs2/super.c:	inode_init_once(&oi->vfs_inode);
fs/ocfs2/mmap.c:				    file->f_vfsmnt, &lock_level);
fs/ocfs2/dlmfs/userdlm.h:	struct inode         ip_vfs_inode;
fs/ocfs2/dlmfs/userdlm.h:			    ip_vfs_inode);
fs/ocfs2/dlmfs/dlmfs.c:/* Simple VFS hooks based on: */
fs/ocfs2/dlmfs/dlmfs.c:	inode_init_once(&ip->ip_vfs_inode);
fs/ocfs2/dlmfs/dlmfs.c:	return &ip->ip_vfs_inode;
fs/ocfs2/dlmfs/userdlm.c:	return &ip->ip_vfs_inode;
fs/ocfs2/dir.c:	error = ocfs2_inode_lock_atime(inode, filp->f_vfsmnt, &lock_level);
fs/ocfs2/refcounttree.c: * sys_reflink().  This will go away when vfs_reflink() exists in
fs/ocfs2/refcounttree.c:/* copied from may_create in VFS. */
fs/ocfs2/refcounttree.c: * ocfs2_vfs_reflink - Create a reference-counted link
fs/ocfs2/refcounttree.c:static int ocfs2_vfs_reflink(struct dentry *old_dentry, struct inode *dir,
fs/ocfs2/refcounttree.c:	error = ocfs2_vfs_reflink(old_path.dentry,
fs/ocfs2/inode.h:	struct inode			vfs_inode;
fs/ocfs2/inode.h:	return container_of(inode, struct ocfs2_inode_info, vfs_inode);
fs/ocfs2/stack_user.c: * mount path.  Since the VFS prevents multiple calls to
fs/ocfs2/inode.c: * vfs' aops, fops, dops and iops
fs/ocfs2/inode.c:	unsigned int flags = oi->vfs_inode.i_flags;
fs/ocfs2/inode.c:	return oi->vfs_inode.i_sb;
fs/ocfs2/dlmglue.c: * code that aop methods pass up to the VFS -- test for errors with != 0. **
fs/ocfs2/dlmglue.c: * that called us can bubble that back up into the VFS who will then
fs/ocfs2/dlmglue.c: * the lock has a great chance of being cached on this node by the time the VFS
fs/ocfs2/dlmglue.c:			  struct vfsmount *vfsmnt,
fs/ocfs2/dlmglue.c:	if (ocfs2_should_update_atime(inode, vfsmnt)) {
fs/ocfs2/dlmglue.c:		if (ocfs2_should_update_atime(inode, vfsmnt))
fs/ocfs2/alloc.c:	struct inode *inode = &cache_info_to_inode(et->et_ci)->vfs_inode;
fs/ocfs2/alloc.c:	struct inode *inode = &cache_info_to_inode(et->et_ci)->vfs_inode;
fs/ocfs2/alloc.c:	struct ocfs2_super *osb = OCFS2_SB(oi->vfs_inode.i_sb);
fs/ocfs2/dcache.c: * Normally, the VFS handles the d_move() for the file system, after
fs/ocfs2/file.c:			      struct vfsmount *vfsmnt)
fs/ocfs2/file.c:	 * We can be called with no vfsmnt structure - NFSD will
fs/ocfs2/file.c:	if (vfsmnt == NULL)
fs/ocfs2/file.c:	if ((vfsmnt->mnt_flags & MNT_NOATIME) ||
fs/ocfs2/file.c:	    ((vfsmnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode)))
fs/ocfs2/file.c:	if (vfsmnt->mnt_flags & MNT_RELATIME) {
fs/ocfs2/file.c:int ocfs2_getattr(struct vfsmount *mnt,
fs/ocfs2/file.c:	vfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);
fs/ocfs2/file.c:	ret = ocfs2_inode_lock_atime(inode, in->f_vfsmnt, &lock_level);
fs/ocfs2/file.c:	ret = ocfs2_inode_lock_atime(inode, filp->f_vfsmnt, &lock_level);
fs/ocfs2/namei.c:	 * And that's why, just like the VFS, we need a file system
fs/ocfs2/namei.c:		/* VFS didn't think there existed an inode here, but
fs/ocfs2/symlink.c:	 * Without vfsmount we can't update atime now,
fs/ocfs2/symlink.c:	ret = vfs_readlink(dentry, buffer, buflen, link);
fs/configfs/dir.c: * try using vfs_mkdir.  Just a thought.
fs/configfs/dir.c: * configfs_attach_group()) can be called from either the VFS or this
fs/configfs/dir.c: * had never been called.  The caller (VFS or local function) will
fs/configfs/dir.c:			 * the VFS may already have hit and used them. Thus,
fs/configfs/dir.c:		 * We must lock the group's inode to avoid races with the VFS
fs/configfs/dir.c: * Why is the locking complex?  Because configfs uses the VFS to handle
fs/configfs/dir.c: * VFS->configfs path.  So it must take VFS locks to prevent the
fs/configfs/dir.c: * VFS->configfs stuff (configfs_mkdir(), configfs_rmdir(), etc).  This is
fs/configfs/mount.c:static struct vfsmount *configfs_mount = NULL;
fs/anon_inodes.c:static struct vfsmount *anon_inode_mnt __read_mostly;
fs/proc_namespace.c:	br_read_lock(vfsmount_lock);
fs/proc_namespace.c:	br_read_unlock(vfsmount_lock);
fs/proc_namespace.c:static void show_mnt_opts(struct seq_file *m, struct vfsmount *mnt)
fs/proc_namespace.c:static int show_vfsmnt(struct seq_file *m, struct vfsmount *mnt)
fs/proc_namespace.c:static int show_mountinfo(struct seq_file *m, struct vfsmount *mnt)
fs/proc_namespace.c:static int show_vfsstat(struct seq_file *m, struct vfsmount *mnt)
fs/proc_namespace.c:			      int (*show)(struct seq_file *, struct vfsmount *))
fs/proc_namespace.c:	return mounts_open_common(inode, file, show_vfsmnt);
fs/proc_namespace.c:	return mounts_open_common(inode, file, show_vfsstat);
fs/readdir.c:int vfs_readdir(struct file *file, filldir_t filler, void *buf)
fs/readdir.c:EXPORT_SYMBOL(vfs_readdir);
fs/readdir.c:	error = vfs_readdir(file, fillonedir, &buf);
fs/readdir.c:	error = vfs_readdir(file, filldir, &buf);
fs/readdir.c:	error = vfs_readdir(file, filldir64, &buf);
fs/gfs2/ops_fstype.c:	sdp->sd_vfs = sb;
fs/gfs2/ops_fstype.c:	struct super_block *s = sdp->sd_vfs;
fs/gfs2/ops_fstype.c:	struct super_block *sb = sdp->sd_vfs;
fs/gfs2/ops_fstype.c:		table = sdp->sd_vfs->s_id;
fs/gfs2/ops_fstype.c:	struct super_block *sb = sdp->sd_vfs;
fs/gfs2/ops_fstype.c:	struct super_block *sb = sdp->sd_vfs;
fs/gfs2/ops_fstype.c: * @sb: The VFS superblock
fs/gfs2/lops.c:	bh = sb_getblk(sdp->sd_vfs, blkno);
fs/gfs2/lops.c:	bh->b_bdev = sdp->sd_vfs->s_bdev;
fs/gfs2/quota.c:	return (atomic_read(&qd_lru_count) * sysctl_vfs_cache_pressure) / 100;
fs/gfs2/quota.c:	if (sdp->sd_vfs->s_flags & MS_RDONLY)
fs/gfs2/quota.c:	if (sdp->sd_vfs->s_flags & MS_RDONLY)
fs/gfs2/quota.c:					   sdp->sd_vfs->s_dev, QUOTA_NL_BHARDWARN);
fs/gfs2/quota.c:					   sdp->sd_vfs->s_dev, QUOTA_NL_BSOFTWARN);
fs/gfs2/quota.c:		int error = fxn(sdp->sd_vfs, 0);
fs/gfs2/quota.c:			int error = gfs2_statfs_sync(sdp->sd_vfs, 0);
fs/gfs2/aops.c:		gfs2_page_add_databufs(ip, page, 0, sdp->sd_vfs->s_blocksize-1);
fs/gfs2/aops.c: * @copied: How much was actually copied by the VFS
fs/gfs2/aops.c: * put our locking around the VFS provided functions.
fs/gfs2/aops.c:	 * the VFS does.
fs/gfs2/aops.c: * @gfp_mask: passed from Linux VFS, ignored by us
fs/gfs2/super.c:	gfs2_quota_sync(sdp->sd_vfs, 0, 1);
fs/gfs2/super.c:	gfs2_statfs_sync(sdp->sd_vfs, 0);
fs/gfs2/super.c: * @sb: The VFS superblock
fs/gfs2/super.c: * @sb: the VFS structure for the filesystem
fs/gfs2/super.c: * @sb: the VFS structure for the filesystem
fs/gfs2/glock.c:		inode = gfs2_ilookup(sdp->sd_vfs, no_addr, 1);
fs/gfs2/glock.c:	struct super_block *s = sdp->sd_vfs;
fs/gfs2/glock.c:	return (atomic_read(&lru_count) / 100) * sysctl_vfs_cache_pressure;
fs/gfs2/glops.c:	if (sdp->sd_vfs->s_flags & MS_RDONLY)
fs/gfs2/recovery.c:	bh = sb_getblk(sdp->sd_vfs, bh_map.b_blocknr);
fs/gfs2/recovery.c:			if (sdp->sd_vfs->s_flags & MS_RDONLY) {
fs/gfs2/recovery.c:				ro = bdev_read_only(sdp->sd_vfs->s_bdev);
fs/gfs2/incore.h:	unsigned int ar_localflocks:1;		/* Let the VFS do flock|fcntl */
fs/gfs2/incore.h:	struct super_block *sd_vfs;
fs/gfs2/meta_io.c:		map_bh(bh, sdp->sd_vfs, blkno);
fs/gfs2/log.c:	unsigned reserved_blks = 6 * (4096 / sdp->sd_vfs->s_blocksize);
fs/gfs2/log.c:	bh = sb_getblk(sdp->sd_vfs, blkno);
fs/gfs2/trans.c:	if (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)
fs/gfs2/rgrp.c:	struct super_block *sb = sdp->sd_vfs;
fs/gfs2/rgrp.c:	struct request_queue *q = bdev_get_queue(sdp->sd_vfs->s_bdev);
fs/gfs2/inode.c: * GFS2 lookup code fills in vfs inode contents based on info obtained
fs/gfs2/inode.c: * Returns: A VFS inode, or an error
fs/gfs2/inode.c:	struct super_block *sb = sdp->sd_vfs;
fs/gfs2/inode.c:	/* gfs2_lookupi has inconsistent callers: vfs
fs/gfs2/inode.c: * This can be called via the VFS filldir function when NFS is doing
fs/gfs2/inode.c: * @nd: passed from Linux VFS, ignored by us
fs/gfs2/inode.c: * Called by the VFS layer. Lock dir and call gfs2_lookupi()
fs/gfs2/inode.c: * @nd: Data that we pass to vfs_follow_link()
fs/gfs2/inode.c: * This may be called from the VFS directly, or from within GFS2 with the
fs/gfs2/inode.c: * The VFS layer wants to change one or more of an inodes attributes.  Write
fs/gfs2/inode.c: * @mnt: The vfsmount the inode is being accessed from
fs/gfs2/inode.c: * This may be called from the VFS directly, or from within GFS2 with the
fs/gfs2/inode.c:static int gfs2_getattr(struct vfsmount *mnt, struct dentry *dentry,
fs/gfs2/sys.c:			MAJOR(sdp->sd_vfs->s_dev), MINOR(sdp->sd_vfs->s_dev));
fs/gfs2/sys.c:	struct super_block *s = sdp->sd_vfs;
fs/gfs2/sys.c:	gfs2_statfs_sync(sdp->sd_vfs, 0);
fs/gfs2/sys.c:	gfs2_quota_sync(sdp->sd_vfs, 0, 1);
fs/gfs2/sys.c:	struct super_block *sb = sdp->sd_vfs;
fs/gfs2/sys.c:	struct super_block *s = sdp->sd_vfs;
fs/gfs2/file.c:	vfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);
fs/gfs2/trace_gfs2.h:		__entry->dev		= gl->gl_sbd->sd_vfs->s_dev;
fs/gfs2/trace_gfs2.h:		__entry->dev		= gl->gl_sbd->sd_vfs->s_dev;
fs/gfs2/trace_gfs2.h:		__entry->dev		= gl->gl_sbd->sd_vfs->s_dev;
fs/gfs2/trace_gfs2.h:		__entry->dev	= gh->gh_gl->gl_sbd->sd_vfs->s_dev;
fs/gfs2/trace_gfs2.h:		__entry->dev	= gh->gh_gl->gl_sbd->sd_vfs->s_dev;
fs/gfs2/trace_gfs2.h:		__entry->dev            = gl->gl_sbd->sd_vfs->s_dev;
fs/gfs2/trace_gfs2.h:		__entry->dev		= bd->bd_gl->gl_sbd->sd_vfs->s_dev;
fs/gfs2/trace_gfs2.h:		__entry->dev            = sdp->sd_vfs->s_dev;
fs/gfs2/trace_gfs2.h:		__entry->dev		= sdp->sd_vfs->s_dev;
fs/gfs2/trace_gfs2.h:		__entry->dev		= sdp->sd_vfs->s_dev;
fs/gfs2/trace_gfs2.h:		__entry->dev            = ip->i_gl->gl_sbd->sd_vfs->s_dev;
fs/gfs2/trace_gfs2.h:		__entry->dev		= ip->i_gl->gl_sbd->sd_vfs->s_dev;
fs/gfs2/bmap.c:	struct super_block *sb = sdp->sd_vfs;
fs/gfs2/xattr.c: * This is not called directly by the VFS since we use the (common)
fs/efs/super.c:#include <linux/vfs.h>
fs/efs/super.c:	return &ei->vfs_inode;
fs/efs/super.c:	inode_init_once(&ei->vfs_inode);
fs/efs/efs.h:	struct inode	vfs_inode;
fs/efs/efs.h:	return container_of(inode, struct efs_inode_info, vfs_inode);
fs/ext4/super.c:#include <linux/vfs.h>
fs/ext4/super.c:		vfs_check_frozen(sb, SB_FREEZE_TRANS);
fs/ext4/super.c: * hook in del_gendisk() to inform the VFS and file system layers.
fs/ext4/super.c:	return &list_entry(l, struct ext4_inode_info, i_orphan)->vfs_inode;
fs/ext4/super.c:	ei->vfs_inode.i_version = 1;
fs/ext4/super.c:	ei->vfs_inode.i_data.writeback_index = 0;
fs/ext4/super.c:	return &ei->vfs_inode;
fs/ext4/super.c:	inode_init_once(&ei->vfs_inode);
fs/ext4/super.c:	Opt_jqfmt_vfsold, Opt_jqfmt_vfsv0, Opt_jqfmt_vfsv1, Opt_quota,
fs/ext4/super.c:	{Opt_jqfmt_vfsold, "jqfmt=vfsold"},
fs/ext4/super.c:	{Opt_jqfmt_vfsv0, "jqfmt=vfsv0"},
fs/ext4/super.c:	{Opt_jqfmt_vfsv1, "jqfmt=vfsv1"},
fs/ext4/super.c:	{Opt_jqfmt_vfsold, QFMT_VFS_OLD, MOPT_QFMT},
fs/ext4/super.c:	{Opt_jqfmt_vfsv0, QFMT_VFS_V0, MOPT_QFMT},
fs/ext4/super.c:	{Opt_jqfmt_vfsv1, QFMT_VFS_V1, MOPT_QFMT},
fs/ext4/super.c:		case QFMT_VFS_OLD:
fs/ext4/super.c:			fmtname = "vfsold";
fs/ext4/super.c:		case QFMT_VFS_V0:
fs/ext4/super.c:			fmtname = "vfsv0";
fs/ext4/super.c:		case QFMT_VFS_V1:
fs/ext4/super.c:			fmtname = "vfsv1";
fs/ext4/super.c: * in the vfs.  ext4 inode has 48 bits of i_block in fsblock units,
fs/ext4/super.c: * Note, this does *not* consider any metadata overhead for vfs i_blocks.
fs/ext4/super.c:	/* small i_blocks in vfs inode? */
fs/ext4/super.c:		 * 32 == size of vfs inode i_blocks * 8
fs/ext4/super.c:	/* Sanity check against vm- & vfs- imposed limits */
fs/ext4/super.c:		 * 2^32 512-byte sectors == size of vfs inode i_blocks * 8
fs/ext4/super.c:		ext4_msg(sb, KERN_ERR, "VFS: Can't find ext4 filesystem");
fs/ext4/super.c:		vfs_check_frozen(sb, SB_FREEZE_TRANS);
fs/ext4/ext4.h:	 * the VFS prior to calling ext4_truncate(), but the filesystem won't
fs/ext4/ext4.h:	struct inode vfs_inode;
fs/ext4/ext4.h:	return container_of(inode, struct ext4_inode_info, vfs_inode);
fs/ext4/ext4.h:extern int  ext4_getattr(struct vfsmount *mnt, struct dentry *dentry,
fs/ext4/inode.c:		 * VFS direct IO won't invoke the end_io call back function,
fs/ext4/inode.c: * much here because ->set_page_dirty is called under VFS locks.  The page is
fs/ext4/inode.c: * transaction, and VFS/VM ensures that ext4_truncate() cannot run
fs/ext4/inode.c:	unsigned int vfs_fl;
fs/ext4/inode.c:		vfs_fl = ei->vfs_inode.i_flags;
fs/ext4/inode.c:		if (vfs_fl & S_SYNC)
fs/ext4/inode.c:		if (vfs_fl & S_APPEND)
fs/ext4/inode.c:		if (vfs_fl & S_IMMUTABLE)
fs/ext4/inode.c:		if (vfs_fl & S_NOATIME)
fs/ext4/inode.c:		if (vfs_fl & S_DIRSYNC)
fs/ext4/inode.c:	struct inode *inode = &(ei->vfs_inode);
fs/ext4/inode.c:	struct inode *inode = &(ei->vfs_inode);
fs/ext4/inode.c: * We want to trap VFS attempts to truncate the file as soon as
fs/ext4/inode.c: * possible.  In particular, we want to make sure that when the VFS
fs/ext4/inode.c:int ext4_getattr(struct vfsmount *mnt, struct dentry *dentry,
fs/ext4/inode.c:	vfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);
fs/ext4/file.c:	struct vfsmount *mnt = filp->f_path.mnt;
fs/ext4/indirect.c: * VFS code falls back into buffered path in that case so we are safe.
fs/ext4/namei.c:		 * NFS may look up ".."; "." should be handled by the VFS
fs/ext4/namei.c:			&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;
fs/minix/inode.c:#include <linux/vfs.h>
fs/minix/inode.c:	return &ei->vfs_inode;
fs/minix/inode.c:	inode_init_once(&ei->vfs_inode);
fs/minix/inode.c:		printk("VFS: Can't find a Minix filesystem V1 | V2 | V3 "
fs/minix/inode.c:int minix_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
fs/minix/minix.h:	struct inode vfs_inode;
fs/minix/minix.h:extern int minix_getattr(struct vfsmount *, struct dentry *, struct kstat *);
fs/minix/minix.h:	return list_entry(inode, struct minix_inode_info, vfs_inode);
fs/udf/super.c:#include <linux/vfs.h>
fs/udf/super.c:	return &ei->vfs_inode;
fs/udf/super.c:	inode_init_once(&ei->vfs_inode);
fs/udf/udf_i.h:	struct inode vfs_inode;
fs/udf/udf_i.h:	return list_entry(inode, struct udf_inode_info, vfs_inode);
fs/ramfs/file-mmu.c: * to keep track of the virtual data: using the VFS
fs/ramfs/inode.c: * to keep track of the virtual data: using the VFS
fs/mbcache.c:	return (count / 100) * sysctl_vfs_cache_pressure;
fs/splice.c:	res = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos);
fs/splice.c:	res = vfs_write(file, (const char __user *)buf, count, &pos);
fs/qnx6/qnx6.h:	struct inode		vfs_inode;
fs/qnx6/qnx6.h:	return container_of(inode, struct qnx6_inode_info, vfs_inode);
fs/qnx6/inode.c:	return &ei->vfs_inode;
fs/qnx6/inode.c:	inode_init_once(&ei->vfs_inode);
fs/ext2/super.c:#include <linux/vfs.h>
fs/ext2/super.c:	ei->vfs_inode.i_version = 1;
fs/ext2/super.c:	return &ei->vfs_inode;
fs/ext2/super.c:	inode_init_once(&ei->vfs_inode);
fs/ext2/ext2.h:	struct inode	vfs_inode;
fs/ext2/ext2.h:	return container_of(inode, struct ext2_inode_info, vfs_inode);
fs/ext2/inode.c:	unsigned int flags = ei->vfs_inode.i_flags;
fs/ext2/namei.c: * Stuff here is basically a glue between the VFS and generic UNIXish
fs/exfat/exfat_super.c:#include <linux/vfs.h>
fs/exfat/exfat_super.c:static int exfat_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
fs/exfat/exfat_super.c:		CHECK_ERR(info->vfs_inode.i_sb != sb);
fs/exfat/exfat_super.c:		inode = igrab(&info->vfs_inode);
fs/exfat/exfat_super.c:	return &ei->vfs_inode;
fs/exfat/exfat_super.c:static int exfat_show_options(struct seq_file *m, struct vfsmount *mnt)
fs/exfat/exfat_super.c:						void *data, struct vfsmount *mnt)
fs/exfat/exfat_super.c:	inode_init_once(&ei->vfs_inode);
fs/exfat/exfat_super.h:	struct inode vfs_inode;
fs/exfat/exfat_super.h:	return container_of(inode, struct exfat_inode_info, vfs_inode);
fs/xfs/xfs_dfrag.c:	if (VN_CACHED(VFS_I(tip)) != 0) {
fs/xfs/xfs_dfrag.c:	if (VN_CACHED(VFS_I(tip)) != 0) {
fs/xfs/xfs_dfrag.c:	if ((sbp->bs_ctime.tv_sec != VFS_I(ip)->i_ctime.tv_sec) ||
fs/xfs/xfs_dfrag.c:	    (sbp->bs_ctime.tv_nsec != VFS_I(ip)->i_ctime.tv_nsec) ||
fs/xfs/xfs_dfrag.c:	    (sbp->bs_mtime.tv_sec != VFS_I(ip)->i_mtime.tv_sec) ||
fs/xfs/xfs_dfrag.c:	    (sbp->bs_mtime.tv_nsec != VFS_I(ip)->i_mtime.tv_nsec)) {
fs/xfs/xfs_dfrag.c:	if (VN_MAPPED(VFS_I(ip))) {
fs/xfs/xfs_trans_inode.c:	struct inode		*inode = VFS_I(ip);
fs/xfs/xfs_vnodeops.c:			if (VN_DIRTY(VFS_I(ip)) && ip->i_delayed_blks > 0)
fs/xfs/xfs_vnodeops.c:	     (VFS_I(ip)->i_size > 0 ||
fs/xfs/xfs_vnodeops.c:	      (VN_CACHED(VFS_I(ip)) > 0 || ip->i_delayed_blks > 0)) &&
fs/xfs/xfs_vnodeops.c:	if (ip->i_d.di_mode == 0 || is_bad_inode(VFS_I(ip))) {
fs/xfs/xfs_vnodeops.c:		    (VFS_I(ip)->i_size > 0 ||
fs/xfs/xfs_vnodeops.c:		     (VN_CACHED(VFS_I(ip)) > 0 || ip->i_delayed_blks > 0)) &&
fs/xfs/xfs_vnodeops.c:		inode_dio_wait(VFS_I(ip));
fs/xfs/xfs_vnodeops.c:	if (VN_CACHED(VFS_I(ip)) != 0) {
fs/xfs/xfs_qm_bhv.c:xfs_fill_statvfs_from_dquot(
fs/xfs/xfs_qm_bhv.c: * A statvfs (df, etc.) of a directory that is using project quota should
fs/xfs/xfs_qm_bhv.c: * return a statvfs of the project, not the entire filesystem.
fs/xfs/xfs_qm_bhv.c:xfs_qm_statvfs(
fs/xfs/xfs_qm_bhv.c:		xfs_fill_statvfs_from_dquot(statp, dqp);
fs/xfs/xfs_mount.h:#define xfs_wait_for_freeze(mp,l)	vfs_check_frozen((mp)->m_super, (l))
fs/xfs/xfs_ioctl.c: * This is a copy from fs/namei.c:vfs_readlink(), except for removing it's
fs/xfs/xfs_ioctl.c:	struct inode		*inode = VFS_I(ip);
fs/xfs/xfs_trace.h:		__entry->dev = VFS_I(ctx->dp)->i_sb->s_dev;
fs/xfs/xfs_trace.h:		__entry->dev = VFS_I(ctx->dp)->i_sb->s_dev;
fs/xfs/xfs_trace.h:		__entry->dev = VFS_I(ip)->i_sb->s_dev;
fs/xfs/xfs_trace.h:		__entry->dev = VFS_I(ip)->i_sb->s_dev;
fs/xfs/xfs_trace.h:		__entry->dev = VFS_I(ip)->i_sb->s_dev;
fs/xfs/xfs_trace.h:		__entry->dev = VFS_I(ip)->i_sb->s_dev;
fs/xfs/xfs_trace.h:		__entry->dev = VFS_I(ip)->i_sb->s_dev;
fs/xfs/xfs_trace.h:		__entry->count = atomic_read(&VFS_I(ip)->i_count);
fs/xfs/xfs_trace.h:		__entry->dev = VFS_I(dp)->i_sb->s_dev;
fs/xfs/xfs_trace.h:		__entry->dev = VFS_I(src_dp)->i_sb->s_dev;
fs/xfs/xfs_trace.h:		__entry->dev = VFS_I(ip)->i_sb->s_dev;
fs/xfs/xfs_trace.h:		__entry->dev = VFS_I(ip)->i_sb->s_dev;
fs/xfs/xfs_trace.h:		__entry->dev = VFS_I(ip)->i_sb->s_dev;
fs/xfs/xfs_trace.h:		__entry->isize = VFS_I(ip)->i_size;
fs/xfs/xfs_trace.h:		__entry->dev = VFS_I(ip)->i_sb->s_dev;
fs/xfs/xfs_trace.h:		__entry->dev = VFS_I(ip)->i_sb->s_dev;
fs/xfs/xfs_trace.h:		__entry->dev = VFS_I(ip)->i_sb->s_dev;
fs/xfs/xfs_trace.h:		__entry->dev = VFS_I(args->dp)->i_sb->s_dev;
fs/xfs/xfs_trace.h:		__entry->dev = VFS_I(args->dp)->i_sb->s_dev;
fs/xfs/xfs_trace.h:		__entry->dev = VFS_I(args->dp)->i_sb->s_dev;
fs/xfs/xfs_trace.h:		__entry->dev = VFS_I(ip)->i_sb->s_dev;
fs/xfs/xfs_iops.c:	inode = VFS_I(ip);
fs/xfs/xfs_iops.c:	return d_splice_alias(VFS_I(cip), dentry);
fs/xfs/xfs_iops.c:		return d_splice_alias(VFS_I(ip), dentry);
fs/xfs/xfs_iops.c:	dentry = d_add_ci(dentry, VFS_I(ip), &dname);
fs/xfs/xfs_iops.c:	 * With unlink, the VFS makes the dentry "negative": no inode,
fs/xfs/xfs_iops.c:	inode = VFS_I(cip);
fs/xfs/xfs_iops.c:	struct vfsmount		*mnt,
fs/xfs/xfs_iops.c:	struct inode	*inode = VFS_I(ip);
fs/xfs/xfs_iops.c:	struct inode		*inode = VFS_I(ip);
fs/xfs/xfs_iops.c:	struct inode		*inode = VFS_I(ip);
fs/xfs/xfs_iops.c:	 * between truncate() and ftruncate() as implemented in the VFS.
fs/xfs/xfs_iops.c:	 * these flags set.  For all other operations the VFS set these flags
fs/xfs/xfs_inode.c:		 * we can't set up filestreams until after the VFS inode
fs/xfs/xfs_inode.c:	/* now we have set up the vfs inode we can associate the filestream */
fs/xfs/xfs_linux.h:#include <linux/vfs.h>
fs/xfs/xfs_qm.c: * Called from the vfsops layer.
fs/xfs/xfs_qm.c:	return (qi->qi_lru_count / 100) * sysctl_vfs_cache_pressure;
fs/xfs/xfs_acl.c: * No need for i_mutex because the inode is not yet exposed to the VFS.
fs/xfs/xfs_inode.h:	/* VFS inode */
fs/xfs/xfs_inode.h:	struct inode		i_vnode;	/* embedded VFS inode */
fs/xfs/xfs_inode.h:/* Convert from vfs inode to xfs inode */
fs/xfs/xfs_inode.h:/* convert from xfs inode to vfs inode */
fs/xfs/xfs_inode.h:static inline struct inode *VFS_I(struct xfs_inode *ip)
fs/xfs/xfs_inode.h: * writing data back to disk.  Until then only the copy in the VFS inode
fs/xfs/xfs_inode.h:		return i_size_read(VFS_I(ip));
fs/xfs/xfs_inode.h:	xfs_fsize_t i_size = i_size_read(VFS_I(ip));
fs/xfs/xfs_inode.h:	ASSERT(atomic_read(&VFS_I(ip)->i_count) > 0) ; \
fs/xfs/xfs_inode.h:	ihold(VFS_I(ip)); \
fs/xfs/xfs_inode.h:	iput(VFS_I(ip)); \
fs/xfs/xfs_export.c:	return VFS_I(ip);
fs/xfs/xfs_export.c:	return d_obtain_alias(VFS_I(cip));
fs/xfs/xfs_file.c:		mutex_lock(&VFS_I(ip)->i_mutex);
fs/xfs/xfs_file.c:		mutex_unlock(&VFS_I(ip)->i_mutex);
fs/xfs/xfs_file.c:		mutex_unlock(&VFS_I(ip)->i_mutex);
fs/xfs/xfs_file.c:	mapping = VFS_I(ip)->i_mapping;
fs/xfs/xfs_quota.h:extern void xfs_qm_statvfs(struct xfs_inode *, struct kstatfs *);
fs/xfs/xfs_quota.h:#define xfs_qm_statvfs(ip, s)
fs/xfs/xfs_utils.c:	drop_nlink(VFS_I(ip));
fs/xfs/xfs_utils.c:	inc_nlink(VFS_I(ip));
fs/xfs/xfs_sync.c:	struct inode		*inode = VFS_I(ip);
fs/xfs/xfs_sync.c:	struct inode		*inode = VFS_I(ip);
fs/xfs/xfs_sync.c:	 * Just warn here till VFS can correctly support
fs/xfs/xfs_sync.c:	if (is_bad_inode(VFS_I(ip)))
fs/xfs/xfs_log_recover.c:		 * under the vfs layer, so we can get away with it unless
fs/xfs/xfs_fsops.c: * into the VFS and then periodic inode flushing will prevent log covering from
fs/xfs/xfs_iget.c:	if (inode_init_always(mp->m_super, VFS_I(ip))) {
fs/xfs/xfs_iget.c:	call_rcu(&VFS_I(ip)->i_rcu, xfs_inode_free_callback);
fs/xfs/xfs_iget.c:	struct inode		*inode = VFS_I(ip);
fs/xfs/xfs_iget.c:	 * If IRECLAIMABLE is set, we've torn down the VFS inode already.
fs/xfs/xfs_iget.c:		/* If the VFS inode is being torn down, pause and try again. */
fs/xfs/xfs_iget.c:	__destroy_inode(VFS_I(ip));
fs/xfs/xfs_iget.c: * If the inode is found in the cache, initialise the vfs inode
fs/xfs/xfs_iget.c: * add it to the cache and initialise the vfs inode.
fs/xfs/xfs_fs_subr.c:	truncate_inode_pages_range(VFS_I(ip)->i_mapping, first, last - 1);
fs/xfs/xfs_fs_subr.c:	struct address_space *mapping = VFS_I(ip)->i_mapping;
fs/xfs/xfs_fs_subr.c:	struct address_space *mapping = VFS_I(ip)->i_mapping;
fs/xfs/xfs_fs_subr.c:	struct address_space *mapping = VFS_I(ip)->i_mapping;
fs/xfs/xfs_super.c:	 * Copy binary VFS mount flags we are interested in.
fs/xfs/xfs_super.c:	/* vfs inode */
fs/xfs/xfs_super.c:	inode_init_once(VFS_I(ip));
fs/xfs/xfs_super.c: * This is called by the VFS when dirtying inode metadata.  This can happen
fs/xfs/xfs_super.c:		xfs_qm_statvfs(ip, statp);
fs/xfs/xfs_super.c:	root = igrab(VFS_I(mp->m_rootip));
fs/xfs/xfs_qm_syscalls.c:	 * because we take the vfslock before calling xfs_qm_sysent).
fs/cifs/connect.c:			 * local vfs will do advisory
fs/cifs/connect.c:		   the vfs in the future) as only NTLM or the much
fs/cifs/cifsfs.c:#include <linux/vfs.h>
fs/cifs/cifsfs.c: * Note that it should be only called if a referece to VFS super block is
fs/cifs/cifsfs.c:	cifs_inode->vfs_inode.i_blkbits = 14;  /* 2**14 = CIFS_MAX_MSGSIZE */
fs/cifs/cifsfs.c:	   to zero by the VFS */
fs/cifs/cifsfs.c:/*	cifs_inode->vfs_inode.i_flags = S_NOATIME | S_NOCMTIME;*/
fs/cifs/cifsfs.c:	return &cifs_inode->vfs_inode;
fs/cifs/cifsfs.c:	/* note that this is called by vfs setlease with lock_flocks held
fs/cifs/cifsfs.c:	inode_init_once(&cifsi->vfs_inode);
fs/cifs/cifsfs.c:#endif /* was needed for dnotify, and will be needed for inotify when VFS fix */
fs/cifs/cifsfs.c:    ("VFS to access servers complying with the SNIA CIFS Specification "
fs/cifs/Kconfig:	  This is the client VFS module for the Common Internet File System
fs/cifs/cifs_dfs_ref.c:#include <linux/vfs.h>
fs/cifs/cifs_dfs_ref.c:static struct vfsmount *cifs_dfs_do_refmount(struct cifs_sb_info *cifs_sb,
fs/cifs/cifs_dfs_ref.c:	struct vfsmount *mnt;
fs/cifs/cifs_dfs_ref.c:		return (struct vfsmount *)mountdata;
fs/cifs/cifs_dfs_ref.c:	mnt = vfs_kern_mount(&cifs_fs_type, 0, devname, mountdata);
fs/cifs/cifs_dfs_ref.c: * Create a vfsmount that we can automount
fs/cifs/cifs_dfs_ref.c:static struct vfsmount *cifs_dfs_do_automount(struct dentry *mntpt)
fs/cifs/cifs_dfs_ref.c:	struct vfsmount *mnt;
fs/cifs/cifs_dfs_ref.c:struct vfsmount *cifs_dfs_d_automount(struct path *path)
fs/cifs/cifs_dfs_ref.c:	struct vfsmount *newmnt;
fs/cifs/cifs_debug.h:		printk(KERN_ERR "CIFS VFS: " fmt "\n", ##arg);	\
fs/cifs/cifssmb.c:#include <linux/vfs.h>
fs/cifs/cifssmb.c:			 * The VFS will not try to do readahead past the
fs/cifs/cifssmb.c:			 * to prevent the VFS from repeatedly attempting to
fs/cifs/cifssmb.c: *	the same reason, but ironically when the VFS moved from
fs/cifs/cifssmb.c: *	in the VFS to make it easier to plug in network file
fs/cifs/cifssmb.c:#endif /* was needed for dnotify, and will be needed for inotify when VFS fix */
fs/cifs/cifsfs.h:extern int cifs_getattr(struct vfsmount *, struct dentry *, struct kstat *);
fs/cifs/cifsfs.h:extern struct vfsmount *cifs_dfs_d_automount(struct path *path);
fs/cifs/cifspdu.h:/* internal cifs vfs structures */
fs/cifs/cifspdu.h: *  internal cifs vfs structures
fs/cifs/cifspdu.h:#define CIFS_NETWORK_OPSYS "CIFS VFS Client for Linux"
fs/cifs/smbfsctl.h: * could be invoked from tools via a specialized hook into the VFS rather
fs/cifs/smbfsctl.h: * than via the standard vfs entry points
fs/cifs/dir.c: *   vfs operations that deal with dentries
fs/cifs/dir.c:	 * The VFS will not allow "/", but "\" is allowed by posix.
fs/cifs/dir.c:	 * the VFS handle the create.
fs/cifs/readdir.c:	 * '..'. Otherwise we won't be able to notify VFS in case of failure.
fs/cifs/cifsglob.h: * CIFS vfs client Status information (based on what we know.)
fs/cifs/cifsglob.h:	struct inode vfs_inode;
fs/cifs/cifsglob.h:	return container_of(inode, struct cifsInodeInfo, vfs_inode);
fs/cifs/cifsglob.h:#endif /* was needed for dnotify, and will be needed for inotify when VFS fix */
fs/cifs/cifs_debug.c:	seq_printf(m, "Active VFS Requests: %d\n", GlobalTotalActiveXid);
fs/cifs/cifs_debug.c:		"Total vfs operations: %d maximum at one time: %d\n",
fs/cifs/cifs_debug.c:			printk(KERN_WARNING "CIFS VFS: The legacy multiuser "
fs/cifs/inode.c: * but will return the EACCESS to the caller. Note that the VFS does not call
fs/cifs/inode.c:	 * sb->s_vfs_rename_mutex here */
fs/cifs/inode.c:int cifs_getattr(struct vfsmount *mnt, struct dentry *dentry,
fs/cifs/cifs_fs_sb.h:#define CIFS_MOUNT_NO_PERM      1 /* do not do client vfs_perm check */
fs/cifs/ioctl.c: *   vfs operations that deal with io control
fs/cifs/misc.c:/* The xid serves as a useful identifier for each incoming vfs request,
fs/cifs/misc.c:   will eventually wrap past zero) of the total vfs operations handled
fs/cifs/misc.c: * so many threads being in the vfs at one time.
fs/cifs/misc.c:		/*         so that the cifs vfs can get at that for all logged*/
fs/cifs/misc.c:		     &cinode->vfs_inode);
fs/cifs/misc.c:		    &cinode->vfs_inode);
fs/cifs/CHANGES:Set s_maxbytes to smaller (the max that vfs can handle) so that
fs/cifs/CHANGES:break to self while vfs_unlink held i_sem) which can hang for 20 seconds.
fs/cifs/CHANGES:that are parsed outside of the cifs vfs such as nosuid.
fs/cifs/CHANGES:Introduced optional mount helper utility mount.cifs and made coreq changes to cifs vfs to enable
fs/cifs/CHANGES:although corresponding function not fully implemented in the vfs yet
fs/cifs/cache.c:	*size = cifsi->vfs_inode.i_size;
fs/cifs/cache.c:	auxdata.last_write_time = cifsi->vfs_inode.i_mtime;
fs/cifs/cache.c:	auxdata.last_change_time = cifsi->vfs_inode.i_ctime;
fs/cifs/cache.c:	auxdata.last_write_time = cifsi->vfs_inode.i_mtime;
fs/cifs/cache.c:	auxdata.last_change_time = cifsi->vfs_inode.i_ctime;
fs/cifs/cache.c:					  cifsi->vfs_inode.i_mapping, first,
fs/cifs/TODO:vfs change to support removing D_NOTIFY on a file.   
fs/cifs/TODO:w) Add support for new vfs entry point for fallocate
fs/cifs/TODO:See http://bugzilla.samba.org - search on product "CifsVFS" for
fs/cifs/TODO:share and run it against cifs vfs in automated fashion.
fs/cifs/cifsproto.h:	cFYI(1, "CIFS VFS: in %s as Xid: %d with uid: %d",	\
fs/cifs/cifsproto.h:	cFYI(1, "CIFS VFS: leaving %s (xid = %d) rc = %d",	\
fs/cifs/cifsproto.h:#endif /* was needed for dnotify, and will be needed for inotify when VFS fix */
fs/cifs/file.c: *   vfs operations that deal with files
fs/cifs/file.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(cifs_inode->vfs_inode.i_sb);
fs/cifs/file.c:	the VFS or MM) should not happen but we had reports of on oops (due to
fs/cifs/file.c:	cifs_sb = CIFS_SB(cifs_inode->vfs_inode.i_sb);
fs/cifs/file.c:		/* Does mm or vfs already set times? */
fs/cifs/file.c:	 * The VFS will fall back to readpage. We should never reach this
fs/cifs/file.c:		cifs_sb = CIFS_SB(cifsInode->vfs_inode.i_sb);
fs/cifs/file.c:		if (i_size_read(&cifsInode->vfs_inode) < end_of_file)
fs/cifs/file.c:		cifs_fscache_invalidate_page(page, &cifsi->vfs_inode);
fs/cifs/AUTHORS:Andrew Tridgell (Samba team) for his early suggestions about smb/cifs VFS
fs/cifs/README:The CIFS VFS support for Linux supports many advanced network filesystem 
fs/cifs/README:and download the cifs vfs source (see the project page
fs/cifs/README:to add the cifs vfs to your kernel configure options if
fs/cifs/README:users do not need to apply the cifs_24.patch since the cifs vfs is
fs/cifs/README:mkdir linux/fs/cifs and then copy the current cifs vfs files from
fs/cifs/README:6) make modules (or "make" if CIFS VFS not to be built as a module)
fs/cifs/README:If you have built the CIFS vfs as module (successfully) simply
fs/cifs/README:If you have built the CIFS vfs into the kernel itself, follow the instructions
fs/cifs/README:the CIFS VFS web site) copy it to the same directory in which mount.smbfs and 
fs/cifs/README:with the cifs vfs.  A way to enable such mounting is to mark the mount.cifs
fs/cifs/README:To get the maximum benefit from the CIFS VFS, we recommend using a server that 
fs/cifs/README:Samba 3.0) but the CIFS vfs works fine with a wide variety of CIFS servers.  
fs/cifs/README:("man smb.conf") on the Samba server system.  Note that the cifs vfs,
fs/cifs/README:unlike the smbfs vfs, does not read the smb.conf on the client system 
fs/cifs/README:Note that Samba 2.2.7 or later includes a fix that allows the CIFS VFS to delete
fs/cifs/README:application using the cifs vfs. Absolute symlinks will work to Samba 3.0.5 or
fs/cifs/README:Once the CIFS VFS support is built into the kernel or installed as a module 
fs/cifs/README:After -o the following commonly used cifs vfs specific options
fs/cifs/README:CIFS VFS Mount Options
fs/cifs/README:		the cifs vfs.
fs/cifs/README:  perm          Client does permission checks (vfs_permission check of uid
fs/cifs/Makefile:# Makefile for Linux CIFS VFS client 
fs/binfmt_misc.c:static struct vfsmount *bm_mnt;
fs/freevxfs/vxfs_inode.c: * @sbp:		VFS superblock
fs/freevxfs/vxfs_inode.c: * @sbp:	VFS superblock
fs/freevxfs/vxfs_inode.c: * @ip:		VFS inode
fs/freevxfs/vxfs_inode.c: *  Returns the filled VFS inode.
fs/freevxfs/vxfs_inode.c: * *ip:			VFS inode
fs/freevxfs/vxfs_lookup.c: *   vxfs_find_entry finds a &struct vxfs_direct for the VFS directory
fs/freevxfs/vxfs_lookup.c: *   using the VFS supplied callback @filler.
fs/freevxfs/vxfs_super.c:#include <linux/vfs.h>
fs/freevxfs/vxfs_super.c: * @sbp:	VFS superblock.
fs/freevxfs/vxfs_super.c: * @dentry:	VFS dentry to locate superblock
fs/freevxfs/vxfs_super.c: * @sbp:		VFS superblock (to fill)
fs/freevxfs/vxfs.h: * Get filesystem private data from VFS inode.
fs/freevxfs/vxfs.h: * Get filesystem private data from VFS superblock.
fs/sysfs/dir.c:		/* If we have submounts we must allow the vfs caches
fs/sysfs/inode.c:int sysfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
fs/sysfs/mount.c:static struct vfsmount *sysfs_mnt;
fs/sysfs/sysfs.h:int sysfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat);
fs/libfs.c:#include <linux/vfs.h>
fs/libfs.c:int simple_getattr(struct vfsmount *mnt, struct dentry *dentry,
fs/libfs.c:int simple_pin_fs(struct file_system_type *type, struct vfsmount **mount, int *count)
fs/libfs.c:	struct vfsmount *mnt = NULL;
fs/libfs.c:		mnt = vfs_kern_mount(type, MS_KERNMOUNT, type->name, NULL);
fs/libfs.c:void simple_release_fs(struct vfsmount **mount, int *count)
fs/libfs.c:	struct vfsmount *mnt;
fs/sysv/itree.c:int sysv_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
fs/sysv/super.c:		printk("VFS: Found a %s FS (block size = %ld) on device %s\n",
fs/sysv/super.c:		printk("VFS: unable to find oldfs superblock on device %s\n",
fs/sysv/super.c:		printk("VFS: oldfs: unsupported block size (%dKb)\n",
fs/sysv/super.c:			printk("VFS: unable to read V7 FS superblock on "
fs/sysv/super.c:	printk(KERN_ERR "VFS: could not find a valid V7 on %s.\n",
fs/sysv/sysv.h:	struct super_block *s_sb;	/* VFS superblock */
fs/sysv/sysv.h:	struct inode	vfs_inode;
fs/sysv/sysv.h:	return list_entry(inode, struct sysv_inode_info, vfs_inode);
fs/sysv/sysv.h:extern int sysv_getattr(struct vfsmount *, struct dentry *, struct kstat *);
fs/sysv/inode.c:#include <linux/vfs.h>
fs/sysv/inode.c:	return &si->vfs_inode;
fs/sysv/inode.c:	inode_init_once(&si->vfs_inode);
fs/adfs/super.c:	return &ei->vfs_inode;
fs/adfs/super.c:	inode_init_once(&ei->vfs_inode);
fs/adfs/super.c:			printk("VFS: Can't find an adfs filesystem on dev "
fs/adfs/super.c:			printk(KERN_ERR "VFS: Unsupported blocksize on dev "
fs/adfs/adfs.h:	struct inode vfs_inode;
fs/adfs/adfs.h:	return container_of(inode, struct adfs_inode_info, vfs_inode);
fs/read_write.c:loff_t vfs_llseek(struct file *file, loff_t offset, int origin)
fs/read_write.c:EXPORT_SYMBOL(vfs_llseek);
fs/read_write.c:		loff_t res = vfs_llseek(file, offset, origin);
fs/read_write.c:	offset = vfs_llseek(file, ((loff_t) offset_high << 32) | offset_low,
fs/read_write.c:ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
fs/read_write.c:EXPORT_SYMBOL(vfs_read);
fs/read_write.c:ssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)
fs/read_write.c:EXPORT_SYMBOL(vfs_write);
fs/read_write.c:		ret = vfs_read(file, buf, count, &pos);
fs/read_write.c:		ret = vfs_write(file, buf, count, &pos);
fs/read_write.c:			ret = vfs_read(file, buf, count, &pos);
fs/read_write.c:			ret = vfs_write(file, buf, count, &pos);
fs/read_write.c:ssize_t vfs_readv(struct file *file, const struct iovec __user *vec,
fs/read_write.c:EXPORT_SYMBOL(vfs_readv);
fs/read_write.c:ssize_t vfs_writev(struct file *file, const struct iovec __user *vec,
fs/read_write.c:EXPORT_SYMBOL(vfs_writev);
fs/read_write.c:		ret = vfs_readv(file, vec, vlen, &pos);
fs/read_write.c:		ret = vfs_writev(file, vec, vlen, &pos);
fs/read_write.c:			ret = vfs_readv(file, vec, vlen, &pos);
fs/read_write.c:			ret = vfs_writev(file, vec, vlen, &pos);
fs/9p/fid.h: * to lookup which 9P FID handle should be used for a particular VFS
fs/9p/fid.h: * See Also: Mapping FIDs to Linux VFS model in
fs/9p/vfs_file.c: *  linux/fs/9p/vfs_file.c
fs/9p/vfs_file.c: * This file contians vfs file ops for 9P2000.
fs/9p/vfs_file.c:#include "v9fs_vfs.h"
fs/9p/vfs_file.c:	p9_debug(P9_DEBUG_VFS, "inode: %p file: %p\n", inode, file);
fs/9p/vfs_file.c:	p9_debug(P9_DEBUG_VFS, "filp: %p lock: %p\n", filp, fl);
fs/9p/vfs_file.c:	/* map 9p status to VFS status */
fs/9p/vfs_file.c:	p9_debug(P9_DEBUG_VFS, "filp: %p cmd:%d lock: %p name: %s\n",
fs/9p/vfs_file.c:	p9_debug(P9_DEBUG_VFS, "filp: %p cmd:%d lock: %p name: %s\n",
fs/9p/vfs_file.c:	p9_debug(P9_DEBUG_VFS, "fid %d offset %llu count %d\n",
fs/9p/vfs_file.c:	p9_debug(P9_DEBUG_VFS, "count %zu offset %lld\n", count, *offset);
fs/9p/vfs_file.c:	p9_debug(P9_DEBUG_VFS, "data %p count %d offset %x\n",
fs/9p/vfs_file.c:	p9_debug(P9_DEBUG_VFS, "filp %p datasync %x\n", filp, datasync);
fs/9p/vfs_file.c:	p9_debug(P9_DEBUG_VFS, "filp %p datasync %x\n", filp, datasync);
fs/9p/vfs_file.c:	p9_debug(P9_DEBUG_VFS, "page %p fid %lx\n",
fs/9p/acl.c:#include "v9fs_vfs.h"
fs/9p/acl.c:				v9fs_vfs_setattr_dotl(dentry, &iattr);
fs/9p/vfs_inode.c: *  linux/fs/9p/vfs_inode.c
fs/9p/vfs_inode.c: * This file contains vfs inode ops for the 9P2000 protocol.
fs/9p/vfs_inode.c:#include "v9fs_vfs.h"
fs/9p/vfs_inode.c:	return &v9inode->vfs_inode;
fs/9p/vfs_inode.c:	p9_debug(P9_DEBUG_VFS, "super block: %p mode: %ho\n", sb, mode);
fs/9p/vfs_inode.c:	p9_debug(P9_DEBUG_VFS, "inode: %p dentry: %p rmdir: %x\n",
fs/9p/vfs_inode.c:		p9_debug(P9_DEBUG_VFS, "fid lookup failed %d\n", retval);
fs/9p/vfs_inode.c:	p9_debug(P9_DEBUG_VFS, "name %s\n", dentry->d_name.name);
fs/9p/vfs_inode.c:		p9_debug(P9_DEBUG_VFS, "fid lookup failed %d\n", err);
fs/9p/vfs_inode.c:		p9_debug(P9_DEBUG_VFS, "p9_client_walk failed %d\n", err);
fs/9p/vfs_inode.c:		p9_debug(P9_DEBUG_VFS, "p9_client_fcreate failed %d\n", err);
fs/9p/vfs_inode.c:			p9_debug(P9_DEBUG_VFS,
fs/9p/vfs_inode.c:			p9_debug(P9_DEBUG_VFS,
fs/9p/vfs_inode.c: * v9fs_vfs_create - VFS hook to create files
fs/9p/vfs_inode.c:v9fs_vfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,
fs/9p/vfs_inode.c: * v9fs_vfs_mkdir - VFS mkdir hook to create a directory
fs/9p/vfs_inode.c:static int v9fs_vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
fs/9p/vfs_inode.c:	p9_debug(P9_DEBUG_VFS, "name %s\n", dentry->d_name.name);
fs/9p/vfs_inode.c: * v9fs_vfs_lookup - VFS lookup hook to "walk" to a new inode
fs/9p/vfs_inode.c:struct dentry *v9fs_vfs_lookup(struct inode *dir, struct dentry *dentry,
fs/9p/vfs_inode.c:	p9_debug(P9_DEBUG_VFS, "dir: %p dentry: (%s) %p nameidata: %p\n",
fs/9p/vfs_inode.c: * v9fs_vfs_unlink - VFS unlink hook to delete an inode
fs/9p/vfs_inode.c:int v9fs_vfs_unlink(struct inode *i, struct dentry *d)
fs/9p/vfs_inode.c: * v9fs_vfs_rmdir - VFS unlink hook to delete a directory
fs/9p/vfs_inode.c:int v9fs_vfs_rmdir(struct inode *i, struct dentry *d)
fs/9p/vfs_inode.c: * v9fs_vfs_rename - VFS hook to rename an inode
fs/9p/vfs_inode.c:v9fs_vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
fs/9p/vfs_inode.c:	p9_debug(P9_DEBUG_VFS, "\n");
fs/9p/vfs_inode.c: * v9fs_vfs_getattr - retrieve file metadata
fs/9p/vfs_inode.c:v9fs_vfs_getattr(struct vfsmount *mnt, struct dentry *dentry,
fs/9p/vfs_inode.c:	p9_debug(P9_DEBUG_VFS, "dentry: %p\n", dentry);
fs/9p/vfs_inode.c: * v9fs_vfs_setattr - set file metadata
fs/9p/vfs_inode.c:static int v9fs_vfs_setattr(struct dentry *dentry, struct iattr *iattr)
fs/9p/vfs_inode.c:	p9_debug(P9_DEBUG_VFS, "\n");
fs/9p/vfs_inode.c:	p9_debug(P9_DEBUG_VFS, " %s\n", dentry->d_name.name);
fs/9p/vfs_inode.c:	p9_debug(P9_DEBUG_VFS, "%s -> %s (%s)\n",
fs/9p/vfs_inode.c: * v9fs_vfs_follow_link - follow a symlink path
fs/9p/vfs_inode.c:static void *v9fs_vfs_follow_link(struct dentry *dentry, struct nameidata *nd)
fs/9p/vfs_inode.c:	p9_debug(P9_DEBUG_VFS, "%s\n", dentry->d_name.name);
fs/9p/vfs_inode.c: * v9fs_vfs_put_link - release a symlink path
fs/9p/vfs_inode.c:v9fs_vfs_put_link(struct dentry *dentry, struct nameidata *nd, void *p)
fs/9p/vfs_inode.c:	p9_debug(P9_DEBUG_VFS, " %s %s\n",
fs/9p/vfs_inode.c: * v9fs_vfs_mkspecial - create a special file
fs/9p/vfs_inode.c:static int v9fs_vfs_mkspecial(struct inode *dir, struct dentry *dentry,
fs/9p/vfs_inode.c: * v9fs_vfs_symlink - helper function to create symlinks
fs/9p/vfs_inode.c:v9fs_vfs_symlink(struct inode *dir, struct dentry *dentry, const char *symname)
fs/9p/vfs_inode.c:	p9_debug(P9_DEBUG_VFS, " %lu,%s,%s\n",
fs/9p/vfs_inode.c:	return v9fs_vfs_mkspecial(dir, dentry, P9_DMSYMLINK, symname);
fs/9p/vfs_inode.c: * v9fs_vfs_link - create a hardlink
fs/9p/vfs_inode.c:v9fs_vfs_link(struct dentry *old_dentry, struct inode *dir,
fs/9p/vfs_inode.c:	p9_debug(P9_DEBUG_VFS, " %lu,%s,%s\n",
fs/9p/vfs_inode.c:	retval = v9fs_vfs_mkspecial(dir, dentry, P9_DMLINK, name);
fs/9p/vfs_inode.c: * v9fs_vfs_mknod - create a special file
fs/9p/vfs_inode.c:v9fs_vfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t rdev)
fs/9p/vfs_inode.c:	p9_debug(P9_DEBUG_VFS, " %lu,%s mode: %hx MAJOR: %u MINOR: %u\n",
fs/9p/vfs_inode.c:	retval = v9fs_vfs_mkspecial(dir, dentry, perm, name);
fs/9p/vfs_inode.c:	.create = v9fs_vfs_create,
fs/9p/vfs_inode.c:	.lookup = v9fs_vfs_lookup,
fs/9p/vfs_inode.c:	.symlink = v9fs_vfs_symlink,
fs/9p/vfs_inode.c:	.link = v9fs_vfs_link,
fs/9p/vfs_inode.c:	.unlink = v9fs_vfs_unlink,
fs/9p/vfs_inode.c:	.mkdir = v9fs_vfs_mkdir,
fs/9p/vfs_inode.c:	.rmdir = v9fs_vfs_rmdir,
fs/9p/vfs_inode.c:	.mknod = v9fs_vfs_mknod,
fs/9p/vfs_inode.c:	.rename = v9fs_vfs_rename,
fs/9p/vfs_inode.c:	.getattr = v9fs_vfs_getattr,
fs/9p/vfs_inode.c:	.setattr = v9fs_vfs_setattr,
fs/9p/vfs_inode.c:	.create = v9fs_vfs_create,
fs/9p/vfs_inode.c:	.lookup = v9fs_vfs_lookup,
fs/9p/vfs_inode.c:	.unlink = v9fs_vfs_unlink,
fs/9p/vfs_inode.c:	.mkdir = v9fs_vfs_mkdir,
fs/9p/vfs_inode.c:	.rmdir = v9fs_vfs_rmdir,
fs/9p/vfs_inode.c:	.mknod = v9fs_vfs_mknod,
fs/9p/vfs_inode.c:	.rename = v9fs_vfs_rename,
fs/9p/vfs_inode.c:	.getattr = v9fs_vfs_getattr,
fs/9p/vfs_inode.c:	.setattr = v9fs_vfs_setattr,
fs/9p/vfs_inode.c:	.getattr = v9fs_vfs_getattr,
fs/9p/vfs_inode.c:	.setattr = v9fs_vfs_setattr,
fs/9p/vfs_inode.c:	.follow_link = v9fs_vfs_follow_link,
fs/9p/vfs_inode.c:	.put_link = v9fs_vfs_put_link,
fs/9p/vfs_inode.c:	.getattr = v9fs_vfs_getattr,
fs/9p/vfs_inode.c:	.setattr = v9fs_vfs_setattr,
fs/9p/v9fs.h:	struct inode vfs_inode;
fs/9p/v9fs.h:	return container_of(inode, struct v9fs_inode, vfs_inode);
fs/9p/v9fs.h:extern struct dentry *v9fs_vfs_lookup(struct inode *dir, struct dentry *dentry,
fs/9p/v9fs.h:extern int v9fs_vfs_unlink(struct inode *i, struct dentry *d);
fs/9p/v9fs.h:extern int v9fs_vfs_rmdir(struct inode *i, struct dentry *d);
fs/9p/v9fs.h:extern int v9fs_vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
fs/9p/v9fs.h:extern void v9fs_vfs_put_link(struct dentry *dentry, struct nameidata *nd,
fs/9p/vfs_inode_dotl.c: *  linux/fs/9p/vfs_inode_dotl.c
fs/9p/vfs_inode_dotl.c: * This file contains vfs inode ops for the 9P2000.L protocol.
fs/9p/vfs_inode_dotl.c:#include "v9fs_vfs.h"
fs/9p/vfs_inode_dotl.c:v9fs_vfs_mknod_dotl(struct inode *dir, struct dentry *dentry, umode_t omode,
fs/9p/vfs_inode_dotl.c: * v9fs_vfs_create_dotl - VFS hook to create files for 9P2000.L protocol.
fs/9p/vfs_inode_dotl.c:v9fs_vfs_create_dotl(struct inode *dir, struct dentry *dentry, umode_t omode,
fs/9p/vfs_inode_dotl.c:		return v9fs_vfs_mknod_dotl(dir, dentry, omode, 0);
fs/9p/vfs_inode_dotl.c:	p9_debug(P9_DEBUG_VFS, "name:%s flags:0x%x mode:0x%hx\n",
fs/9p/vfs_inode_dotl.c:		p9_debug(P9_DEBUG_VFS, "fid lookup failed %d\n", err);
fs/9p/vfs_inode_dotl.c:		p9_debug(P9_DEBUG_VFS, "p9_client_walk failed %d\n", err);
fs/9p/vfs_inode_dotl.c:		p9_debug(P9_DEBUG_VFS, "Failed to get acl values in creat %d\n",
fs/9p/vfs_inode_dotl.c:		p9_debug(P9_DEBUG_VFS, "p9_client_open_dotl failed in creat %d\n",
fs/9p/vfs_inode_dotl.c:		p9_debug(P9_DEBUG_VFS, "p9_client_walk failed %d\n", err);
fs/9p/vfs_inode_dotl.c:		p9_debug(P9_DEBUG_VFS, "inode creation failed %d\n", err);
fs/9p/vfs_inode_dotl.c: * v9fs_vfs_mkdir_dotl - VFS mkdir hook to create a directory
fs/9p/vfs_inode_dotl.c:static int v9fs_vfs_mkdir_dotl(struct inode *dir,
fs/9p/vfs_inode_dotl.c:	p9_debug(P9_DEBUG_VFS, "name %s\n", dentry->d_name.name);
fs/9p/vfs_inode_dotl.c:		p9_debug(P9_DEBUG_VFS, "fid lookup failed %d\n", err);
fs/9p/vfs_inode_dotl.c:		p9_debug(P9_DEBUG_VFS, "Failed to get acl values in mkdir %d\n",
fs/9p/vfs_inode_dotl.c:			p9_debug(P9_DEBUG_VFS, "p9_client_walk failed %d\n",
fs/9p/vfs_inode_dotl.c:			p9_debug(P9_DEBUG_VFS, "inode creation failed %d\n",
fs/9p/vfs_inode_dotl.c:v9fs_vfs_getattr_dotl(struct vfsmount *mnt, struct dentry *dentry,
fs/9p/vfs_inode_dotl.c:	p9_debug(P9_DEBUG_VFS, "dentry: %p\n", dentry);
fs/9p/vfs_inode_dotl.c: * v9fs_vfs_setattr_dotl - set file metadata
fs/9p/vfs_inode_dotl.c:int v9fs_vfs_setattr_dotl(struct dentry *dentry, struct iattr *iattr)
fs/9p/vfs_inode_dotl.c:	p9_debug(P9_DEBUG_VFS, "\n");
fs/9p/vfs_inode_dotl.c:v9fs_vfs_symlink_dotl(struct inode *dir, struct dentry *dentry,
fs/9p/vfs_inode_dotl.c:	p9_debug(P9_DEBUG_VFS, "%lu,%s,%s\n", dir->i_ino, name, symname);
fs/9p/vfs_inode_dotl.c:		p9_debug(P9_DEBUG_VFS, "fid lookup failed %d\n", err);
fs/9p/vfs_inode_dotl.c:		p9_debug(P9_DEBUG_VFS, "p9_client_symlink failed %d\n", err);
fs/9p/vfs_inode_dotl.c:			p9_debug(P9_DEBUG_VFS, "p9_client_walk failed %d\n",
fs/9p/vfs_inode_dotl.c:			p9_debug(P9_DEBUG_VFS, "inode creation failed %d\n",
fs/9p/vfs_inode_dotl.c: * v9fs_vfs_link_dotl - create a hardlink for dotl
fs/9p/vfs_inode_dotl.c:v9fs_vfs_link_dotl(struct dentry *old_dentry, struct inode *dir,
fs/9p/vfs_inode_dotl.c:	p9_debug(P9_DEBUG_VFS, "dir ino: %lu, old_name: %s, new_name: %s\n",
fs/9p/vfs_inode_dotl.c:		p9_debug(P9_DEBUG_VFS, "p9_client_link failed %d\n", err);
fs/9p/vfs_inode_dotl.c: * v9fs_vfs_mknod_dotl - create a special file
fs/9p/vfs_inode_dotl.c:v9fs_vfs_mknod_dotl(struct inode *dir, struct dentry *dentry, umode_t omode,
fs/9p/vfs_inode_dotl.c:	p9_debug(P9_DEBUG_VFS, " %lu,%s mode: %hx MAJOR: %u MINOR: %u\n",
fs/9p/vfs_inode_dotl.c:		p9_debug(P9_DEBUG_VFS, "fid lookup failed %d\n", err);
fs/9p/vfs_inode_dotl.c:		p9_debug(P9_DEBUG_VFS, "Failed to get acl values in mknod %d\n",
fs/9p/vfs_inode_dotl.c:			p9_debug(P9_DEBUG_VFS, "p9_client_walk failed %d\n",
fs/9p/vfs_inode_dotl.c:			p9_debug(P9_DEBUG_VFS, "inode creation failed %d\n",
fs/9p/vfs_inode_dotl.c: * v9fs_vfs_follow_link_dotl - follow a symlink path
fs/9p/vfs_inode_dotl.c:v9fs_vfs_follow_link_dotl(struct dentry *dentry, struct nameidata *nd)
fs/9p/vfs_inode_dotl.c:	p9_debug(P9_DEBUG_VFS, "%s\n", dentry->d_name.name);
fs/9p/vfs_inode_dotl.c:	.create = v9fs_vfs_create_dotl,
fs/9p/vfs_inode_dotl.c:	.lookup = v9fs_vfs_lookup,
fs/9p/vfs_inode_dotl.c:	.link = v9fs_vfs_link_dotl,
fs/9p/vfs_inode_dotl.c:	.symlink = v9fs_vfs_symlink_dotl,
fs/9p/vfs_inode_dotl.c:	.unlink = v9fs_vfs_unlink,
fs/9p/vfs_inode_dotl.c:	.mkdir = v9fs_vfs_mkdir_dotl,
fs/9p/vfs_inode_dotl.c:	.rmdir = v9fs_vfs_rmdir,
fs/9p/vfs_inode_dotl.c:	.mknod = v9fs_vfs_mknod_dotl,
fs/9p/vfs_inode_dotl.c:	.rename = v9fs_vfs_rename,
fs/9p/vfs_inode_dotl.c:	.getattr = v9fs_vfs_getattr_dotl,
fs/9p/vfs_inode_dotl.c:	.setattr = v9fs_vfs_setattr_dotl,
fs/9p/vfs_inode_dotl.c:	.getattr = v9fs_vfs_getattr_dotl,
fs/9p/vfs_inode_dotl.c:	.setattr = v9fs_vfs_setattr_dotl,
fs/9p/vfs_inode_dotl.c:	.follow_link = v9fs_vfs_follow_link_dotl,
fs/9p/vfs_inode_dotl.c:	.put_link = v9fs_vfs_put_link,
fs/9p/vfs_inode_dotl.c:	.getattr = v9fs_vfs_getattr_dotl,
fs/9p/vfs_inode_dotl.c:	.setattr = v9fs_vfs_setattr_dotl,
fs/9p/vfs_super.c: *  linux/fs/9p/vfs_super.c
fs/9p/vfs_super.c:#include "v9fs_vfs.h"
fs/9p/vfs_super.c:	p9_debug(P9_DEBUG_VFS, "\n");
fs/9p/vfs_super.c:	p9_debug(P9_DEBUG_VFS, " simple set mount, return 0\n");
fs/9p/vfs_super.c:	p9_debug(P9_DEBUG_VFS, " %p\n", s);
fs/9p/vfs_super.c:	p9_debug(P9_DEBUG_VFS, "exiting kill_super\n");
fs/9p/vfs_super.c:	p9_debug(P9_DEBUG_VFS, "%s: inode %p\n", __func__, inode);
fs/9p/vfs_super.c:	p9_debug(P9_DEBUG_VFS, "%s: inode %p\n", __func__, inode);
fs/9p/vfs_addr.c: *  linux/fs/9p/vfs_addr.c
fs/9p/vfs_addr.c: * This file contians vfs address (mmap) ops for 9P2000.
fs/9p/vfs_addr.c:#include "v9fs_vfs.h"
fs/9p/vfs_addr.c:	p9_debug(P9_DEBUG_VFS, "\n");
fs/9p/vfs_addr.c: * v9fs_vfs_readpage - read an entire page in from 9P
fs/9p/vfs_addr.c:static int v9fs_vfs_readpage(struct file *filp, struct page *page)
fs/9p/vfs_addr.c: * v9fs_vfs_readpages - read a set of pages from 9P
fs/9p/vfs_addr.c:static int v9fs_vfs_readpages(struct file *filp, struct address_space *mapping,
fs/9p/vfs_addr.c:	p9_debug(P9_DEBUG_VFS, "inode: %p file: %p\n", inode, filp);
fs/9p/vfs_addr.c:	ret = read_cache_pages(mapping, pages, (void *)v9fs_vfs_readpage, filp);
fs/9p/vfs_addr.c:	p9_debug(P9_DEBUG_VFS, "  = %d\n", ret);
fs/9p/vfs_addr.c:static int v9fs_vfs_writepage_locked(struct page *page)
fs/9p/vfs_addr.c:static int v9fs_vfs_writepage(struct page *page, struct writeback_control *wbc)
fs/9p/vfs_addr.c:	retval = v9fs_vfs_writepage_locked(page);
fs/9p/vfs_addr.c:		retval = v9fs_vfs_writepage_locked(page);
fs/9p/vfs_addr.c: * the VFS gets them, so this method should never be called.
fs/9p/vfs_addr.c:	p9_debug(P9_DEBUG_VFS, "v9fs_direct_IO: v9fs_direct_IO (%s) off/no(%lld/%lu) EINVAL\n",
fs/9p/vfs_addr.c:	.readpage = v9fs_vfs_readpage,
fs/9p/vfs_addr.c:	.readpages = v9fs_vfs_readpages,
fs/9p/vfs_addr.c:	.writepage = v9fs_vfs_writepage,
fs/9p/vfs_dir.c: * linux/fs/9p/vfs_dir.c
fs/9p/vfs_dir.c: * This file contains vfs directory ops for the 9P2000 protocol.
fs/9p/vfs_dir.c:#include "v9fs_vfs.h"
fs/9p/vfs_dir.c:	p9_debug(P9_DEBUG_VFS, "name %s\n", filp->f_path.dentry->d_name.name);
fs/9p/vfs_dir.c:				p9_debug(P9_DEBUG_VFS, "returned %d\n", err);
fs/9p/vfs_dir.c:	p9_debug(P9_DEBUG_VFS, "name %s\n", filp->f_path.dentry->d_name.name);
fs/9p/vfs_dir.c:				p9_debug(P9_DEBUG_VFS, "returned %d\n", err);
fs/9p/vfs_dir.c:	p9_debug(P9_DEBUG_VFS, "inode: %p filp: %p fid: %d\n",
fs/9p/cache.c:		 &v9inode->vfs_inode, v9inode->qid.path);
fs/9p/cache.c:	*size = i_size_read(&v9inode->vfs_inode);
fs/9p/cache.c:		 &v9inode->vfs_inode, *size);
fs/9p/cache.c:		 &v9inode->vfs_inode, v9inode->qid.version);
fs/9p/cache.c:		nr_pages = pagevec_lookup(&pvec, v9inode->vfs_inode.i_mapping,
fs/9p/cache.c:static void v9fs_vfs_readpage_complete(struct page *page, void *data,
fs/9p/cache.c:					 v9fs_vfs_readpage_complete,
fs/9p/cache.c:					  v9fs_vfs_readpage_complete,
fs/9p/v9fs.c: *  This file contains functions assisting in mapping VFS to 9P2000
fs/9p/v9fs.c:#include "v9fs_vfs.h"
fs/9p/v9fs.c:	inode_init_once(&v9inode->vfs_inode);
fs/9p/v9fs_vfs.h: * V9FS VFS extensions.
fs/9p/v9fs_vfs.h:#ifndef FS_9P_V9FS_VFS_H
fs/9p/v9fs_vfs.h:#define FS_9P_V9FS_VFS_H
fs/9p/v9fs_vfs.h:int v9fs_vfs_setattr_dotl(struct dentry *, struct iattr *);
fs/9p/vfs_dentry.c: *  linux/fs/9p/vfs_dentry.c
fs/9p/vfs_dentry.c: * This file contians vfs dentry ops for the 9P2000 protocol.
fs/9p/vfs_dentry.c:#include "v9fs_vfs.h"
fs/9p/vfs_dentry.c:	p9_debug(P9_DEBUG_VFS, " dentry: %s (%p)\n",
fs/9p/vfs_dentry.c:	p9_debug(P9_DEBUG_VFS, " dentry: %s (%p)\n",
fs/9p/vfs_dentry.c:	p9_debug(P9_DEBUG_VFS, " dentry: %s (%p)\n",
fs/9p/fid.c:#include "v9fs_vfs.h"
fs/9p/fid.c:	p9_debug(P9_DEBUG_VFS, "fid %d dentry %s\n",
fs/9p/fid.c:	p9_debug(P9_DEBUG_VFS, " dentry: %s (%p) uid %d any %d\n",
fs/9p/xattr.c:		p9_debug(P9_DEBUG_VFS, "p9_client_attrwalk failed %zd\n",
fs/9p/xattr.c:	p9_debug(P9_DEBUG_VFS, "name = %s value_len = %zu\n",
fs/9p/xattr.c:	p9_debug(P9_DEBUG_VFS, "name = %s value_len = %zu flags = %d\n",
fs/9p/xattr.c:		p9_debug(P9_DEBUG_VFS, "p9_client_xattrcreate failed %d\n",
fs/9p/Makefile:	vfs_super.o \
fs/9p/Makefile:	vfs_inode.o \
fs/9p/Makefile:	vfs_inode_dotl.o \
fs/9p/Makefile:	vfs_addr.o \
fs/9p/Makefile:	vfs_file.o \
fs/9p/Makefile:	vfs_dir.o \
fs/9p/Makefile:	vfs_dentry.o \
fs/hostfs/hostfs_kern.c:	struct inode vfs_inode;
fs/hostfs/hostfs_kern.c:	return list_entry(inode, struct hostfs_inode_info, vfs_inode);
fs/hostfs/hostfs_kern.c:	inode_init_once(&hi->vfs_inode);
fs/hostfs/hostfs_kern.c:	return &hi->vfs_inode;
fs/hostfs/hostfs_user.c:#include <sys/vfs.h>
fs/lockd/svclock.c:	/* Set notifier function for VFS, and init args */
fs/lockd/svclock.c:	error = vfs_lock_file(file->f_file, F_SETLK, &lock->fl, NULL);
fs/lockd/svclock.c:	dprintk("lockd: vfs_lock_file returned %d\n", error);
fs/lockd/svclock.c:	error = vfs_test_lock(file->f_file, &lock->fl);
fs/lockd/svclock.c:	error = vfs_lock_file(file->f_file, F_SETLK, &lock->fl, NULL);
fs/lockd/svclock.c:		vfs_cancel_lock(block->b_file->f_file,
fs/lockd/svclock.c: * This is a callback from the filesystem for VFS file lock requests.
fs/lockd/svclock.c: * VFS layer when a lock on which we blocked is removed.
fs/lockd/svclock.c:	dprintk("lockd: VFS unblock notification for block %p\n", fl);
fs/lockd/svclock.c:	/* vfs_lock_file() can mangle fl_start and fl_end, but we need
fs/lockd/svclock.c:	error = vfs_lock_file(file->f_file, F_SETLK, &lock->fl, NULL);
fs/lockd/svclock.c:	/* Lock was granted by VFS. */
fs/lockd/clntproc.c:static int do_vfs_lock(struct file_lock *fl)
fs/lockd/clntproc.c:	status = do_vfs_lock(fl);
fs/lockd/clntproc.c:		if (do_vfs_lock(fl) < 0)
fs/lockd/clntproc.c:			printk(KERN_WARNING "%s: VFS is out of sync with lock manager!\n", __func__);
fs/lockd/clntproc.c:	do_vfs_lock(fl);
fs/lockd/clntproc.c:	status = do_vfs_lock(fl);
fs/lockd/svcsubs.c: * and open a (VFS) file for the given inode.
fs/lockd/svcsubs.c:			if (vfs_lock_file(file->f_file, F_SETLK, &lock, NULL) < 0) {
fs/inode.c:static int relatime_need_update(struct vfsmount *mnt, struct inode *inode,
fs/inode.c:	struct vfsmount *mnt = path->mnt;
fs/scfs/scfs.c:	struct scfs_sb_info *sbi = SCFS_S(sii->vfs_inode.i_sb);
fs/scfs/scfs.c: * @inode: inode in VFS layer
fs/scfs/scfs.c:	struct vfsmount *lower_mnt = scfs_dentry_to_lower_mnt(dentry);
fs/scfs/scfs.c:	i_size = i_size_read(&sii->vfs_inode);
fs/scfs/scfs.c:	/* vfs read, either cluster or page */
fs/scfs/scfs.c:		SCFS_PRINT_ERROR("file %s: vfs_read failed, clust %d of %d, "
fs/scfs/scfs.c:	struct scfs_sb_info *sbi = SCFS_S(sii->vfs_inode.i_sb);
fs/scfs/scfs.c:	struct scfs_sb_info *sbi = SCFS_S(sii->vfs_inode.i_sb);
fs/scfs/scfs.c:		pos = i_size_read(&sii->vfs_inode);
fs/scfs/scfs.c:	cf.original_file_size = i_size_read(&sii->vfs_inode);
fs/scfs/scfs.c:	struct scfs_sb_info *sbi = SCFS_S(sii->vfs_inode.i_sb);
fs/scfs/scfs.c:		loff_t i_size = i_size_read(&sii->vfs_inode);
fs/scfs/scfs.c:			SCFS_PRINT_ERROR("f:%s vfs_read failed, size %d pos %d ret = %d\n",
fs/scfs/scfs.c:	struct scfs_sb_info *sbi = SCFS_S(sii->vfs_inode.i_sb);
fs/scfs/scfs.c:		ret = vfs_read(file, buf + read, count - read, pos);
fs/scfs/scfs.c:			SCFS_PRINT_ERROR("f:%s err in vfs_read, ret : %d\n",
fs/scfs/scfs.c:		ret = vfs_write(file, buf + written, count - written, pos);
fs/scfs/scfs.c:			SCFS_PRINT_ERROR("f:%s err in vfs_write, ret : %d\n",
fs/scfs/scfs.c:	inode_init_once(&sii->vfs_inode);
fs/scfs/scfs.c:			SCFS_S(sii->vfs_inode.i_sb));
fs/scfs/scfs.c:			SCFS_S(sii->vfs_inode.i_sb));
fs/scfs/scfs.c:			SCFS_S(sii->vfs_inode.i_sb));
fs/scfs/scfs.c:		profile_sub_kmalloced(sii->cinfo_array_size, SCFS_S(sii->vfs_inode.i_sb));
fs/scfs/Kconfig:	  SCFS on the VFS layer.
fs/scfs/scfs.h: 	struct inode vfs_inode;
fs/scfs/scfs.h:	/* DO NOT ADD FIELDS BELOW vfs_inode */
fs/scfs/scfs.h:#define SCFS_I(inode)	(container_of(inode, struct scfs_inode_info, vfs_inode))
fs/scfs/scfs.h:	DIV_ROUND_UP_ULL(i_size_read(&sii->vfs_inode), sii->cluster_size)
fs/scfs/scfs.h:static inline struct vfsmount *scfs_dentry_to_lower_mnt(struct dentry *dentry)
fs/scfs/scfs.h:	struct vfsmount *lower_mnt)
fs/scfs/super.c:	memset(sii, 0, offsetof(struct scfs_inode_info, vfs_inode));
fs/scfs/super.c:	sii->vfs_inode.i_version = 1;
fs/scfs/super.c:	return &sii->vfs_inode;
fs/scfs/super.c:	struct vfsmount *lower_mnt;
fs/scfs/super.c:	struct vfsmount *lower_mnt;
fs/scfs/super.c:	struct vfsmount *vfsmount_save = NULL;
fs/scfs/super.c:		vfsmount_save = nd->path.mnt;
fs/scfs/super.c:		nd->path.mnt = vfsmount_save;
fs/scfs/mmap.c:		sbi->buffer_cache[pref_index].ino == sii->vfs_inode.i_ino &&
fs/scfs/mmap.c:		if (sbi->buffer_cache[pref_index].ino != sii->vfs_inode.i_ino ||
fs/scfs/mmap.c:		if (sbi->buffer_cache[i].ino == sii->vfs_inode.i_ino &&
fs/scfs/mmap.c:			if (sbi->buffer_cache[i].ino == sii->vfs_inode.i_ino &&
fs/scfs/mmap.c:		sbi->buffer_cache[allocated_index].ino = sii->vfs_inode.i_ino;
fs/scfs/mmap.c:			sbi->buffer_cache[i].ino = sii->vfs_inode.i_ino;
fs/scfs/mmap.c:	i_size = i_size_read(&sii->vfs_inode);
fs/scfs/mmap.c:			i_size_read(&sii->vfs_inode));
fs/scfs/mmap.c:	if (pos != i_size_read(&sii->vfs_inode)) {
fs/scfs/mmap.c:			file->f_path.dentry->d_name.name,pos,i_size_read(&sii->vfs_inode));
fs/scfs/mmap.c:	struct scfs_sb_info *sb_info = SCFS_S(sii->vfs_inode.i_sb);
fs/scfs/mmap.c:			i_size_read(&sii->vfs_inode), page->index);
fs/scfs/mmap.c:	if (pos + copied > i_size_read(&sii->vfs_inode)) {
fs/scfs/mmap.c:		i_size_write(&sii->vfs_inode, pos + copied);
fs/scfs/mmap.c:			(unsigned long long)i_size_read(&sii->vfs_inode));
fs/scfs/mmap.c:	struct scfs_sb_info *sb_info = SCFS_S(sii->vfs_inode.i_sb);
fs/scfs/mmap.c:	struct scfs_sb_info *sbi = SCFS_S(sii->vfs_inode.i_sb);
fs/scfs/mmap.c:	struct scfs_sb_info *sbi = SCFS_S(sii->vfs_inode.i_sb);
fs/scfs/inode.c:	ret = vfs_create(lower_parent_dentry->d_inode, lower_file_dentry, mode, true);
fs/scfs/inode.c:	ret = vfs_create(lower_parent_dentry->d_inode, lower_file_dentry, mode, NULL);
fs/scfs/inode.c:		SCFS_PRINT_ERROR("error in vfs_create, lower create, ret : %d\n", ret);
fs/scfs/inode.c:		vfs_unlink(lower_parent_dentry->d_inode, lower_file_dentry);
fs/scfs/inode.c:	ret = vfs_unlink(lower_dir_inode, lower_dentry);
fs/scfs/inode.c:		SCFS_PRINT_ERROR("error in vfs_unlink, ret : %d\n", ret);
fs/scfs/inode.c:	ret = vfs_mkdir(lower_parent_dentry->d_inode, lower_dir_dentry, mode);
fs/scfs/inode.c:		SCFS_PRINT_ERROR("dir %s vfs_mkdir failed, "
fs/scfs/inode.c:		vfs_rmdir(lower_parent_dentry->d_inode, lower_dir_dentry);
fs/scfs/inode.c:	struct vfsmount *lower_mnt;
fs/scfs/inode.c:	ret = vfs_rename(lower_old_dir_dentry->d_inode, lower_old_dentry,
fs/scfs/inode.c:	ret = vfs_rmdir(lower_dir_dentry->d_inode, lower_dentry);
fs/scfs/inode.c:int scfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
fs/scfs/inode.c:	ret = vfs_getattr(
fs/scfs/inode.c:	ret = vfs_symlink(lower_dir_dentry->d_inode, lower_dentry, symname);
fs/scfs/inode.c:	ret = vfs_mknod(lower_dir_dentry->d_inode, lower_dentry, mode, dev);
fs/scfs/inode.c:	ret = vfs_link(lower_old_dentry, lower_dir_dentry->d_inode,
fs/scfs/inode.c:	ret = vfs_setxattr(lower_dentry, name, value, size, flags);
fs/scfs/file.c:	ret = vfs_readdir(lower_file, filldir, dirent);
fs/scfs/file.c:	ret = vfs_fsync(scfs_lower_file(file), datasync);
fs/buffer.c:	WARN(1, KERN_ERR "VFS: brelse: Trying to free free buffer\n");
fs/buffer.c: * Direct callers of this function should call vfs_check_frozen() so that page
fs/buffer.c:	vfs_check_frozen(sb, SB_FREEZE_WRITE);
fs/ioctl.c: * vfs_ioctl - call filesystem specific ioctl methods
fs/ioctl.c:static long vfs_ioctl(struct file *filp, unsigned int cmd,
fs/ioctl.c:	return vfs_ioctl(filp, cmd, arg);
fs/ioctl.c: * do_vfs_ioctl() is not for drivers and not intended to be EXPORT_SYMBOL()'d.
fs/ioctl.c:int do_vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd,
fs/ioctl.c:			error = vfs_ioctl(filp, cmd, arg);
fs/ioctl.c:	error = do_vfs_ioctl(filp, fd, cmd, arg);
fs/nilfs2/super.c:#include <linux/vfs.h>
fs/nilfs2/super.c:	ii->vfs_inode.i_version = 1;
fs/nilfs2/super.c:	nilfs_mapping_init(&ii->i_btnode_cache, &ii->vfs_inode, sb->s_bdi);
fs/nilfs2/super.c:	return &ii->vfs_inode;
fs/nilfs2/super.c:	inode_init_once(&ii->vfs_inode);
fs/nilfs2/nilfs.h:	struct inode vfs_inode;
fs/nilfs2/nilfs.h:	return container_of(inode, struct nilfs_inode_info, vfs_inode);
fs/nilfs2/nilfs.h:	return &ii->vfs_inode;
fs/nilfs2/inode.c: * block. It is done by VFS.
fs/nilfs2/inode.c:	nilfs_relax_pressure_in_lock(ii->vfs_inode.i_sb);
fs/nilfs2/inode.c:	nilfs_warning(ii->vfs_inode.i_sb, __func__,
fs/nilfs2/inode.c:		      ii->vfs_inode.i_ino, ret);
fs/nilfs2/ioctl.c:	vfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);
fs/nilfs2/btree.c:		       NILFS_BMAP_I(btree)->vfs_inode.i_ino,
fs/nilfs2/segment.c:	vfs_check_frozen(sb, SB_FREEZE_WRITE);
fs/nilfs2/segment.c:			iput(&(*pii)->vfs_inode);
fs/nilfs2/segment.c:		raw_inode = nilfs_ifile_map_inode(ifile, ii->vfs_inode.i_ino,
fs/nilfs2/segment.c:		nilfs_ifile_unmap_inode(ifile, ii->vfs_inode.i_ino, ibh);
fs/nilfs2/segment.c:					sci, &ii->vfs_inode,
fs/nilfs2/segment.c:			err = nilfs_segctor_scan_file(sci, &ii->vfs_inode,
fs/nilfs2/segment.c:		err = nilfs_segctor_scan_file_dsync(sci, &ii->vfs_inode);
fs/nilfs2/segment.c:				ifile, ii->vfs_inode.i_ino, &ibh);
fs/nilfs2/segment.c:		if (!ii->vfs_inode.i_nlink || during_mount) {
fs/nilfs2/segment.c:			iput(&ii->vfs_inode);
fs/nilfs2/segment.c:		truncate_inode_pages(&ii->vfs_inode.i_data, 0);
fs/nilfs2/segment.c:		iput(&ii->vfs_inode);
fs/nilfs2/gcinode.c:		truncate_inode_pages(&ii->vfs_inode.i_data, 0);
fs/nilfs2/gcinode.c:		iput(&ii->vfs_inode);
fs/nilfs2/bmap.c:	bmap->b_inode = &NILFS_BMAP_I(bmap)->vfs_inode;
fs/nilfs2/bmap.c:	bmap->b_inode = &NILFS_BMAP_I(bmap)->vfs_inode;
fs/ufs/super.c:#include <linux/vfs.h>
fs/ufs/super.c:	ei->vfs_inode.i_version = 1;
fs/ufs/super.c:	return &ei->vfs_inode;
fs/ufs/super.c:	inode_init_once(&ei->vfs_inode);
fs/ufs/ufs.h:	struct inode vfs_inode;
fs/ufs/ufs.h:	return container_of(inode, struct ufs_inode_info, vfs_inode);
fs/hugetlbfs/inode.c:	struct inode vfs_inode;
fs/hugetlbfs/inode.c:	return container_of(inode, struct hugetlbfs_inode_info, vfs_inode);
fs/hugetlbfs/inode.c:	return &p->vfs_inode;
fs/hugetlbfs/inode.c:	inode_init_once(&ei->vfs_inode);
fs/hugetlbfs/inode.c:static struct vfsmount *hugetlbfs_vfsmount;
fs/hugetlbfs/inode.c:	if (!hugetlbfs_vfsmount)
fs/hugetlbfs/inode.c:	root = hugetlbfs_vfsmount->mnt_root;
fs/hugetlbfs/inode.c:	path.mnt = mntget(hugetlbfs_vfsmount);
fs/hugetlbfs/inode.c:	struct vfsmount *vfsmount;
fs/hugetlbfs/inode.c:	vfsmount = kern_mount(&hugetlbfs_fs_type);
fs/hugetlbfs/inode.c:	if (!IS_ERR(vfsmount)) {
fs/hugetlbfs/inode.c:		hugetlbfs_vfsmount = vfsmount;
fs/hugetlbfs/inode.c:	error = PTR_ERR(vfsmount);
fs/hugetlbfs/inode.c:	kern_unmount(hugetlbfs_vfsmount);
fs/proc/root.c:static int proc_root_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat
fs/proc/root.c:	struct vfsmount *mnt;
fs/proc/inode.c:	inode = &ei->vfs_inode;
fs/proc/inode.c:	inode_init_once(&ei->vfs_inode);
fs/proc/proc_sysctl.c:static int proc_sys_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
fs/proc/internal.h:int pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat);
fs/proc/base.c:int pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
fs/proc/base.c:	return vfs_readlink(dentry,buffer,buflen,tmp);
fs/proc/base.c:static void proc_flush_task_mnt(struct vfsmount *mnt, pid_t pid, pid_t tgid)
fs/proc/base.c:static int proc_task_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
fs/proc/generic.c:static int proc_getattr(struct vfsmount *mnt, struct dentry *dentry,
fs/proc/generic.c: * Note that the VFS-layer doesn't care about the return
fs/proc/proc_net.c:static int proc_tgid_net_getattr(struct vfsmount *mnt, struct dentry *dentry,
fs/reiserfs/reiserfs.h:	struct inode vfs_inode;
fs/reiserfs/reiserfs.h:	return container_of(inode, struct reiserfs_inode_info, vfs_inode);
fs/reiserfs/reiserfs.h:excessive effort to avoid disturbing the precious VFS code.:-( The
fs/reiserfs/super.c:#include <linux/vfs.h>
fs/reiserfs/super.c:	return &ei->vfs_inode;
fs/reiserfs/super.c:	inode_init_once(&ei->vfs_inode);
fs/reiserfs/super.c:		if (REISERFS_SB(s)->s_jquota_fmt == QFMT_VFS_OLD)
fs/reiserfs/super.c:			seq_puts(seq, ",jqfmt=vfsold");
fs/reiserfs/super.c:		else if (REISERFS_SB(s)->s_jquota_fmt == QFMT_VFS_V0)
fs/reiserfs/super.c:			seq_puts(seq, ",jqfmt=vfsv0");
fs/reiserfs/super.c:			if (!strcmp(arg, "vfsold"))
fs/reiserfs/super.c:				*qfmt = QFMT_VFS_OLD;
fs/reiserfs/super.c:			else if (!strcmp(arg, "vfsv0"))
fs/reiserfs/super.c:				*qfmt = QFMT_VFS_V0;
fs/reiserfs/dir.c:					/* too big to send back to VFS */
fs/reiserfs/inode.c:** The VFS layer calls reiserfs_readpage, who searches the tree to find
fs/reiserfs/inode.c:** though the VFS layer is calling this function with create==1.  If you
fs/reiserfs/inode.c:** always logs them.  This call allows the VFS inode marking routines
fs/reiserfs/inode.c:				 "but vfs thinks they are!");
fs/reiserfs/inode.c:** vfs version of truncate file.  Must NOT be called with
fs/reiserfs/file.c:** file_release is called by the VFS layer when the file is closed.  If
fs/reiserfs/file.c:static void reiserfs_vfs_truncate_file(struct inode *inode)
fs/reiserfs/file.c:	* file sizes. Catch this case here, as the rest of the VFS layer is
fs/reiserfs/file.c:	.truncate = reiserfs_vfs_truncate_file,
fs/reiserfs/bitmap.c:	struct inode *inode = &ei->vfs_inode;
fs/reiserfs/bitmap.c:	/* Mimic old block allocator behaviour, that is if VFS allowed for preallocation,
fs/reiserfs/xattr.c:/* Helpers for inode ops. We do this so that we don't have all the VFS
fs/reiserfs/xattr.c:/* Actual operations that are exported to VFS-land */
fs/hppfs/hppfs.c:	struct inode vfs_inode;
fs/hppfs/hppfs.c:	return container_of(inode, struct hppfs_inode_info, vfs_inode);
fs/hppfs/hppfs.c:	struct vfsmount *proc_mnt;
fs/hppfs/hppfs.c:	struct vfsmount *proc_mnt;
fs/hppfs/hppfs.c:	void *vfs_dirent;
fs/hppfs/hppfs.c:	return (*dirent->filldir)(dirent->vfs_dirent, name, size, offset,
fs/hppfs/hppfs.c:		                      { .vfs_dirent  	= ent,
fs/hppfs/hppfs.c:	inode_init_once(&hi->vfs_inode);
fs/hppfs/hppfs.c:	return &hi->vfs_inode;
fs/hppfs/hppfs.c:	struct vfsmount *proc_mnt;
fs/f2fs/super.c:	inode_init_once(&fi->vfs_inode);
fs/f2fs/super.c:	fi->vfs_inode.i_version = 1;
fs/f2fs/super.c:	return &fi->vfs_inode;
fs/f2fs/file.c:	vfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);
fs/f2fs/file.c:static loff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)
fs/f2fs/file.c:	return vfs_setpos(file, data_ofs, maxbytes);
fs/f2fs/file.c:int f2fs_getattr(struct vfsmount *mnt,
fs/f2fs/f2fs.h:	struct inode *inode;	/* vfs inode pointer */
fs/f2fs/f2fs.h:	struct inode *inode;	/* vfs inode pointer */
fs/f2fs/f2fs.h:	struct inode vfs_inode;		/* serve a vfs inode */
fs/f2fs/f2fs.h:	struct inode *inode;		/* vfs inode pointer */
fs/f2fs/f2fs.h:	struct super_block *sb;			/* pointer to VFS super block */
fs/f2fs/f2fs.h:	return container_of(inode, struct f2fs_inode_info, vfs_inode);
fs/f2fs/f2fs.h:	if (f2fs_has_inline_xattr(&fi->vfs_inode))
fs/f2fs/f2fs.h:int f2fs_getattr(struct vfsmount *, struct dentry *, struct kstat *);
fs/exportfs/expfs.c:static int get_name(struct vfsmount *mnt, struct dentry *dentry, char *name,
fs/exportfs/expfs.c:static int exportfs_get_name(struct vfsmount *mnt, struct dentry *dir,
fs/exportfs/expfs.c:reconnect_path(struct vfsmount *mnt, struct dentry *target_dir, char *nbuf)
fs/exportfs/expfs.c:static int get_name(struct vfsmount *mnt, struct dentry *dentry,
fs/exportfs/expfs.c:		error = vfs_readdir(file, filldir_one, &buffer);
fs/exportfs/expfs.c:struct dentry *exportfs_decode_fh(struct vfsmount *mnt, struct fid *fid,
fs/exportfs/expfs.c:		 * connected to the filesystem root.  The VFS really doesn't
fs/compat_ioctl.c:/* 'X' - originally XFS but some now in the VFS */
fs/compat_ioctl.c:		return do_vfs_ioctl(file, fd, cmd, arg);
fs/compat_ioctl.c:	error = do_vfs_ioctl(filp, fd, cmd, arg);
fs/internal.h:extern struct vfsmount *lookup_mnt(struct path *);
fs/internal.h:extern int finish_automount(struct vfsmount *, struct path *);
fs/internal.h:extern void mnt_make_longterm(struct vfsmount *);
fs/internal.h:extern void mnt_make_shortterm(struct vfsmount *);
fs/internal.h:DECLARE_BRLOCK(vfsmount_lock);
fs/internal.h:extern struct file *do_file_open_root(struct dentry *, struct vfsmount *,
fs/cramfs/inode.c: * These are the VFS interfaces to the compressed rom filesystem.
fs/cramfs/inode.c:#include <linux/vfs.h>
fs/ecryptfs/kthread.c: * @lower_mnt: Lower vfsmount for file to open
fs/ecryptfs/kthread.c:			     struct vfsmount *lower_mnt,
fs/ecryptfs/miscdev.c: * miscdevfs packet format:
fs/ecryptfs/miscdev.c: * @file: fs/ecryptfs/euid miscdevfs handle (ignored)
fs/ecryptfs/miscdev.c: * being sent via a miscdevfs handle, and copies it into @buf
fs/ecryptfs/Kconfig:	  Encrypted filesystem that operates on the VFS layer.  See
fs/ecryptfs/super.c:	inode = &inode_info->vfs_inode;
fs/ecryptfs/main.c:	struct vfsmount *lower_mnt = ecryptfs_dentry_to_lower_mnt(dentry);
fs/ecryptfs/main.c:	inode_init_once(&ei->vfs_inode);
fs/ecryptfs/dentry.c: * Called when the VFS needs to revalidate a dentry. This
fs/ecryptfs/dentry.c:	struct vfsmount *lower_mnt;
fs/ecryptfs/dentry.c:	struct vfsmount *vfsmount_save = NULL;
fs/ecryptfs/dentry.c:		vfsmount_save = nd->path.mnt;
fs/ecryptfs/dentry.c:		nd->path.mnt = vfsmount_save;
fs/ecryptfs/read_write.c:	rc = vfs_write(lower_file, data, size, &offset);
fs/ecryptfs/read_write.c: * written to the lower page cache (via VFS writes). This function
fs/ecryptfs/read_write.c:	rc = vfs_read(lower_file, data, size, &offset);
fs/ecryptfs/inode.c:	rc = vfs_unlink(lower_dir_inode, lower_dentry);
fs/ecryptfs/inode.c:		printk(KERN_ERR "Error in vfs_unlink; rc = [%d]\n", rc);
fs/ecryptfs/inode.c: * @nd: nameidata of ecryptfs' parent's dentry & vfsmount
fs/ecryptfs/inode.c:	rc = vfs_create(lower_dir_dentry->d_inode, lower_dentry, mode, NULL);
fs/ecryptfs/inode.c:		vfs_unlink(lower_dir_dentry->d_inode, lower_dentry);
fs/ecryptfs/inode.c: * @nd: nameidata of ecryptfs' parent's dentry & vfsmount
fs/ecryptfs/inode.c:	struct vfsmount *lower_mnt = NULL;
fs/ecryptfs/inode.c:	struct vfsmount *vfsmount_save = NULL;
fs/ecryptfs/inode.c:		vfsmount_save = nd->path.mnt;
fs/ecryptfs/inode.c:	rc = vfs_create(lower_dir_dentry->d_inode, lower_dentry, mode, nd);
fs/ecryptfs/inode.c:		nd->path.mnt = vfsmount_save;
fs/ecryptfs/inode.c:		vfs_unlink(lower_dir_dentry->d_inode, lower_dentry);
fs/ecryptfs/inode.c:	struct vfsmount *lower_mnt;
fs/ecryptfs/inode.c:	rc = vfs_link(lower_old_dentry, lower_dir_dentry->d_inode,
fs/ecryptfs/inode.c:	rc = vfs_symlink(lower_dir_dentry->d_inode, lower_dentry,
fs/ecryptfs/inode.c:	rc = vfs_mkdir(lower_dir_dentry->d_inode, lower_dentry, mode);
fs/ecryptfs/inode.c:	rc = vfs_rmdir(lower_dir_dentry->d_inode, lower_dentry);
fs/ecryptfs/inode.c:	rc = vfs_mknod(lower_dir_dentry->d_inode, lower_dentry, mode, dev);
fs/ecryptfs/inode.c:	rc = vfs_rename(lower_old_dir_dentry->d_inode, lower_old_dentry,
fs/ecryptfs/inode.c:int ecryptfs_getattr_link(struct vfsmount *mnt, struct dentry *dentry,
fs/ecryptfs/inode.c:int ecryptfs_getattr(struct vfsmount *mnt, struct dentry *dentry,
fs/ecryptfs/inode.c:	rc = vfs_getattr(ecryptfs_dentry_to_lower_mnt(dentry),
fs/ecryptfs/inode.c:	rc = vfs_setxattr(lower_dentry, name, value, size, flags);
fs/ecryptfs/file.c:	rc = vfs_readdir(lower_file, ecryptfs_filldir, (void *)&buf);
fs/ecryptfs/file.c:	return vfs_fsync(ecryptfs_file_to_lower(file), datasync);
fs/ecryptfs/ecryptfs_kernel.h:	struct inode vfs_inode;
fs/ecryptfs/ecryptfs_kernel.h: * vfsmount too. */
fs/ecryptfs/ecryptfs_kernel.h:	return container_of(inode, struct ecryptfs_inode_info, vfs_inode);
fs/ecryptfs/ecryptfs_kernel.h:static inline struct vfsmount *
fs/ecryptfs/ecryptfs_kernel.h:ecryptfs_set_dentry_lower_mnt(struct dentry *dentry, struct vfsmount *lower_mnt)
fs/ecryptfs/ecryptfs_kernel.h:	struct vfsmount *lower_mnt;
fs/ecryptfs/ecryptfs_kernel.h:			     struct vfsmount *lower_mnt,
fs/compat.c:#include <linux/vfs.h>
fs/compat.c:	error = vfs_stat(filename, &stat);
fs/compat.c:	error = vfs_lstat(filename, &stat);
fs/compat.c:	error = vfs_fstatat(dfd, filename, &stat, flag);
fs/compat.c:	int error = vfs_fstat(fd, &stat);
fs/compat.c:	int err = vfs_ustat(new_decode_dev(dev), &sbuf);
fs/compat.c:	error = vfs_readdir(file, compat_fillonedir, &buf);
fs/compat.c:	error = vfs_readdir(file, compat_filldir, &buf);
fs/compat.c:	error = vfs_readdir(file, compat_filldir64, &buf);
fs/dcache.c:int sysctl_vfs_cache_pressure __read_mostly = 100;
fs/dcache.c:EXPORT_SYMBOL_GPL(sysctl_vfs_cache_pressure);
fs/dcache.c: * be found through a VFS lookup any more. Note that this is different from
fs/dcache.c: *     dentry trees will not be rearranged by the VFS
fs/dcache.c: * This is not to be used outside core vfs.
fs/dcache.c: * __d_lookup_rcu must only be used in rcu-walk mode, ie. with vfsmount lock
fs/dcache.c: * and the sb->s_vfs_rename_mutex if they differ. See lock_rename().
fs/dcache.c:		printk(KERN_WARNING "VFS: moving negative dcache entry\n");
fs/dcache.c:	if (!mutex_trylock(&dentry->d_sb->s_vfs_rename_mutex))
fs/dcache.c:	m1 = &dentry->d_sb->s_vfs_rename_mutex;
fs/dcache.c:						"VFS: Lookup of '%s' in %s %s"
fs/dcache.c: * @path: the dentry/vfsmount to report
fs/dcache.c: * @root: root vfsmnt/dentry
fs/dcache.c:	struct vfsmount *vfsmnt = path->mnt;
fs/dcache.c:	struct mount *mnt = real_mount(vfsmnt);
fs/dcache.c:	while (dentry != root->dentry || vfsmnt != root->mnt) {
fs/dcache.c:		if (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {
fs/dcache.c:			if (dentry != vfsmnt->mnt_root) {
fs/dcache.c:			vfsmnt = &mnt->mnt;
fs/dcache.c:		error = real_mount(vfsmnt)->mnt_ns ? 1 : 2;
fs/dcache.c: * @path: the dentry/vfsmount to report
fs/dcache.c: * @root: root vfsmnt/dentry
fs/dcache.c:	br_read_lock(vfsmount_lock);
fs/dcache.c:	br_read_unlock(vfsmount_lock);
fs/dcache.c:	br_read_lock(vfsmount_lock);
fs/dcache.c:	br_read_unlock(vfsmount_lock);
fs/dcache.c:	br_read_lock(vfsmount_lock);
fs/dcache.c:	br_read_unlock(vfsmount_lock);
fs/dcache.c:	br_read_lock(vfsmount_lock);
fs/dcache.c:		br_read_unlock(vfsmount_lock);
fs/dcache.c:		br_read_unlock(vfsmount_lock);
fs/dcache.c:void __init vfs_caches_init_early(void)
fs/dcache.c:void __init vfs_caches_init(unsigned long mempages)
fs/open.c:					  struct vfsmount *mnt)
fs/open.c:static struct file *__dentry_open(struct dentry *dentry, struct vfsmount *mnt,
fs/open.c:struct file *dentry_open(struct dentry *dentry, struct vfsmount *mnt, int flags,
fs/open.c: * The VFS is full of places where we drop the files lock between
fs/open.c:struct file *file_open_root(struct dentry *dentry, struct vfsmount *mnt,
fs/open.c:		printk(KERN_ERR "VFS: Close: file count is 0\n");
fs/btrfs/super.c:	/* FIXME: need to fix VFS to return error? */
fs/btrfs/super.c:	struct vfsmount *mnt;
fs/btrfs/super.c:	mnt = vfs_kern_mount(&btrfs_fs_type, flags, device_name,
fs/btrfs/ordered-data.c:		inode = &btrfs_inode->vfs_inode;
fs/btrfs/btrfs_inode.h:	/* full 64 bit generation number, struct vfs_inode doesn't have a big
fs/btrfs/btrfs_inode.h:	struct inode vfs_inode;
fs/btrfs/btrfs_inode.h:	return container_of(inode, struct btrfs_inode, vfs_inode);
fs/btrfs/inode.c:		if (ino < btrfs_ino(&entry->vfs_inode))
fs/btrfs/inode.c:		else if (ino > btrfs_ino(&entry->vfs_inode))
fs/btrfs/inode.c:			WARN_ON(!(entry->vfs_inode.i_state &
fs/btrfs/inode.c:		if (objectid < btrfs_ino(&entry->vfs_inode))
fs/btrfs/inode.c:		else if (objectid > btrfs_ino(&entry->vfs_inode))
fs/btrfs/inode.c:			if (objectid <= btrfs_ino(&entry->vfs_inode)) {
fs/btrfs/inode.c:		objectid = btrfs_ino(&entry->vfs_inode) + 1;
fs/btrfs/inode.c:		inode = igrab(&entry->vfs_inode);
fs/btrfs/inode.c:	inode = &ei->vfs_inode;
fs/btrfs/inode.c:	inode_init_once(&ei->vfs_inode);
fs/btrfs/inode.c:static int btrfs_getattr(struct vfsmount *mnt,
fs/btrfs/inode.c:		inode = igrab(&binode->vfs_inode);
fs/btrfs/ioctl.c: * sys_mkdirat and vfs_mkdir, but we only do a single component lookup
fs/btrfs/relocation.c:		if (objectid < btrfs_ino(&entry->vfs_inode))
fs/btrfs/relocation.c:		else if (objectid > btrfs_ino(&entry->vfs_inode))
fs/btrfs/relocation.c:			if (objectid <= btrfs_ino(&entry->vfs_inode)) {
fs/btrfs/relocation.c:		inode = igrab(&entry->vfs_inode);
fs/btrfs/relocation.c:		objectid = btrfs_ino(&entry->vfs_inode) + 1;
fs/btrfs/file.c:	vfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);
fs/btrfs/disk-io.c:		vfs_check_frozen(root->fs_info->sb, SB_FREEZE_WRITE);
fs/btrfs/disk-io.c:		vfs_check_frozen(root->fs_info->sb, SB_FREEZE_WRITE);
fs/fhandle.c:static struct vfsmount *get_vfsmount_from_fd(int fd)
fs/fhandle.c:static int vfs_dentry_acceptable(void *context, struct dentry *dentry)
fs/fhandle.c:	path->mnt = get_vfsmount_from_fd(mountdirfd);
fs/fhandle.c:					  vfs_dentry_acceptable, NULL);
fs/fhandle.c: * to the vfsmount pointed by the @mountdirfd. @flags
fs/exofs/super.c:#include <linux/vfs.h>
fs/exofs/super.c:	oi->vfs_inode.i_version = 1;
fs/exofs/super.c:	return &oi->vfs_inode;
fs/exofs/super.c:	inode_init_once(&oi->vfs_inode);
fs/exofs/super.c: * This function is called when the vfs is freeing the superblock.  We just
fs/exofs/exofs.h:	struct backing_dev_info bdi;		/* register our bdi with VFS  */
fs/exofs/exofs.h:	struct inode   vfs_inode;          /* normal in-memory inode          */
fs/exofs/exofs.h:	return oi->vfs_inode.i_ino + EXOFS_OBJ_OFF;
fs/exofs/exofs.h: * get to our inode from the vfs inode
fs/exofs/exofs.h:	return container_of(inode, struct exofs_i_info, vfs_inode);
fs/exofs/inode.c:/* readpage_strip is called either directly from readpage() or by the VFS from
fs/exofs/inode.c:/* writepage_strip is called either directly from writepage() or by the VFS from
fs/exofs/inode.c:	return unlikely(is_bad_inode(&oi->vfs_inode)) ? -EIO : 0;
fs/exofs/file.c:	int ret = vfs_fsync(file, 0);
fs/namei.c: * implemented.  Let's see if raised priority of ->s_vfs_rename_mutex gives
fs/namei.c: * Given a path increment the reference count to the dentry and the vfsmount.
fs/namei.c: * Given a path decrement the reference count to the dentry and the vfsmount.
fs/namei.c:	struct vfsmount *mnt = path->mnt;
fs/namei.c: * normal reference counts on dentries and vfsmounts to transition to rcu-walk
fs/namei.c:	br_read_unlock(vfsmount_lock);
fs/namei.c:			br_read_unlock(vfsmount_lock);
fs/namei.c:		br_read_unlock(vfsmount_lock);
fs/namei.c:static __always_inline int __vfs_follow_link(struct nameidata *nd, const char *link)
fs/namei.c:			error = __vfs_follow_link(nd, s);
fs/namei.c:	br_read_lock(vfsmount_lock);
fs/namei.c:		br_read_unlock(vfsmount_lock);
fs/namei.c:	br_read_unlock(vfsmount_lock);
fs/namei.c:	struct vfsmount *mnt;
fs/namei.c:	struct vfsmount *mnt = path->mnt; /* held by caller, must be left alone */
fs/namei.c:			struct vfsmount *mounted = lookup_mnt(path);
fs/namei.c:			 * vfsmount_lock */
fs/namei.c:	struct vfsmount *mounted;
fs/namei.c:	br_read_unlock(vfsmount_lock);
fs/namei.c:			struct vfsmount *mounted = lookup_mnt(path);
fs/namei.c:		struct vfsmount *mounted = lookup_mnt(path);
fs/namei.c:	struct vfsmount *mnt = nd->path.mnt;
fs/namei.c:		br_read_unlock(vfsmount_lock);
fs/namei.c:			br_read_lock(vfsmount_lock);
fs/namei.c:			br_read_lock(vfsmount_lock);
fs/namei.c:			br_read_lock(vfsmount_lock);
fs/namei.c:			br_read_lock(vfsmount_lock);
fs/namei.c: * vfs_path_lookup - lookup a file path relative to a dentry-vfsmount pair
fs/namei.c: * @mnt: pointer to vfs mount of the base directory
fs/namei.c:int vfs_path_lookup(struct dentry *dentry, struct vfsmount *mnt,
fs/namei.c:	mutex_lock(&p1->d_inode->i_sb->s_vfs_rename_mutex);
fs/namei.c:		mutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);
fs/namei.c:int vfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,
fs/namei.c:		error = vfs_create(dir->d_inode, dentry, mode, nd);
fs/namei.c:struct file *do_file_open_root(struct dentry *dentry, struct vfsmount *mnt,
fs/namei.c:	 * From the vfs_mknod() POV we just have a negative dentry -
fs/namei.c:int vfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)
fs/namei.c:			error = vfs_create(path.dentry->d_inode,dentry,mode,NULL);
fs/namei.c:			error = vfs_mknod(path.dentry->d_inode,dentry,mode,
fs/namei.c:			error = vfs_mknod(path.dentry->d_inode,dentry,mode,0);
fs/namei.c:int vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
fs/namei.c:	error = vfs_mkdir(path.dentry->d_inode, dentry, mode);
fs/namei.c:int vfs_rmdir(struct inode *dir, struct dentry *dentry)
fs/namei.c:	error = vfs_rmdir(nd.path.dentry->d_inode, dentry);
fs/namei.c:int vfs_unlink(struct inode *dir, struct dentry *dentry)
fs/namei.c:		error = vfs_unlink(nd.path.dentry->d_inode, dentry);
fs/namei.c:int vfs_symlink(struct inode *dir, struct dentry *dentry, const char *oldname)
fs/namei.c:	error = vfs_symlink(path.dentry->d_inode, dentry, from);
fs/namei.c:int vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry)
fs/namei.c:	error = vfs_link(old_path.dentry, new_path.dentry->d_inode, new_dentry);
fs/namei.c: *	   sb->s_vfs_rename_mutex. We might be more accurate, but that's another
fs/namei.c: *	   only under ->s_vfs_rename_mutex _and_ that parent of the object we
fs/namei.c: *	   lock child" and rename is under ->s_vfs_rename_mutex.
fs/namei.c:static int vfs_rename_dir(struct inode *old_dir, struct dentry *old_dentry,
fs/namei.c:static int vfs_rename_other(struct inode *old_dir, struct dentry *old_dentry,
fs/namei.c:int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
fs/namei.c:		error = vfs_rename_dir(old_dir,old_dentry,new_dir,new_dentry);
fs/namei.c:		error = vfs_rename_other(old_dir,old_dentry,new_dir,new_dentry);
fs/namei.c:	error = vfs_rename(old_dir->d_inode, old_dentry,
fs/namei.c:int vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen, const char *link)
fs/namei.c:	res = vfs_readlink(dentry, buffer, buflen, nd_get_link(&nd));
fs/namei.c:int vfs_follow_link(struct nameidata *nd, const char *link)
fs/namei.c:	return __vfs_follow_link(nd, link);
fs/namei.c:	int res = vfs_readlink(dentry,buffer,buflen,s);
fs/namei.c:EXPORT_SYMBOL(vfs_path_lookup);
fs/namei.c:EXPORT_SYMBOL(vfs_create);
fs/namei.c:EXPORT_SYMBOL(vfs_follow_link);
fs/namei.c:EXPORT_SYMBOL(vfs_link);
fs/namei.c:EXPORT_SYMBOL(vfs_mkdir);
fs/namei.c:EXPORT_SYMBOL(vfs_mknod);
fs/namei.c:EXPORT_SYMBOL(vfs_readlink);
fs/namei.c:EXPORT_SYMBOL(vfs_rename);
fs/namei.c:EXPORT_SYMBOL(vfs_rmdir);
fs/namei.c:EXPORT_SYMBOL(vfs_symlink);
fs/namei.c:EXPORT_SYMBOL(vfs_unlink);
fs/cachefiles/bind.c:	ret = vfs_statfs(&path, &stats);
fs/cachefiles/daemon.c:	ret = vfs_statfs(&path, &stats);
fs/cachefiles/internal.h:	struct vfsmount			*mnt;		/* mountpoint holding the cache */
fs/cachefiles/namei.c: *   call vfs_unlink(), vfs_rmdir() or vfs_rename()
fs/cachefiles/namei.c:			ret = vfs_unlink(dir->d_inode, rep);
fs/cachefiles/namei.c:		ret = vfs_rename(dir->d_inode, rep,
fs/cachefiles/namei.c:			ret = vfs_mkdir(dir->d_inode, next, 0);
fs/cachefiles/namei.c:			ret = vfs_create(dir->d_inode, next, S_IFREG, NULL);
fs/cachefiles/namei.c:		ret = vfs_mkdir(dir->d_inode, subdir, 0700);
fs/cachefiles/xattr.c:	ret = vfs_setxattr(dentry, cachefiles_xattr_cache, type, 2,
fs/cachefiles/xattr.c:	ret = vfs_getxattr(dentry, cachefiles_xattr_cache, xtype, 3);
fs/cachefiles/xattr.c:	ret = vfs_setxattr(dentry, cachefiles_xattr_cache,
fs/cachefiles/xattr.c:	ret = vfs_setxattr(dentry, cachefiles_xattr_cache,
fs/cachefiles/xattr.c:	ret = vfs_getxattr(dentry, cachefiles_xattr_cache,
fs/cachefiles/xattr.c:		ret = vfs_setxattr(dentry, cachefiles_xattr_cache,
fs/cachefiles/xattr.c:	ret = vfs_removexattr(dentry, cachefiles_xattr_cache);
fs/fat/fat.h:	struct inode vfs_inode;
fs/fat/fat.h:	return container_of(inode, struct msdos_inode_info, vfs_inode);
fs/fat/fat.h:extern int fat_getattr(struct vfsmount *mnt, struct dentry *dentry,
fs/fat/inode.c:#include <linux/vfs.h>
fs/fat/inode.c:		BUG_ON(i->vfs_inode.i_sb != sb);
fs/fat/inode.c:		inode = igrab(&i->vfs_inode);
fs/fat/inode.c:	return &ei->vfs_inode;
fs/fat/inode.c:	inode_init_once(&ei->vfs_inode);
fs/fat/file.c:int fat_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
fs/pnode.c: * vfsmount lock must be held for write
fs/pnode.c: * vfsmount found while iterating with propagation_next() is
fs/pnode.c:	br_write_lock(vfsmount_lock);
fs/pnode.c:	br_write_unlock(vfsmount_lock);
fs/pnode.c: * vfsmount lock must be held for write
fs/pnode.c: * vfsmount lock must be held for write
fs/debugfs/inode.c:static struct vfsmount *debugfs_mount;
fs/debugfs/inode.c:	 * block. A pointer to that is in the struct vfsmount that we
fs/ncpfs/ncp_fs_i.h:	struct inode vfs_inode;
fs/ncpfs/inode.c:#include <linux/vfs.h>
fs/ncpfs/inode.c:	return &ei->vfs_inode;
fs/ncpfs/inode.c:	inode_init_once(&ei->vfs_inode);
fs/ncpfs/ncp_fs.h:	return container_of(inode, struct ncp_inode_info, vfs_inode);
fs/ncpfs/symlink.c:	/* EPERM is returned by VFS if symlink procedure does not exist */
fs/jfs/super.c:#include <linux/vfs.h>
fs/jfs/super.c:	return &jfs_inode->vfs_inode;
fs/jfs/super.c:	inode_init_once(&jfs_ip->vfs_inode);
fs/jfs/jfs_incore.h:	 * directories since the i_mutex taken in the VFS is sufficient.
fs/jfs/jfs_incore.h:	struct inode	vfs_inode;
fs/jfs/jfs_incore.h:	struct super_block *sb;		/* Point back to vfs super block */
fs/jfs/jfs_incore.h:	return list_entry(inode, struct jfs_inode_info, vfs_inode);
fs/jfs/jfs_mount.c: * each vfs represents a fileset, and points to its "fileset inode
fs/jfs/jfs_mount.c: * an internal vfs is constructed and points to its "fileset inode
fs/jfs/jfs_mount.c: * each vnode/inode of a fileset is linked to its vfs (to facilitate
fs/jfs/jfs_mount.c: *   mntvfs -> fileset ipimap+ -> aggregate ipbmap -> aggregate ipaimap;
fs/jfs/jfs_mount.c: *             fileset vfs     -> vp(1) <-> ... <-> vp(n) <->vproot;
fs/jfs/jfs_mount.c: * FUNCTION:	vfs_mount()
fs/jfs/jfs_mount.c:	 * hand craft a vfs in the same fashion as we did to read ipaimap.
fs/jfs/jfs_umount.c: * NAME:	jfs_umount(vfsp, flags, crp)
fs/jfs/jfs_umount.c: * FUNCTION:	vfs_umount()
fs/jfs/jfs_umount.c: * PARAMETERS:	vfsp	- virtual file system pointer
fs/jfs/jfs_inode.c:	unsigned int flags = jfs_ip->vfs_inode.i_flags;
fs/jfs/jfs_superblock.h:				 * VFS: number of blocks
fs/jfs/jfs_superblock.h:				 * VFS: fragment size
fs/jfs/jfs_txnmgr.c:		ip = &jfs_ip->vfs_inode;
fs/jfs/jfs_txnmgr.c:			ip = &jfs_ip->vfs_inode;
fs/jfs/jfs_dtree.c:		 * the value we return to the vfs is one greater than the
fs/jfs/namei.c:	 * The vfs does the hard part for us.  Any time we are taking nested
fs/jfs/namei.c:	 * commit_mutexes, the vfs already has i_mutex held on the parent.
fs/jfs/namei.c:	 * Here, the vfs has already taken i_mutex on both old_dir and new_dir.
fs/jfs/xattr.c: * Most of the permission checking is done by xattr_permission in the vfs.
fs/exec.c:	result = vfs_read(file, (void __user *)addr, count, &pos);
fs/fuse/dir.c: * different inode, then let the VFS invalidate the dentry and redo
fs/fuse/dir.c:static int fuse_getattr(struct vfsmount *mnt, struct dentry *entry,
fs/fuse/inode.c:	 * Don't set the sticky bit in i_mode, unless we want the VFS
fs/fuse/file.c:	/* Hold vfsmount and dentry until release is finished */
fs/fuse/file.c:	/* return value is ignored by VFS */
fs/fuse/file.c:	vfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);
fs/locks.c:static int __vfs_setlease(struct file *filp, long arg, struct file_lock **lease)
fs/locks.c: *	vfs_setlease        -       sets a lease on an open file
fs/locks.c: *	leases in certain cases.  More vfs changes may be required to
fs/locks.c:int vfs_setlease(struct file *filp, long arg, struct file_lock **lease)
fs/locks.c:	error = __vfs_setlease(filp, arg, lease);
fs/locks.c:EXPORT_SYMBOL_GPL(vfs_setlease);
fs/locks.c:	return vfs_setlease(filp, F_UNLCK, &flp);
fs/locks.c:	error = __vfs_setlease(filp, arg, &ret);
fs/locks.c: * vfs_test_lock - test file byte range lock
fs/locks.c:int vfs_test_lock(struct file *filp, struct file_lock *fl)
fs/locks.c:EXPORT_SYMBOL_GPL(vfs_test_lock);
fs/locks.c:	error = vfs_test_lock(filp, &file_lock);
fs/locks.c: * vfs_lock_file - file byte range lock
fs/locks.c: * grants a lock so the VFS can find out which locks are locally held and do
fs/locks.c:int vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)
fs/locks.c:EXPORT_SYMBOL_GPL(vfs_lock_file);
fs/locks.c:		error = vfs_lock_file(filp, cmd, fl, NULL);
fs/locks.c:	error = vfs_test_lock(filp, &file_lock);
fs/locks.c:	vfs_lock_file(filp, F_SETLK, &lock, NULL);
fs/locks.c: * vfs_cancel_lock - file byte range unblock lock
fs/locks.c:int vfs_cancel_lock(struct file *filp, struct file_lock *fl)
fs/locks.c:EXPORT_SYMBOL_GPL(vfs_cancel_lock);
fs/ubifs/journal.c: * get_dent_type - translate VFS inode mode to UBIFS directory entry type.
fs/ubifs/journal.c: * @ui->dirty flag and releasing its budget. Note, VFS may still treat the
fs/ubifs/budget.c: * Note, this function synchronizes even VFS inodes which are locked
fs/ubifs/budget.c:	down_read(&c->vfs_sb->s_umount);
fs/ubifs/budget.c:	writeback_inodes_sb(c->vfs_sb, WB_REASON_FS_FREE_SPACE);
fs/ubifs/budget.c:	up_read(&c->vfs_sb->s_umount);
fs/ubifs/debug.c:	inode = ilookup(c->vfs_sb, inum);
fs/ubifs/debug.c:	 * If the inode is present in the VFS inode cache, use it instead of
fs/ubifs/debug.c:	 *      inode size in the VFS cache, but on on-flash.
fs/ubifs/super.c: * This file implements UBIFS initialization and VFS superblock operations. Some
fs/ubifs/super.c:	return &ui->vfs_inode;
fs/ubifs/super.c:	 * also happen if it was synchronized in an VFS operation, e.g.
fs/ubifs/super.c:			struct super_block *sb = c->vfs_sb;
fs/ubifs/super.c:	c->ro_mount = !!(c->vfs_sb->s_flags & MS_RDONLY);
fs/ubifs/super.c: * We assume VFS has stopped writing. Possibly the background thread could be
fs/ubifs/super.c:	c->vfs_sb = sb;
fs/ubifs/super.c:	inode_init_once(&ui->vfs_inode);
fs/ubifs/super.c:		ubifs_err("VFS page cache size is %u bytes, but UBIFS requires"
fs/ubifs/dir.c:	inode = new_inode(c->vfs_sb);
fs/ubifs/dir.c:	 * Set 'S_NOCMTIME' to prevent VFS form updating [mc]time of inodes and
fs/ubifs/dir.c: * vfs_dent_type - get VFS directory entry type.
fs/ubifs/dir.c: * This function converts UBIFS directory entry type into VFS directory entry
fs/ubifs/dir.c:static unsigned int vfs_dent_type(uint8_t type)
fs/ubifs/dir.c: * (name, inode number) entries. Linux/VFS assumes this model as well.
fs/ubifs/dir.c:			       vfs_dent_type(dent->type));
fs/ubifs/dir.c: * VFS has already done it for us on the @i_mutex. So this is just a simple
fs/ubifs/dir.c: * @dir: VFS inode object of the directory to check
fs/ubifs/dir.c: * VFS has already done it for us on the @i_mutex. So this is just a simple
fs/ubifs/dir.c:int ubifs_getattr(struct vfsmount *mnt, struct dentry *dentry,
fs/ubifs/recovery.c:				inode = ubifs_iget(c->vfs_sb, e->inum);
fs/ubifs/misc.h: * ubifs_inode - get UBIFS inode information by VFS 'struct inode' object.
fs/ubifs/misc.h: * @inode: the VFS 'struct inode' pointer
fs/ubifs/misc.h:	return container_of(inode, struct ubifs_inode, vfs_inode);
fs/ubifs/commit.c: * (as permitted by the TNC mutex), or access to VFS data structures e.g. page
fs/ubifs/sb.c:	c->vfs_sb->s_time_gran = le32_to_cpu(sup->time_gran);
fs/ubifs/ioctl.c: * ubifs_set_inode_flags - set VFS inode flags.
fs/ubifs/ioctl.c: * @inode: VFS inode to set flags for
fs/ubifs/ioctl.c: * This function propagates flags from UBIFS inode object to VFS inode object.
fs/ubifs/file.c: * This file implements VFS file and inode operations for regular files, device
fs/ubifs/file.c: * A thing to keep in mind: inode @i_mutex is locked in most VFS operations we
fs/ubifs/file.c:		 * VFS copied less data to the page that it intended and
fs/ubifs/file.c:		 * Return 0 to force VFS to repeat the whole operation, or the
fs/ubifs/file.c: * When writing-back dirty inodes, VFS first writes-back pages belonging to the
fs/ubifs/file.c: * @i_mutex, which means other VFS operations may be run on this inode at the
fs/ubifs/file.c: * This function implements VFS '->setattr()' call when the inode is truncated
fs/ubifs/file.c: * This function implements VFS '->setattr()' call for all cases except
fs/ubifs/file.c:		 * For some really strange reasons VFS does not filter out
fs/ubifs/io.c:		c->vfs_sb->s_flags |= MS_RDONLY;
fs/ubifs/ubifs.h:/* UBIFS file system VFS magic number */
fs/ubifs/ubifs.h:/* Number of UBIFS blocks per VFS page */
fs/ubifs/ubifs.h: * @vfs_inode: VFS inode description object
fs/ubifs/ubifs.h: * @ui_mutex: serializes inode write-back with the rest of VFS operations,
fs/ubifs/ubifs.h: * being written back while UBIFS changing them, being in the middle of an VFS
fs/ubifs/ubifs.h: * actually). But unfortunately, VFS marks inodes dirty in many places, and it
fs/ubifs/ubifs.h:	struct inode vfs_inode;
fs/ubifs/ubifs.h: * @vfs_sb: VFS @struct super_block object
fs/ubifs/ubifs.h: * @bdi: backing device info object to make VFS happy and disable read-ahead
fs/ubifs/ubifs.h:	struct super_block *vfs_sb;
fs/ubifs/ubifs.h:int ubifs_getattr(struct vfsmount *mnt, struct dentry *dentry,
fs/ubifs/xattr.c: * in the VFS inode cache. The xentries are cached in the LNC cache (see
fs/ubifs/xattr.c:	inode = ubifs_iget(c->vfs_sb, inum);
fs/ubifs/tnc.c: * and over again. Most things are cached by VFS, however the file system must
fs/bfs/bfs.h:	struct inode vfs_inode;
fs/bfs/bfs.h:	return container_of(inode, struct bfs_inode_info, vfs_inode);
fs/bfs/inode.c:#include <linux/vfs.h>
fs/bfs/inode.c:	return &bi->vfs_inode;
fs/bfs/inode.c:	inode_init_once(&bi->vfs_inode);
fs/autofs4/autofs_i.h:int autofs4_expire_run(struct super_block *, struct vfsmount *,
fs/autofs4/autofs_i.h:int autofs4_do_expire_multi(struct super_block *sb, struct vfsmount *mnt,
fs/autofs4/autofs_i.h:int autofs4_expire_multi(struct super_block *, struct vfsmount *,
fs/autofs4/autofs_i.h:				     struct vfsmount *mnt,
fs/autofs4/autofs_i.h:				       struct vfsmount *mnt,
fs/autofs4/autofs_i.h:/* VFS automount flags management functions */
fs/autofs4/dev-ioctl.c:	struct vfsmount *mnt;
fs/autofs4/root.c:static struct vfsmount *autofs4_d_automount(struct path *);
fs/autofs4/root.c:static struct vfsmount *autofs4_d_automount(struct path *path)
fs/autofs4/root.c: * Normal filesystems would do a "d_delete()" to tell the VFS dcache
fs/autofs4/root.c: * VFS layer can turn the dentry into a negative dentry.  We don't want
fs/autofs4/root.c:static inline int autofs4_ask_umount(struct vfsmount *mnt, int __user *p)
fs/autofs4/expire.c:static int autofs4_mount_busy(struct vfsmount *mnt, struct dentry *dentry)
fs/autofs4/expire.c:static int autofs4_direct_busy(struct vfsmount *mnt,
fs/autofs4/expire.c:static int autofs4_tree_busy(struct vfsmount *mnt,
fs/autofs4/expire.c:static struct dentry *autofs4_check_leaves(struct vfsmount *mnt,
fs/autofs4/expire.c:				     struct vfsmount *mnt,
fs/autofs4/expire.c:				       struct vfsmount *mnt,
fs/autofs4/expire.c:		      struct vfsmount *mnt,
fs/autofs4/expire.c:int autofs4_do_expire_multi(struct super_block *sb, struct vfsmount *mnt,
fs/autofs4/expire.c:int autofs4_expire_multi(struct super_block *sb, struct vfsmount *mnt,
fs/xattr.c:	 * No restriction for security.* and system.* from the VFS.  Decision
fs/xattr.c: *  __vfs_setxattr_noperm - perform setxattr operation without performing
fs/xattr.c:int __vfs_setxattr_noperm(struct dentry *dentry, const char *name,
fs/xattr.c:vfs_setxattr(struct dentry *dentry, const char *name, const void *value,
fs/xattr.c:	error = __vfs_setxattr_noperm(dentry, name, value, size, flags);
fs/xattr.c:EXPORT_SYMBOL_GPL(vfs_setxattr);
fs/xattr.c: * vfs_getxattr_alloc - allocate memory, if necessary, before calling getxattr
fs/xattr.c:vfs_getxattr_alloc(struct dentry *dentry, const char *name, char **xattr_value,
fs/xattr.c:int vfs_xattr_cmp(struct dentry *dentry, const char *xattr_name,
fs/xattr.c:	rc = vfs_getxattr_alloc(dentry, xattr_name, &xattr_value, 0, flags);
fs/xattr.c:vfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)
fs/xattr.c:EXPORT_SYMBOL_GPL(vfs_getxattr);
fs/xattr.c:vfs_listxattr(struct dentry *d, char *list, size_t size)
fs/xattr.c:EXPORT_SYMBOL_GPL(vfs_listxattr);
fs/xattr.c:vfs_removexattr(struct dentry *dentry, const char *name)
fs/xattr.c:EXPORT_SYMBOL_GPL(vfs_removexattr);
fs/xattr.c:	error = vfs_setxattr(d, kname, kvalue, size, flags);
fs/xattr.c:	error = vfs_getxattr(d, kname, kvalue, size);
fs/xattr.c:	error = vfs_listxattr(d, klist, size);
fs/xattr.c:	return vfs_removexattr(d, kname);
fs/yaffs2/yaffs_vfs.c: * the VFS.
fs/yaffs2/yaffs_vfs.c: * NB There are two variants of Linux VFS glue code. This variant supports
fs/yaffs2/yaffs_vfs.c: * The VFS layer already does all the dentry stuff for rename.
fs/yaffs2/yaffs_vfs.c:	ret = vfs_readlink(dentry, buffer, buflen, alias);
fs/yaffs2/yaffs_guts.c:				/* Don't tell the VFS about this one if it is defered free */
fs/yaffs2/Makefile:yaffs-y := yaffs_ecc.o yaffs_vfs.o yaffs_guts.o yaffs_checkptrw.o
block/partitions/efi.c: * - Removed CONFIG_DEVFS_VOLUMES_UUID code entirely per Martin Wilck
block/partitions/efi.c: * - added devfs volume UUID support (/dev/volumes/uuids) for
lib/Kconfig.debug:	  vfsmount.  This will increase the size of each file struct by
kernel/power/main.c:#ifdef CONFIG_SEC_DVFS
kernel/power/main.c:#ifdef CONFIG_SEC_DVFS
kernel/power/main.c:DEFINE_MUTEX(dvfs_mutex);
kernel/power/main.c:static unsigned long dvfs_id;
kernel/power/main.c:	mutex_lock(&dvfs_mutex);
kernel/power/main.c:		dvfs_id &= ~id;
kernel/power/main.c:		dvfs_id |= id;
kernel/power/main.c:	if (id == DVFS_APPS_MIN_ID)
kernel/power/main.c:	else if (id == DVFS_APPS_MAX_ID)
kernel/power/main.c:	else if (id == DVFS_THERMALD_ID)
kernel/power/main.c:	else if (id == DVFS_TOUCH_ID)
kernel/power/main.c:	if (dvfs_id & DVFS_APPS_MIN_ID && min < apps_min_freq)
kernel/power/main.c:	if (dvfs_id & DVFS_TOUCH_ID && min < touch_min_freq)
kernel/power/main.c:	if (dvfs_id & DVFS_APPS_MAX_ID && max > apps_max_freq)
kernel/power/main.c:	if (dvfs_id & DVFS_THERMALD_ID && max > thermald_max_freq)
kernel/power/main.c:	if (dvfs_id & DVFS_UNICPU_ID && max > unicpu_max_freq)
kernel/power/main.c:	mutex_unlock(&dvfs_mutex);
kernel/power/main.c:	set_freq_limit(DVFS_APPS_MIN_ID, freq_min_limit);
kernel/power/main.c:	set_freq_limit(DVFS_APPS_MAX_ID, freq_max_limit);
kernel/power/main.c:#ifdef CONFIG_SEC_DVFS
kernel/power/main.c:#ifdef CONFIG_SEC_DVFS
kernel/acct.c:#include <linux/vfs.h>
kernel/acct.c:	if (vfs_statfs(&file->f_path, &sbuf))
kernel/acct.c:	struct vfsmount *mnt;
kernel/acct.c: * @m: vfsmount being shut down
kernel/acct.c:void acct_auto_close_mnt(struct vfsmount *m)
kernel/audit_watch.c:					  struct fsnotify_mark *vfsmount_mark,
kernel/audit_watch.c:				    struct fsnotify_mark *vfsmount_mark,
kernel/audit_tree.c:static int compare_root(struct vfsmount *mnt, void *arg)
kernel/audit_tree.c:		struct vfsmount *root_mnt;
kernel/audit_tree.c:static int tag_mount(struct vfsmount *mnt, void *arg)
kernel/audit_tree.c:	struct vfsmount *mnt;
kernel/audit_tree.c:	struct vfsmount *tagged;
kernel/audit_tree.c:				   struct fsnotify_mark *vfsmonut_mark,
kernel/audit_tree.c:				  struct fsnotify_mark *vfsmount_mark,
kernel/sysctl.c:		.procname	= "vfs_cache_pressure",
kernel/sysctl.c:		.data		= &sysctl_vfs_cache_pressure,
kernel/sysctl.c:		.maxlen		= sizeof(sysctl_vfs_cache_pressure),
kernel/cgroup.c:	/* the vfs holds inode->i_mutex already */
kernel/cgroup.c:	/* the vfs holds both inode->i_mutex already */
kernel/auditsc.c:	struct cpu_vfs_cap_data caps;
kernel/auditsc.c:	rc = get_vfs_caps_from_disk(dentry, &caps);
kernel/auditsc.c:	name->fcap.fE = !!(caps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);
kernel/auditsc.c:	name->fcap_ver = (caps.magic_etc & VFS_CAP_REVISION_MASK) >> VFS_CAP_REVISION_SHIFT;
kernel/auditsc.c:	struct cpu_vfs_cap_data vcaps;
kernel/auditsc.c:	get_vfs_caps_from_disk(dentry, &vcaps);
kernel/auditsc.c:	ax->fcap.fE = !!(vcaps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);
kernel/auditsc.c:	ax->fcap_ver = (vcaps.magic_etc & VFS_CAP_REVISION_MASK) >> VFS_CAP_REVISION_SHIFT;
kernel/relay.c: *	Useful to do early tracing in kernel, before VFS is up, for example.
kernel/latencytop.c: * 70 59433 4897 i915_irq_wait drm_ioctl vfs_ioctl do_vfs_ioctl sys_ioctl
kernel/sysctl_binary.c:	{ CTL_INT,	VM_VFS_CACHE_PRESSURE,	"vfs_cache_pressure" },
kernel/sysctl_binary.c:		result = vfs_read(file, oldval, oldlen, &pos);
kernel/sysctl_binary.c:		result = vfs_write(file, newval, newlen, &pos);
kernel/sysctl_binary.c:		result = vfs_read(file, buffer, BUFSZ - 1, &pos);
kernel/sysctl_binary.c:		result = vfs_write(file, buffer, str - buffer, &pos);
kernel/sysctl_binary.c:		result = vfs_read(file, buffer, BUFSZ - 1, &pos);
kernel/sysctl_binary.c:		result = vfs_write(file, buffer, str - buffer, &pos);
kernel/sysctl_binary.c:		result = vfs_read(file, buf, sizeof(buf) - 1, &pos);
kernel/sysctl_binary.c:		result = vfs_read(file, buf, sizeof(buf) - 1, &pos);
kernel/sysctl_binary.c:		result = vfs_write(file, buf, len, &pos);
kernel/sysctl_binary.c:	struct vfsmount *mnt;
